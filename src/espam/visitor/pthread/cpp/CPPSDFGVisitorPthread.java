package espam.visitor.pthread.cpp;

import espam.datamodel.graph.csdf.*;
import espam.datamodel.graph.csdf.datasctructures.MemoryUnit;
import espam.datamodel.graph.csdf.datasctructures.Tensor;
import espam.utils.fileworker.FileWorker;
import espam.visitor.sesame.cpp.CPPSDFGVisitor;

import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;

public class CPPSDFGVisitorPthread extends CPPSDFGVisitor {
    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///

     /**
     * Call CPP SDFG Visitor
     * @param y  corresponding CSDFNode
     * @param dir directory for .cpp templates
     */
     @Override
     public void callVisitor(CSDFNode y, String dir){
         try {
             _printStream = FileWorker.openFile(dir, y.getName(), "cpp");
             _writeCommonCppBeginning(y.getName());
             _writeAdditionalLibraries();
             _writeCppConstructorAndDestructor(y);
             _writeMain(y);
         }
         catch (Exception e){
             System.err.println(".cpp file creation error for node" + y.getName() + " " + e.getMessage());
         }
     }

    /**
     * generate main class template contains R/W primitives description
     * and other common stuff.
     */
    public void generateMainClassTemplate(String dir, CSDFGraph sdfg){
        try {
            _printStream = FileWorker.openFile(dir, _mainClassName, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("");
            _addAllClassesHeaders(sdfg);
            _writeMainClassCPPBeginning();
            _writeNoBaseCppConstructorAndDestructor(_mainClassName);
            _writeMainClassMain(sdfg);
            _printStream.close();
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

      /**
     * generate main class template contains R/W primitives description
     * and other common stuff.
     */
    public void generateFuncClassTemplate(String dir){
        try {
            _printStream = FileWorker.openFile(dir, _funcClassName, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("");
            _writeFuncClassCPPBeginning();
            _writeNoBaseCppConstructorAndDestructor(_funcClassName);
            _writeFunctions();
            _printStream.close();
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _funcClassName + " " + e.getMessage());
        }
    }

     /**
     * generate main class template contains R/W primnitives description
     * and other common stuff.
     */
    public void generateBaseClassTemplate(String dir){
        try {
            String className = "csdfNode";
            _printStream = FileWorker.openFile(dir, className, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("#include \"" + _baseClassName + ".h\"");
            _printStream.println(className + "::" + className + "() {}");
            _printStream.println(className + "::~" + className + "() {}");
            _printStream.println("");
            _printStream.println("//virtual main function");
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

    /**
     * Write common beginning for all generated nodes, contains:
     *  - definition of header
     *  - definition of standard libraries
     *  - definition of namespace
     * @param className name of the .cpp class
     */
    @Override
    protected void _writeCommonCppBeginning(String className){
        _printStream.println("// File automatically generated by ESPAM");
        _printStream.println("");
         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include \""+ className + ".h\"");
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include \"" + _baseClassName + ".h\"");
        _printStream.println("#include \""+_mainClassName+".h\"");
        _printStream.println("#include \""+_funcClassName+".h\"");
        /** include existing primitives definition*/
        _printStream.println("#include \"fifo.h\"");
        _printStream.println("#include <cstddef>");
        _printStream.println("#include \"types.h\"");
        //include null
        _printStream.println("#include <vector>");
        _printStream.println("#include <string>");
        _printStream.println("using namespace std;");
        _printStream.println("");


    }

    /**
     * Write application main class .cpp beginning
     */
    protected void _writeMainClassCPPBeginning(){

         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include <map>");
        _printStream.println("#include <vector>");
        _printStream.println("#include \"" + _baseClassName + ".h\"");
        _printStream.println("#include \""+_mainClassName+".h\"");
        _printStream.println("#include \""+_funcClassName+".h\"");
        /** include existing primitives definition*/
        _printStream.println("#include \"fifo.h\"");
        _printStream.println("#include <cstddef>");
        _printStream.println("#include \"types.h\"");
        _printStream.println("#include <thread>");

        _printStream.println("using namespace std;");
        _printStream.println("");
    }

    /**
     * Write application main class .cpp beginning
     */
    protected void _writeFuncClassCPPBeginning(){

         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include <string>");
        _printStream.println("#include <vector>");
        _printStream.println("#include <map>");
        _printStream.println("#include \"" + _funcClassName + ".h\"");
        /**TODO replace by real API*/
        _printStream.println("#include \"dnnFunc.h\"");
        _printStream.println("#include \"types.h\"");
        /** include existing primitives definition*/
        _printStream.println("#include <cstddef>");
        _printStream.println("using namespace std;");
        _printStream.println("");
    }

     /**
     * Write main function for the node
     * @param y SDF Node
     */
    @Override
    protected void _writeMain(CSDFNode y) {
        _printStream.println("void " + y.getName() + "::main(void *threadarg) {");
        _prefixInc();
        _createCommunicationChannel(y);
        _printStream.println(_prefix + "// repetition parameters definition");
        _printStream.println(_prefix + "int q = " + y.getRepetitions() + ";");
        _printStream.println(_prefix + "int phase_len = " + y.getLength() + ";");
        _printStream.println(_prefix + "int phase; ");
         _printStream.println(" ");
        _printStream.println(_prefix + "// while (1) {");
        _prefixInc();
        _printStream.println(_prefix + "// loop over the repetitions number");
        _printStream.println(_prefix + "for (int rep = 0; rep < q ; rep ++) {");
        _prefixInc();
        _printStream.println(_prefix + "phase = rep % phase_len;");
        _processReading(y);
        _processExecution(y);
        _processWriting(y);
        _prefixDec();
        _printStream.println(_prefix + "}// loop over the phases");
        _prefixDec();
        _printStream.println(_prefix + "cout<<\" " + y.getName() + " finished! \"<<endl;");
        _printStream.println(_prefix + "//} while (1)");
        _prefixDec();
        _printStream.println(_prefix + "} // main");
    }


      /**
      * process execution phase.
      * Execution describes processing of input data
      * by elementary operations. The general format is
      * for(each kernel in kernels)
      *     for(repetition on data chunk)
      *         run elementary operation;
      *
      * Where number of kernels (operation instances, processing the same data
      * with different context) = number of neurons of DNN block
      * and =1 by default
      *
      * @param node SDF Node
     *  @param execPrimitiveName name of the execution primitive
     */
    @Override
    protected void _processExecution(CSDFNode node,String execPrimitiveName){
      int kernels = node.getKernelsNum();
      if(kernels>1)
          _processExecutionMultiKernels(node,execPrimitiveName,kernels);
      else
          _processExecutionOneKernel(node, execPrimitiveName);
    }

    /**TODO checkout: multi-kernel node have one input and one output (LB-model)
     * TODO refactoring on CONV operator
     * Process execution, when kernels number > 1
     * @param node CSFDF node
     * @param execPrimitiveName
     */
    protected void _processExecutionMultiKernels(CSDFNode node,String execPrimitiveName, int kernels){
      int opRepetitionsNum = node.getOperationRepetitionsNumber();
      if(opRepetitionsNum==0)
          return;
      String operation = node.getOperation();
      if(operation==null)
          return;

      _printStream.println("");
      _printStream.println(_prefix + "//execution");
      _printStream.println(_prefix + "//execution parameters");


      /** input*/
      CSDFPort inp = node.getNonOverlapHandlingInPorts().firstElement();
      if(inp==null){
          _printStream.println(_prefix + "cout<<\"" + node.getName() + "EXEC ERROR: no input found!\"<<endl;");
          return;
      }

      MemoryUnit inp_mu = inp.getAssignedMemory();
      String inp_desc ="&" + inp_mu.getName();
      for(int i=0; i<inp_mu.getDimensionality(); i++)
          inp_desc+="[0]";

      /**weights*/
      MemoryUnit w_mu = node.getMemoryUnit("weights");
      String w_desc;
      if(w_mu==null)
          w_desc ="NULL";
      else {
          w_desc ="&" + w_mu.getName();
           w_desc+="[n]";
            for(int i=0; i<w_mu.getDimensionality()-1; i++)
                w_desc+="[0]";
      }

      /**output*/
      CSDFPort outp = node.getNonOverlapHandlingOutPorts().firstElement();
      if(inp==null){
          _printStream.println(_prefix + "cout<<\"" + node.getName() + "EXEC ERROR: no output found!\"<<endl;");
          return;
      }

      MemoryUnit outp_mu = outp.getAssignedMemory();

      String outp_desc ="&" + outp_mu.getName() + "[n]";


      for(int i=0; i<outp_mu.getDimensionality()-1; i++)
          outp_desc+="[0]";

      prefixInc();
      _printStream.println(_prefix + "for (int n = 0; n < " + kernels + "; n++) {");


    /**  if(opRepetitionsNum>1){
          prefixInc();
          _printStream.println(_prefix + "for (int i = 0; i < " + opRepetitionsNum + "; i++) {");
      } */


      //exec primitive call, format : exec(input, weights, output, vector<int*>* int_params_ptr);
      _printStream.print(_prefix + execPrimitiveName +"(std::string(\"" + operation + "\"),");

      _printStream.print(inp_desc + ", ");
      _printStream.print(w_desc + ", ");
      _printStream.print(outp_desc + ", ");
      _printStream.println("&int_params);");

    /**  if(opRepetitionsNum>1) {
          prefixDec();
          _printStream.println(_prefix + "}");
      } */

         prefixDec();
         _printStream.println(_prefix + "}");
    }


    /**
     * Process execution, when kernels number == 1
     * @param node
     * @param execPrimitiveName
     */
    protected void _processExecutionOneKernel(CSDFNode node,String execPrimitiveName){
      int opRepetitionsNum = node.getOperationRepetitionsNumber();
      if(opRepetitionsNum==0)
          return;
      String operation = node.getOperation();
      if(operation==null)
          return;

      _printStream.println("");
      _printStream.println(_prefix + "//execution");


      /** input*/
      CSDFPort inp = node.getNonOverlapHandlingInPorts().firstElement();
      if(inp==null){
          _printStream.println(_prefix + "cout<<\"" + node.getName() + "EXEC ERROR: no input found!\"<<endl;");
          return;
      }

      MemoryUnit inp_mu = inp.getAssignedMemory();
      String inp_desc ="&" + inp_mu.getName();
      for(int i=0; i<inp_mu.getDimensionality(); i++)
          inp_desc+="[0]";

      /**weights*/
      MemoryUnit w_mu = node.getMemoryUnit("weights");
      String w_desc;
      if(w_mu==null)
          w_desc ="NULL";
      else {
          w_desc ="&" + w_mu.getName();
            for(int i=0; i<w_mu.getDimensionality(); i++)
                w_desc+="[0]";
      }

      /**output*/
           /** input*/
      CSDFPort outp = node.getNonOverlapHandlingOutPorts().firstElement();
      if(inp==null){
          _printStream.println(_prefix + "cout<<\"" + node.getName() + "EXEC ERROR: no output found!\"<<endl;");
          return;
      }

      MemoryUnit outp_mu = outp.getAssignedMemory();
      String outp_desc ="&" + outp_mu.getName();
      for(int i=0; i<outp_mu.getDimensionality(); i++)
          outp_desc+="[0]";

      Vector<CSDFPort> inports = node.getNonOverlapHandlingInPorts();

      if(opRepetitionsNum>1){
          prefixInc();
          _printStream.println(_prefix + "for (int i = 0; i < " + opRepetitionsNum + "; i++) {");
      }


      //exec primitive call, format : exec(input, weights, output, vector<int*>* int_params_ptr);
      _printStream.print(_prefix + execPrimitiveName +"(std::string(\"" + operation + "\"),");
     _printStream.print(inp_desc + ", ");
      _printStream.print(w_desc + ", ");
      _printStream.print(outp_desc + ", ");
      _printStream.println("&int_params);");


      if(opRepetitionsNum>1) {
          prefixDec();
          _printStream.println(_prefix + "}");
      }

    }



    /**
     * TODO more fifos for general model
     * Create FIFO communication channel
     */
    protected void _createCommunicationChannel(CSDFNode node){

        _printStream.println(_prefix + "// create communication channel");
        _printStream.println(_prefix + "thread_info *thread_data;");
        _printStream.println(_prefix + "thread_data = (struct thread_info *) threadarg;");

        for(CSDFPort inport:node.getNonOverlapHandlingInPorts())
            _createCommunicationChannel(node.getName(),inport.getName(),false);

        for(CSDFPort outport:node.getNonOverlapHandlingOutPorts())
            _createCommunicationChannel(node.getName(),outport.getName(),true);

        _printStream.println(" ");
        _printStream.println(_prefix + "setaffinity(thread_data->core_id);");

    }

    /**
     * Create FIFO communication channel
     */
    protected void _createCommunicationChannel(String nodeName, String portName, boolean isOutPort){
        String getByPostfix = "dst";
        if(isOutPort)
            getByPostfix = "src";

        String bufName = nodeName + "_" + portName;
        _printStream.println(_prefix + "fifo_buf* " + bufName +
                "_buf_ptr = thread_data->get_fifo_buf_by_" + getByPostfix +"(\"" + bufName + "\");");
        _printStream.println(" ");
    }

    /**
     * TODO refactoring on idea
     * mention all available nodes
     */
    protected void  _addAllClassesHeaders(CSDFGraph csdfG){
         Iterator i = csdfG.getNodeList().iterator();
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            _printStream.println("#include \""+ node.getName() + ".h\"");
        }
    }

    /**
     * Write application main class .cpp beginning
     */
    protected void _writeFunctions(){
        _printStream.println(_prefix + "// Execution function primitive");
        prefixInc();
        _writeExecPrimitive();
        _writeExecPrimitive("int");
        prefixDec();
        _printStream.println("");
        _printStream.println(_prefix + "// Data shift function (for shifting overlapping data in I/O arrays)");
        prefixInc();
        _writeCPULine("int");
        _writeCPULine("float");
        _writeShiftFunctions();
        _writePrintFunctions();
        _writeGetBufFuncs();
        prefixDec();
    }

    /**
     * Write main function of the main class
     */
    protected void _writeMainClassMain(CSDFGraph csdfg){
        _printStream.println("// Main function");
        _prefixInc();
        _printStream.println(_prefix + "void " + _mainClassName + "::main()");
        prefixInc();
        //open main function
         _printStream.println(_prefix + "{");
         prefixInc();
         _printStream.println(_prefix + "// list of all available nodes");
         _printStream.println(_prefix + "std::map< std::string, "+ _baseClassName +
                 "* > nodes = std::map< std::string," + _baseClassName + "* >();");
         _createAllClassesInstancesAndRefs(csdfg);
         _printStream.println("");
         _writeSchedule();
         _printStream.println("");
         _printStream.println(_prefix + "// Prepare shared data and memory");
         _defineFIFOChannels(csdfg);
         _printStream.println(_prefix + "// Preparation work for threads on CPU");
         _prepareThreads();
         _fillInThreadInfo(csdfg);
         _printStream.println("");
         _createAndRunThreads(csdfg);
         _printStream.println("");
         _joinThreads();
        /* _printStream.println("");
         _printStream.println(_prefix + "// Call dnn nodes according to the schedule ");
         _callNodesInScheduleOrder();*/
         _printStream.println("");
         _printStream.println(_prefix + "cout<<\"Generated program is finished!\"<<endl;");
         prefixDec();
         //close main function
         _printStream.println(_prefix + "}");
         prefixDec();
        _prefixDec();
        _printStream.println("");
    }

    /**
     * Print functions of getting buffer from vector of buffers
     */
    protected void _writeGetBufFuncs(){
        _writeGetBufFunc("src");
        _writeGetBufFunc("dst");
    }

     /**
     * Print functions of getting buffer from vector of buffers
     * @param bufPrefix
     */
    protected void _writeGetBufFunc(String bufPrefix){
     _printStream.println("");
     _printStream.println(_prefix+"// get fifo buffer by " + bufPrefix);
     _printStream.println(_prefix + "fifo_buf* "+ _funcClassName +"::get_buf_by_" + bufPrefix +
     " (std::string name, std::vector<fifo_buf>& fifos){");
     prefixInc();
     _printStream.println(_prefix + "for (auto & fifos_elem: fifos)  {");
     prefixInc();
     _printStream.println(_prefix + "if (name.compare(fifos_elem." + bufPrefix + ") == 0)");
     prefixInc();
     _printStream.println(_prefix + "return &fifos_elem;");
     prefixDec();
     _printStream.println(_prefix + "}");
     _printStream.println(_prefix + "return nullptr;");
     prefixDec();
     prefixDec();
     _printStream.println(_prefix + "}");

    }

    /**
     *  preparation work for threads on CPU
     */
    protected void _prepareThreads(){
     _printStream.println("");
     _printStream.println(_prefix + "// Allocate memory for pthread_create() arguments");
     _printStream.println(_prefix + "const int num_threads = schedule.size();");
     _printStream.println(_prefix + "struct thread_info *thread_info = (struct thread_info*)(calloc(num_threads, sizeof(struct thread_info)));");
     _printStream.println("");
     _printStream.println(_prefix + "// Main threads");
    }

    /**
     * Preapare and run fifo threads
     * @param csdfg CSDF graph
     */
     protected void _createAndRunThreads(CSDFGraph csdfg){
         Iterator i = csdfg.getNodeList().iterator();
         int threadId = 0;
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
                String nodeName = node.getName();
                _createAndRunThread(threadId, "thread_" + nodeName, nodeName, nodeName);
                threadId++;
        }

     }

      /**
     * Create and run thread
     * @param threadId thread id
     * @param threadName thread Name
     * @param nodeClassName node class name
     * @param nodeName node name
     */
    protected void _createAndRunThread(int threadId, String threadName, String nodeClassName, String nodeName){
         _printStream.println(_prefix + "// Create and run " + threadName);
         _printStream.println(_prefix + "std::thread " + threadName +
                 "(&" + nodeClassName + "::main, &" + nodeName +"_inst" + ", &thread_info[" + threadId + "]);");

         _printStream.println(_prefix + "cout<<\"Joined with thread " + threadName + "\"" + "<<endl;");
         _printStream.println(_prefix + "//" + threadName + ".join();");
         _printStream.println("");
    }


    /**
     * Preapare and run fifo threads
     * @param csdfg CSDF graph
     */
     protected void _fillInThreadInfo(CSDFGraph csdfg){
        Iterator i = csdfg.getNodeList().iterator();
        int threadId = 0;
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            _fillInThreadInfo(node,threadId);
            threadId++;
        }

     }

    /**
     * Fill in thread info for one CSDF node
     * @param node CSFD node
     */
    protected void _fillInThreadInfo(CSDFNode node, int threadId){
        _printStream.println("");
        _printStream.println(_prefix + "//" + node.getName() + " thread info");
        _printStream.println(_prefix + "thread_info[" + threadId +"].core_id = " + _assignFreeCore() + ";");

         for(CSDFPort inport: node.getNonOverlapHandlingInPorts()){
             _fillInThreadInfo(inport,false);
         }

         for(CSDFPort outport: node.getNonOverlapHandlingOutPorts()){
             _fillInThreadInfo(outport,true);
         }
    }

        /** fill thread info*/
    protected void _fillInThreadInfo(CSDFPort port, boolean isOutPort){
        int threadId = _schedule.indexOf(port.getNode().getName());
        int edgeId = port.getEdge().getId();

        String fifoBufSearchF = _funcClassName + "::get_buf_by_";
        if(isOutPort)
            fifoBufSearchF += "src";
        else fifoBufSearchF+= "dst";

        String fullPortName = port.getNode().getName() + "_" + port.getName();

        _printStream.println(_prefix + "fifo_buf* buf_ref_" + fullPortName + " = " + fifoBufSearchF + "( \"" + fullPortName + "\", fifos);");
        _printStream.println(_prefix + "thread_info[" + threadId + "].add_fifo_buf_ref( buf_ref_" + fullPortName + ");");
    }


    /**
     * Join all threads that should wait for each other
     * TODO NOT TRUE IN GENERAL! ADAPT FOR MULTIPLE THREADS PER ONE NODE AND MULTIPLE INSTANCES (NODES) OF ONE NODE CLASS
     */
    protected void _joinThreads(){
        if(_schedule==null)
            return;
        _printStream.println(_prefix + "// Join threads that should be awaited");
        for(String node: _schedule){
            _printStream.println(_prefix + "thread_" + node + ".join();");
        }

    }

    /**
     * define fifo channels sizs in ints from CSDF graph edges
     */
    protected void _defineFIFOChannels(CSDFGraph csdfg){
        _printStream.println(" ");
        _printStream.println(_prefix + "//Size of one token of FIFO in ints");
        _printStream.println(_prefix +  "int token_len=sizeof(long)/sizeof(int)+(sizeof(long)%sizeof(int)+(sizeof(int)-1))/sizeof(int);");
        _printStream.println(" ");
        _printStream.println(_prefix + "//fifo channels definition and initialization. Fifo sizes are given in tokens.");
        _printStream.println(_prefix +  "std::vector<fifo_buf> fifos = std::vector<fifo_buf>();");
        _printStream.println(" ");

         Iterator i = csdfg.getEdgeList().iterator();
        while (i.hasNext()) {
            CSDFEdge edge = (CSDFEdge) i.next();
            if(!(edge.getSrc().isOverlapHandler() ||edge.getDst().isOverlapHandler())) {
                _defineFIFOChannel(edge);
            }
        }
    }

    /**
     * Define bufferized FIFO channel
     * @param edge CSDF graph node
     */
    protected void _defineFIFOChannel(CSDFEdge edge){

        CSDFPort edgeSrc = edge.getSrc();
        CSDFPort edgeDst = edge.getDst();

        String srcFullName = edgeSrc.getNode().getName() + "_" +edgeSrc.getName();
        String dstFullName = edgeDst.getNode().getName() + "_" +edgeDst.getName();

        int fifoId = edge.getId();
        String fifoName  = "fifo_" + edge.getId();
        String fifoSize = "fifo_size_"+ fifoId;


        //datatype should be the same for src/dst ports. If it is not defined, it is set to int by default.
        String dataType = getDataType(edgeSrc);

        _printStream.println(_prefix + "// FIFO " + srcFullName  + "-->" + dstFullName );


        _printStream.println(_prefix + "void *" + fifoName +"=NULL;");
        _printStream.println(_prefix + "int "+ fifoSize +
                " = max(" +
                edgeSrc.getNode().getName() + "_inst." + edgeSrc.getName() + "_fifo_size ," +
                edgeDst.getNode().getName() + "_inst." + edgeDst.getName() + "_fifo_size);");

      _printStream.println(_prefix + fifoName +" = calloc("+ fifoSize + " +2, sizeof(" + dataType + "));");


      _printStream.println(_prefix + "struct fifo_buf buf_" + fifoId + " = fifo_buf ("+ fifoName +","
              + fifoSize + ", \"" + srcFullName + "\" , \"" + dstFullName + "\");");

      _printStream.println(_prefix + "fifos.push_back(buf_" + fifoId + ");");

      _printStream.println(" ");
    }

      /**
     * TODO refactoring on idea
     * Create instances of all node and references on them
     * @param csdfG csdf graph
     */
    protected void _createAllClassesInstancesAndRefs(CSDFGraph csdfG){
        Iterator i = csdfG.getNodeList().iterator();
        String nodename;
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            nodename = node.getName();
            _printStream.println(_prefix + nodename + " " + nodename + "_inst = " + nodename + "();");
            _printStream.println(_prefix + "nodes[\"" + nodename + "\"] = &" + nodename + "_inst;");
        }

    }

    /**
     //define schedule - LB: layers in traverse order
	   //NB : neurons of one layer can run in parallel?

     */
    protected void _writeSchedule(){
        _printStream.println(_prefix + "/**");
        prefixInc();
        _printStream.println(_prefix + "Define schedule ");
        _printStream.println(_prefix + "Dummy schedule for LB-mode: layers in traverse order");
        _printStream.println(_prefix + "Dummy schedule for NB-mode: neurons of one layer can run in parallel");
        prefixDec();
        _printStream.println(_prefix + "*/");
        _printStream.println(_prefix + "vector<std::string> schedule = vector<std::string>();");
        _printStream.println("");
        //
        if(_isScheduleNullOrEmpty())
            _processNullSchedule();

        else {
            for (String nodeCall : _schedule)
                _printStream.println(_prefix + "schedule.push_back(\"" + nodeCall + "\");");
        }

    }

    /**
     * Checks if schedule is null or empty
     * @return true, if schedule is null or empty and false otherwise
     */
    private boolean _isScheduleNullOrEmpty(){
        if(_schedule==null)
            return true;
        if(_schedule.size()==0)
            return true;
        return false;
    }

    /**
     * Process null schedule in generated .cpp - code
     */
    private void _processNullSchedule(){
        _printStream.println(_prefix + "//WARNING: Please, write CSDF graph schedule here using schedule.push_back(\"node_name\");");
        _printStream.println(_prefix + "cout<<\"WARNING: CSDF graph schedule is undefined.\"<<endl<<\"Please, write schedule manually in appMain.main()\";");
    }

    /**
     * Call dnn nodes according to schedule
     */
    protected void _callNodesInScheduleOrder(){
        _printStream.println(_prefix + "for(int i=0; i<schedule.size();i++){");
        prefixInc();
        _printStream.println(_prefix + "nodes[schedule.at(i)]->main();");
        prefixDec();
        _printStream.println(_prefix + "}");
    }


      /**
     * Write line copy function
     * TODO replace by data loader in real implementation
     * @param dataType type of line copy function
     */
    protected void _writeCPULine(String dataType){
         _printStream.println(_prefix + "/**");
         prefixInc();
          _printStream.println(_prefix + "* copies 2D-data line from src to dst.");
          _printStream.println(_prefix + "* data_h - src data height");
          _printStream.println(_prefix + "* data_w - src data width");
          _printStream.println(_prefix + "* src - pointer to first data source array element");
          _printStream.println(_prefix + "* dst - pointer to first copy destination array element");
         prefixDec();
         _printStream.println(_prefix + "*/");

         _printStream.println(_prefix + " void " + _funcClassName + "::cpy_2D_data_line(const int &data_w, "+
                 dataType + " *src,"+ dataType + " *dst,"+" const int &line_id)");
         prefixInc();
         _printStream.println(_prefix + "{");
         prefixInc();
         _printStream.println(_prefix + "int line_start = line_id * data_w;");
         _printStream.println(_prefix + "for (int i = 0; i < data_w ; i++)");
         prefixInc();
         _printStream.println(_prefix + "dst[i] = src[line_start];");
         prefixDec();
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
    }


    /**
     * Write shift function (for shifting overlapping data in I/O arrays)"
     * TODO refactor shift function : make one for general arrays - tensors
     */
    protected void _writeShiftFunctions(){
        _writeShift2D("int");
        _writeShift3D("int");
        _writeShift2D("float");
        _writeShift3D("float");
    }

    /**
     * Write 2D shift
     */
    protected void _writeShift2D(String dataType){
        _printStream.println(_prefix + "/**");
         prefixInc();
          _printStream.println(_prefix + "* Moves 2D data on n lines to top.");
          _printStream.println(_prefix + "* Required for overlapping data.");
          _printStream.println(_prefix + "* h - array height");
          _printStream.println(_prefix + "* w - array width");
          _printStream.println(_prefix + "* x - pointer to first array element");
       //   _printStream.println(_prefix + "* TODO: remove cout after testing");
         prefixDec();
         _printStream.println(_prefix + "*/");

         _printStream.println(_prefix + " void " + _funcClassName + "::shift_2D (const int &h, const int &w, "+ dataType + " *x, const int &stride)");
         prefixInc();
         _printStream.println(_prefix + "{");
         prefixInc();
      //   _printStream.println(_prefix + "cout<<\"2D data shift\"<<endl;");
         _printStream.println(_prefix + "for(int line_ind = stride; line_ind < w ; line_ind ++){");
         prefixInc();
         _printStream.println(_prefix + "for(int i=0; i<w; i++)");
         prefixInc();
         _printStream.println(_prefix + "x[i + (line_ind - stride)* w] = x[i + line_ind * w];");
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
    }

    /**
     * Write 3D shift
     */
    protected void _writeShift3D(String dataType){
         _printStream.println(_prefix + "/**");
         prefixInc();
          _printStream.println(_prefix + "* Moves 3D data on n lines to top.");
          _printStream.println(_prefix + "* Required for overlapping data.");
          _printStream.println(_prefix + "* d - array depth");
          _printStream.println(_prefix + "* h - array height");
          _printStream.println(_prefix + "* w - array width");
          _printStream.println(_prefix + "* x - pointer to first array element");
      //    _printStream.println(_prefix + "* TODO: remove cout after testing");
         prefixDec();
         _printStream.println(_prefix + "*/");

         _printStream.println(_prefix + " void " + _funcClassName + "::shift_3D (const int &d, const int &h, const int &w, "+ dataType + " *x, const int &stride)");
         prefixInc();
         _printStream.println(_prefix + "{");
         prefixInc();
       //  _printStream.println(_prefix + "cout<<\"3D data shift\"<<endl;");

         _printStream.println(_prefix + "int start_elem_id = 0;");
         _printStream.println(_prefix + "for(int depth=0; depth < d; depth++ ){");
         prefixInc();
         _printStream.println(_prefix + "for(int line_ind = stride; line_ind < w ; line_ind ++){");
         prefixInc();
         _printStream.println(_prefix + "for(int i=0; i<w; i++)");
         prefixInc();
         _printStream.println(_prefix + "x[i + (line_ind - stride)* w + start_elem_id] = x[i + line_ind * w + start_elem_id];");
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
         _printStream.println(_prefix + "start_elem_id +=w*h;");
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
         _printStream.println(_prefix + "}");
         prefixDec();
    }

    /**
     * TODO: refactoring for tensor
     */
  /**
     * Write matrix print functions
     * TODO refactoring: print(matrix)
     */
    protected void _writePrintFunctions(){
        _writeprint2D("int");
        _writeprint3D("int");
        _writeprint2D("float");
        _writeprint3D("float");
    }

    protected void _writeprint2D(String dataType){
        _printStream.println(_prefix + "//2D array print function, type: " + dataType);
        _printStream.println(_prefix + " void " + _funcClassName + "::print_2D(const int &h, const int &w, "+ dataType + " *x)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "for (int i = 0; i < h; i++){");
        prefixInc();
        _printStream.println(_prefix + "for (int j = 0; j < w ; j++)");
        prefixInc();
        _printStream.println(_prefix + "std::cout << x[i * w + j] << ' ';");
        prefixDec();
        _printStream.println(_prefix + "std::cout<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }

    protected void _writeprint3D(String dataType){
        _printStream.println(_prefix + "//3D array print function, type: " + dataType);
        _printStream.println(_prefix + " void " + _funcClassName + "::print_3D(const int &d, const int &h, const int &w, "+ dataType + " *x)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "int start_elem_id = 0;");
        _printStream.println(_prefix + "for(int depth=0; depth < d; depth++ ){");
        prefixInc();
        _printStream.println(_prefix + "std::cout<<\"depth\"<<depth<<endl;");
        _printStream.println(_prefix + "for (int i = 0; i < h; i++){");
        prefixInc();
        _printStream.println(_prefix + "for (int j = 0; j < w ; j++)");
        prefixInc();
        _printStream.println(_prefix + "std::cout << x[i * w + j + start_elem_id] << ' ';");
        prefixDec();
        _printStream.println(_prefix + "std::cout<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        _printStream.println(_prefix + "start_elem_id +=w*h;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }

    /**
     * Write execution function primitive simplest MoC
     * (only function name is a parameter)
     */
    protected void _writeExecPrimitive(){
        _printStream.println(_prefix + " void " + _funcClassName +
                    "::execute (std::string function)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "// cout<<function<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }


    /**
     * Write execution function primitive MoC
     * (with a number of parameters, that can be used by DNN operators)
     * TODO extend or replace by DNN library
     */
    protected void _writeExecPrimitive(String tensorParamType){
        _printStream.println(_prefix + " void " + _funcClassName +
                    "::execute (std::string function," +
                tensorParamType +"* input, " + tensorParamType + "* weights, "
                + tensorParamType + "* output, std::map<std::string,int>* int_params_ptr )");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "if (function.find(\"CONV\") != std::string::npos)");
        prefixInc();
        _printStream.println(_prefix + "dnnFunc::execute_conv(input, weights, output,int_params_ptr);");
        prefixDec();
        _printStream.println(_prefix + "if (function.find(\"DENSEBLOCK\") != std::string::npos)");
        prefixInc();
        _printStream.println(_prefix + "dnnFunc::execute_dense_block(function,input, weights, output,int_params_ptr);");
        prefixDec();
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }


    /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    @Override
    protected void  _writeCppConstructorAndDestructor(String className, String baseClassName){
        _printStream.println(_prefix + className + "::" + className + "() : " + _baseClassName + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }

      /**
     * Write constructor and destructor .cpp definitions
     * @param node CSDF node
     */
    protected void  _writeCppConstructorAndDestructor(CSDFNode node){
        String className = node.getName();
        _printStream.println(_prefix + className + "::" + className + "() : " + _baseClassName + "() {");
        prefixInc();
        _writeFIFOsizes(node);
        /**TODO refactoring */
        _fillInIntParams(node);

        MemoryUnit weights = node.getMemoryUnit("weights");
        if(weights!=null)
        _initWeightsDummy(weights.getDimensionality());
        //TODO REMOVE AFTER TESTING
        if(node.getName().equals("input")) {
            _writeDummy2DDataInOutput();
        }
        prefixDec();
        _printStream.println(_prefix + "}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }

    /**
     * TODO refactoring
     * Fill in CSDFNode integer parameters
     * @param node CSDFNode
     */
    protected void _fillInIntParams(CSDFNode node){
        /** define constant parameters, if any*/
        Vector<MemoryUnit> constParams = node.getUnitParams();
        if(constParams.size()>0) {
            _printStream.println("//const int parameters");
            _printStream.println(_prefix + "int_params[\"neurons\"] = neurons;");

            for (MemoryUnit mu : constParams) {
                if(mu.getTypeDesc().equals("int"))
                    _printStream.println(_prefix + "int_params[\"" + mu.getName() + "\"] = " + mu.getName() + ";");
            }
        }

        for(CSDFPort inport: node.getNonOverlapHandlingInPorts()){
                MemoryUnit mu = inport.getAssignedMemory();
                if (mu!=null) {
                    _printStream.println(_prefix + "int_params[\"" + mu.getName() +
                                "_dims\"] = " + mu.getName()+"_dims;");
                    for(int i=0;i<mu.getDimensionality();i++){
                        _printStream.println(_prefix + "int_params[\"" + mu.getName() +
                                "_dim_" + i + "\"] = " + mu.getName() + "_dim_" + i + ";");
                    }
                }
        }

        /** define only distinct out ports*/
        Vector<String> defined = new Vector<>();
        for(CSDFPort outport: node.getNonOverlapHandlingOutPorts()){
                MemoryUnit mu = outport.getAssignedMemory();
                if (mu!=null) {
                    if(!defined.contains(mu.getName())) {
                        _printStream.println(_prefix + "int_params[\"" + mu.getName() +
                                "_dims\"] = " + mu.getName()+"_dims;");
                        for(int i=0;i<mu.getDimensionality();i++) {
                            _printStream.println(_prefix + "int_params[\"" + mu.getName() +
                                    "_dim_" + i + "\"] = " + mu.getName() + "_dim_" + i + ";");
                            defined.add(mu.getName());
                        }
                    }
                }
        }
        defined.clear();
     }

        //TODO REMOVE AFTER TESTING
    private void _writeDummy2DDataInOutput(){
        _printStream.println("// fill data container with dummy data ");
        String dataname = "data";
        _printStream.println(_prefix + "for (int j=0;j< "+dataname+"_dim_0;j++) { ");
        prefixInc();
        _printStream.println(_prefix + "for (int i=0;i< "+dataname+"_dim_1;i++) { ");
        prefixInc();
        _printStream.println(_prefix + dataname + "[j][i]=j;");
        prefixDec();
        _printStream.println(_prefix + "} ");
        prefixDec();
        _printStream.println(_prefix + "} ");
    }

    //TODO REMOVE AFTER TESTING
    private void _initWeightsDummy(int weightsDim){

        _printStream.println("");
        _printStream.println("// fill weights with dummy values ");
        String weightsDesc = "weights";

        for(int i=0; i<weightsDim; i++)
            weightsDesc+="[w"+i+"]";

        for(int i=0; i<weightsDim; i++) {
            _printStream.println(_prefix + "for (int w" + i + "=0;w" + i +"< weights_dim_"+ i +";w" + i +"++) { ");
            prefixInc();
        }

         _printStream.println(_prefix + weightsDesc + " = 1; ");

         for(int i=0; i<weightsDim; i++) {
            _printStream.println(_prefix + "}");
            prefixDec();
        }
    }

     /**
     * Write FIFO sizes for CSDF node
     * @param node CSDF node
      * TODO check why min FIFO sizes (without repetitions) are not always applicable
     */
    protected void _writeFIFOsizes(CSDFNode node){
        _printStream.println(_prefix + "//assign FIFO sizes");
        for(CSDFPort inport: node.getNonOverlapHandlingInPorts())
            _writeFIFOsize(inport,node.getRepetitions());
        for(CSDFPort outport: node.getNonOverlapHandlingOutPorts())
            _writeFIFOsize(outport,node.getRepetitions());
        _printStream.println("");
    }


        /**
     * Write FIFO sizes for CSDF node
     * @param port CSDF port
     */
     protected void _writeFIFOsize(CSDFPort port, int repetitions){
      MemoryUnit mu = port.getAssignedMemory();
      if(mu==null) {
          _printStream.println(_prefix + port.getName() + "_fifo_size = 0;");
          return;
      }
      if(mu.getDimensionality()<1) {
          _printStream.println(_prefix + port.getName() + "_fifo_size = 0;");
          return;
      }
      _printStream.println(_prefix + port.getName() + "_fifo_size = "
              + mu.getShape().getElementsNumber() * repetitions + ";");
    }

     /**
     * Write FIFO sizes for CSDF node
     * @param port CSDF port
     */
     protected void _writeFIFOsize(CSDFPort port){
      MemoryUnit mu = port.getAssignedMemory();
      if(mu==null) {
          _printStream.println(_prefix + port.getName() + "_fifo_size = 0;");
          return;
      }
      if(mu.getDimensionality()<1) {
          _printStream.println(_prefix + port.getName() + "_fifo_size = 0;");
          return;
      }
      _printStream.println(_prefix + port.getName() + "_fifo_size = "
              + mu.getShape().getElementsNumber() + ";");
    }



     /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    protected void  _writeNoBaseCppConstructorAndDestructor(String className){
        _printStream.println(className + "::" + className + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }

    /**
     * process exec function with default name
     * @param node CSDF node
     */
    @Override
    protected void _processExecution(CSDFNode node){
        /**TODO REPLACE BY DATA LOADER AFTER TEST*/
        if(node.getName().equals("input"))
            _processInputNodeExecution();

        _processExecution(node,_funcClassName + "::execute");
    }

    /**TODO REPLACE BY DATA LOADER AFTER TEST*/
   protected void _processInputNodeExecution(){
       _printStream.println(_prefix + "//execution: produce next data line");
       _printStream.println(_prefix + _funcClassName + "::cpy_2D_data_line(data_dim_1,&data[0][0],&output[0][0],rep);");
   }

    /**
    * process node output ports
    * @param node SDF Node
    * */
    @Override
    protected void _processWriting(CSDFNode node){
       _printStream.println("");
       _printStream.println(_prefix + "//writing");
        for (CSDFPort outport: node.getOutPorts()){
            if(!outport.isOverlapHandler())
                _definePhasesLimitation(outport, false);
            printWriteTemplate(outport);
        }
    }

      /**
     * process node input ports
     * @param node SDF Node
     */
    @Override
    protected void _processReading(CSDFNode node){
       _printStream.println("");
       _printStream.println(_prefix + "//reading");
        for (CSDFPort inport: node.getOverlapHandlingInPorts()){
          //  _definePhasesLimitation(inport, false);
            printReadTemplate(inport);
        }

        for (CSDFPort inport: node.getNonOverlapHandlingInPorts()){
            _definePhasesLimitation(inport, false);
            printReadTemplate(inport);
        }
    }

     /**
     * print reading template
     * @param port SDF input port
     */
     @Override
      public void printReadTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
         if(port.isOverlapHandler()){
              _printInternalArrayShift(port,arrayName);
              return;
         }

         if(port.getStartTokens()==null)
             printOperationTemplate(port, "read" + _externalRWPostfix, arrayName);
         else
             printOperationShiftedTemplate(port,"read" + _externalRWPostfix,arrayName,
                     port.getName() + "_shift");
    }

    /**
     * Print write template
     * @param port CSDF port performs writing
     */
    public void printWriteTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
        if(!port.isOverlapHandler())
            printOperationTemplate(port, "write" + _externalRWPostfix, arrayName);
    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     * R/W primitive parameters:
     * 1. fifo: reference on destination array (name of CSDF node input port array) or FIFO
     * 2. memobj_cpu : reference on source array (default value, stored in header)
     * 3. len - number of tokens to be transferred
     * 4. fifo_size - total fifo size (const value, stored in header)
      *
      * write fifo --> local mem
      * read: local mem --> fifo
      * */
     @Override
    public void printOperationTemplate(CSDFPort port,String operation, String arrayName){
       if(port==null || arrayName==null)
           return;

       String portName = port.getName();
       String fifoRef = port.getNode().getName() + "_" + portName + "_buf_ptr";
        _printStream.println(" ");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
                /** check, if there are any tokens to r/w*/
        _printStream.println(_prefix + "if ( " + portName + "_tokens > 0 )" );
        prefixInc();
        _printStream.println(_prefix + operation + "(" + fifoRef +"->fifo, " +
              getArrayAddress(arrayName,port.getMemoryDim()) + ", "+
                portName + "_tokens, " + fifoRef +"->fifo_size);");
        _prefixDec();
    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     */
     @Override
    public void printOperationShiftedTemplate(CSDFPort port,String operation, String arrayName, String shiftDesc){
       if(port==null || arrayName==null)
           return;

       String portName = port.getName();
       String fifoRef = port.getNode().getName() + "_" + portName + "_buf_ptr";
       String portDataType = getDataType(port);
       port.getMemoryDim();

        _printStream.println(" ");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
        /** check, if there are any tokens to r/w*/
        _printStream.println(_prefix + "if ( " + portName + "_tokens > 0 )" );
        prefixInc();
        _printStream.println(_prefix + operation + "(" + fifoRef +"->fifo, "+
                getArrayAddress(arrayName,port.getMemoryDim()) + " + " + portName + "_shift*sizeof("+
                portDataType + "), " + portName + "_tokens, " + fifoRef +"->fifo_size);");
        prefixDec();
    }

    /**
     * Get address of the first element of the array
     * @param arrayName array name
     * @param arrayDim array dimensionality
     * @return  address of the first element of the array
     */
    private String getArrayAddress(String arrayName,int arrayDim){
         String arrayAdress = "&" + arrayName;
        for(int i=0; i<arrayDim;i++)
            arrayAdress+="[0]";

        return arrayAdress;
    }

      /**
     * Get data type of CSDF port. If there is a memory unit, assigned to
     * a memory port, the memory unit data type is used. Otherwise,
     * int (integer) data type is used
     * @param port CSDF port
     * @return data type of CSDF port
     */
    private String getDataType(CSDFPort port){
        String dataType;
        MemoryUnit mu = port.getAssignedMemory();
        if(mu==null)
            dataType = "int";
        else
            dataType = mu.getTypeDesc();
        return dataType;
    }

    /**
     * print internal data shift for overlapping port memory,
     * taking into account only end border limitations
     *
     * C++ shift functions:
     * static void shift_2D(int h, int w, int *x, int stride);
     * appMain::shift_2D(h,w,&arr_to_shift_3D[0][0],stride);
     * static void shift_3D(int d, int h, int w, int *x, int stride);
     * appMain::shift_3D(d,h,w,&arr_to_shift_3D[0][0][0],stride);
     *
     */

    public void _printInternalArrayShift(CSDFPort port,String arrayName){
       if(port==null || arrayName==null)
           return;
        int dataDimensionality = port.getMemoryDim();
        if(dataDimensionality<2 || dataDimensionality>3)
            return;

        _printStream.println(" ");
        _printStream.println(_prefix + "// internal shift of " + arrayName);
        //shift 2D
        if(dataDimensionality==2)
                   _printStream.print(_prefix + _funcClassName + "::shift_2D(" + arrayName + "_dim_0," +
                arrayName + "_dim_1," + "&" + arrayName +"[0][0], stride);");
        //shift 3D
        else
            _printStream.print(_prefix + _funcClassName + "::shift_3D("+ arrayName + "_dim_0," +
                arrayName + "_dim_1," + arrayName + "_dim_2," + "&" + arrayName +"[0][0][0], stride);");

        _printStream.println("");
    }

    /**
     * Set csdfg schedule
     * CSDFG nodes schedule : get from the repetition vector of CSDFG??
     * @param schedule CSDFG nodes schedule : get from the repetition vector of CSDFG??
     */
    public void setSchedule(Vector<String> schedule){
        _schedule = schedule;
    }

    /**
     * get next free core id
     * TODO should be replaced by the mapping specification
     * @return next free core id
     */
    private int _assignFreeCore(){
        if(_curCore>=_maxCores)
            _curCore=0;
        else
            _curCore++;
        return _curCore;
    }

    ///////////////////////////////////////////////////////////////////
    ///                private variables                           ///

    /** primitive postfix*/
    private static String _externalRWPostfix = "SWF_CPU";

    /** application main class name*/
    private static String _mainClassName = "appMain";

    /** CSDF graph node base class*/
    private static String _baseClassName = "csdfNode";

    /** CSDF graph node functions class*/
    private static String _funcClassName = "appFunc";

    /** CSDFG nodes schedule : get from the repetition vector of CSDFG??*/
    Vector<String> _schedule;

    /**TODO should be replaced by mapping specification
     * Number of cores
     */
    private static int _maxCores = 6;

    /**
     * TODO should be replaced by mapping specification
     * Current core Id
     */
    private static int _curCore = 0;
}