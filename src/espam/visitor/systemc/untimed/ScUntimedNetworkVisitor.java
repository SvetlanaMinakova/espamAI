/*******************************************************************\

The ESPAM Software Tool 
Copyright (c) 2004-2010 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the 
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by 
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

package espam.visitor.systemc.untimed;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Iterator;

import espam.datamodel.graph.adg.ADGParameter;
import espam.datamodel.graph.adg.ADGEdge;

import espam.datamodel.pn.cdpn.CDChannel;
import espam.datamodel.pn.cdpn.CDProcessNetwork;
import espam.datamodel.pn.cdpn.CDProcess;
import espam.datamodel.pn.cdpn.CDGate;

import espam.main.UserInterface;
import espam.visitor.CDPNVisitor;

//////////////////////////////////////////////////////////////////////////
////ScUntimedNetworkVisitor

/**
 * This class generates a SystemC model from a CDPN. It is based on the YAPI
 * visitor.
 *
 * @author  Hristo Nikolov, Todor Stefanov, Adarsha Rao, Sven van Haastregt
 * @version  $Id: ScUntimedNetworkVisitor.java,v 1.1 2010/11/05 16:23:58 svhaastr Exp $
 */

public class ScUntimedNetworkVisitor extends CDPNVisitor {

    /**
     *  Constructor for the SystemCNetworkVisitor object
     *
     * @param  printStream Description of the Parameter
     */
    public ScUntimedNetworkVisitor(PrintStream printStream) {
        _printStream = printStream;
        _printStream.println("// File automatically generated by ESPAM");

        // Use the directory indicated by the '-o' option. Otherwise
        // select the orignal filename. (REFACTOR)
        UserInterface ui = UserInterface.getInstance();
        if( ui.getOutputFileName() == "" ) {
            _outputDir = ui.getBasePath() + "/" + ui.getFileName();
        }
        else {
            _outputDir = ui.getBasePath() + "/" + ui.getOutputFileName();
        }
    }


    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///

    /**
     * @param  x Description of the Parameter
     */
    public void visitComponent( CDProcessNetwork x ) {
        _pn = x;

        _printStream.println("#ifndef " + x.getName() + "_KPN_H");
        _printStream.println("#define " + x.getName() + "_KPN_H");
        _printStream.println("");
        _printStream.println("");

        CDProcess process;

        Iterator i = x.getProcessList().iterator();
        while( i.hasNext() ) {
            process = (CDProcess) i.next();
            _printStream.println("#include \"" + process.getName() + ".h\"");
        }

        _printStream.println("");
        _printStream.println
                ("class " + x.getName() + " : public sc_module{");
        _prefixInc();
        _printStream.println(_prefix + "private:");
        _prefixInc();
        _printStream.println(_prefix + "// Channels");

        CDChannel channel;

        i = x.getChannelList().iterator();
        while( i.hasNext() ) {
            channel = (CDChannel) i.next();
            channel.accept(this);
        }

        _printStream.println("");
        _printStream.println(_prefix + "// processes");

        i = x.getProcessList().iterator();
        while( i.hasNext() ) {
            process = (CDProcess) i.next();
            process.accept(this);
        }

        _printStream.println("");
        _prefixDec();
        _printConstructor();

        //  the type() function
        _printStream.println("");
        _prefixDec();
//        _printStream.println(_prefix + "const char* type() const { " +
//                      "return \"" + x.getName() + "\"; };");

        _printStream.println("");
        _printStream.println("};");

        _printStream.println("");
        _printStream.println("#endif /* " + x.getName() + "_H */");

        ScUntimedProcessVisitor pt = new ScUntimedProcessVisitor();
        x.accept( pt );

        _writeMakeFile();
        _writeConfigFile();
        _writeMainFile();
    }

    /**
     * @param  x Description of the Parameter
     */
    public void visitComponent( CDChannel x ) {

       _printStream.println(_prefix + "Fifo<t"+x.getName()+"> " + x.getName() + ";");
    }

    /**
     * @param  x Description of the Parameter
     */
    public void visitComponent( CDProcess x ) {

       _printStream.println(_prefix + x.getName() + " " + x.getName() + "_instance;");
    }


    ///////////////////////////////////////////////////////////////////
    ////                         private methods                   ////

    /**
     *  Description of the Method
     */
    private void _printConstructor() {

        _printStream.println(" public: ");
        _printStream.println(_prefix + _pn.getName() + "(");

        String csl = "sc_module_name n, ";

        Iterator I = _pn.getAdg().getParameterList().iterator();
        while( I.hasNext() ) {
            csl += "int parm_" + ((ADGParameter) I.next()).getName() + ", ";
        }

        csl = csl.substring(0, csl.length() - 2);
        _printStream.print(_prefix + _prefix + csl);

        _printStream.println("");
        _printStream.println(_prefix + ") :");

        _prefixInc();
        csl = _prefix + "sc_module(n)";

        I = _pn.getChannelList().iterator();
        while( I.hasNext() ) {
            CDChannel ch = (CDChannel) I.next();
            String channelName = ch.getName();
            int chSize = ( (ADGEdge) ch.getAdgEdgeList().get(0) ).getSize();

            if (chSize < 1) {
                 csl += ",\n" + _prefix + channelName + "(\"" + channelName + "\")";
            } else {
                 csl += ",\n" + _prefix + channelName + "(\"" + channelName + "\")";
            }

         }
        _printStream.print(csl);

        I = _pn.getProcessList().iterator();
        while( I.hasNext() ) {
            CDProcess process = (CDProcess) I.next();

            _printStream.print(",\n" + _prefix + process.getName() + "_instance" +
                               "(\"" + process.getName() + "\"");
            _printConnections( process );
        }

        _printStream.println("");
        _printStream.println(_prefix + "{");
        _printStream.println(_prefix + "};");
    }

    /**
     *  Description of the Method
     *
     * @param  x Description of the Parameter
     */
    private void _printConnections( CDProcess x ) {
        String ed;
        String csl = "";
        Iterator i;
        CDGate gate;

        i = x.getGateList().iterator();
        while( i.hasNext() ) {
            gate = (CDGate) i.next();
            csl += ", " + gate.getChannel().getName();
        }

        i = _pn.getAdg().getParameterList().iterator();
        while( i.hasNext() ) {
            csl += ", parm_" + ((ADGParameter) i.next()).getName();
        }
        _printStream.print(csl + ")");
    }


    /**
     */
    private void _writeConfigFile() {
        try {
            String configFilename = _outputDir + "/config.mk";
            File f = new File(configFilename);
            if (f.exists() == false) {
                // Only write the file if it did not exist (so existing config is kept).
                PrintStream cf = _openFile(configFilename);

                cf.println("# Makefile config for SystemC Process Networks");
                cf.println("");
                cf.println("CC = gcc");
                cf.println("CXX = g++");
                cf.println("SYS_LIBS =");
                cf.println("SYSTEMC = $(HOME)/systemc-2.2.0");
            }
            else {
                System.out.println(" -- Preserving config.mk");
            }

        }
        catch( Exception e ) {
            System.out.println("Error: " + e.getMessage());
            System.out.println("Cannt create the default config file");
            System.out.println("please supply your own config file");
        }
    }



    /**
     */
    private void _writeMainFile() {
        try {
            PrintStream maf = _openFile(_outputDir + "/main.cc");

            maf.println("//main.cc file for SystemC Process Networks");
            maf.println("//@Author: ESPAM");
            maf.println(" ");
            maf.println("#include \"" + _pn.getName() + "_KPN.h\"");
            maf.println("#include <fstream>");
            maf.println("using namespace std;");
            maf.println(" ");
            maf.println("int sc_main(int argc , char *argv[])");
            maf.println("{");
            maf.println(" ");
            maf.print("   static " + _pn.getName() + " " + _pn.getName() + "( \"" + _pn.getName() + "\"");

            ADGParameter parameter;
            Iterator i = _pn.getAdg().getParameterList().iterator();

            while( i.hasNext() ) {
                parameter = (ADGParameter) i.next();
                maf.print(", " + parameter.getValue());
            }
            maf.println(");");
            maf.println(" ");
            maf.println(" sc_start();");
            maf.println(" return 0;");
            maf.println(" ");
            maf.println("}");

        }
        catch( Exception e ) {
            System.out.println("Error: " + e.getMessage());
            System.out.println("Cannt create the default main.cc file");
            System.out.println("please supply your own main.cc file");
        }
    }

    /**
     */
    private void _writeMakeFile() {
        try {
            // create the makefile
            PrintStream mf = _openFile(_outputDir + "/Makefile");

            mf.println("include config.mk\n");
            mf.println("SRC_DIR=.");
            mf.println("INC_DIR=.");
            mf.println("OBJ_DIR=.");
            mf.println("BIN_DIR=.\n");
            mf.println("EXEC= $(BIN_DIR)/sim\n");
            mf.println("COMP_FLAGS= -Wall -c -g -I$(INC_DIR) -I$(SYSTEMC)/include");
            mf.println("BUILD_FLAGS= -g -L$(SYSTEMC)/lib-linux");
            mf.println("DEFINES= -DPLATFORM_X86\n");
            mf.println("HEADER= $(wildcard $(INC_DIR)/*.h)");
            mf.println("SRC=    $(wildcard $(SRC_DIR)/*.cc)"); 
            mf.println("OBJ=    $(SRC:$(SRC_DIR)/%.cc=$(OBJ_DIR)/%.o) ");
            mf.println("LIBS=-lsystemc\n");
            mf.println("default: $(EXEC)\n");
            mf.println("$(EXEC): $(OBJ) Makefile");
            mf.println("\t$(CXX) $(BUILD_FLAGS) -o $@  $(OBJ) $(LIBS)");
            mf.println("");
            mf.println("$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cc Makefile *.h");
            mf.println("\t$(CXX) -o $@ $(COMP_FLAGS) $(DEFINES) $<\n");
            mf.println("run:");
            mf.println("\t${EXEC}\n");
            mf.println("clean:");
            mf.println("\trm -f $(OBJ_DIR)/*.o $(EXEC) ");

        }
        catch( Exception e ) {
            System.out.println("Error: " + e.getMessage());
            System.out.println("Cannot create the default makefile");
            System.out.println("please supply your own makefile");
        }
    }



    /**
     * Open a file for writing.
     *
     * @return  Description of the Return Value
     * @exception  FileNotFoundException Description of the Exception
     */
    private static PrintStream _openFile(String fullFileName)
             throws FileNotFoundException {

        PrintStream printStream = null;
        OutputStream file = null;
        System.out.println(" -- OPEN FILE: " + fullFileName);
        file = new FileOutputStream( fullFileName );
        printStream = new PrintStream( file );
        return printStream;
    }



    ///////////////////////////////////////////////////////////////////
    ////                         private variables                 ////

    /**
     */
    private CDProcessNetwork _pn = null;

    private String _outputDir = null;
}

