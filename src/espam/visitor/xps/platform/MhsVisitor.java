/*******************************************************************\

The ESPAM Software Tool
Copyright (c) 2004-2008 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

package espam.visitor.xps.platform;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;
import java.math.*;

import espam.datamodel.EspamException;
import espam.datamodel.mapping.Mapping;
import espam.datamodel.platform.Platform;
import espam.datamodel.platform.Resource;
import espam.datamodel.platform.Port;
import espam.datamodel.platform.Link;
import espam.datamodel.platform.processors.Processor;
import espam.datamodel.platform.processors.PowerPC;
import espam.datamodel.platform.processors.MicroBlaze;
import espam.datamodel.platform.processors.MemoryMap;
import espam.datamodel.platform.processors.Page;
import espam.datamodel.platform.memories.MultiFifo;
import espam.datamodel.platform.memories.Memory;
import espam.datamodel.platform.memories.Fifo;
import espam.datamodel.platform.memories.BRAM;
import espam.datamodel.platform.memories.ZBT;
import espam.datamodel.platform.communication.Crossbar;
import espam.datamodel.platform.peripherals.ZBTMemoryController;
import espam.datamodel.platform.peripherals.Uart;
import espam.datamodel.platform.ports.CompaanInPort;
import espam.datamodel.platform.ports.CompaanOutPort;
import espam.datamodel.platform.ports.FifoReadPort;
import espam.datamodel.platform.ports.FifoWritePort;
import espam.datamodel.platform.ports.PLBPort;
import espam.datamodel.platform.ports.LMBPort;
import espam.datamodel.platform.ports.DLMBPort;
import espam.datamodel.platform.ports.ILMBPort;
import espam.datamodel.platform.ports.OPBPort;
import espam.datamodel.platform.hwnodecompaan.CompaanHWNode;
import espam.datamodel.platform.controllers.MemoryController;
import espam.datamodel.platform.controllers.FifosController;
import espam.datamodel.platform.controllers.MultiFifoController;
import espam.datamodel.platform.controllers.ReadCrossbarController;
import espam.datamodel.platform.host_interfaces.ADMXRCII;
import espam.datamodel.platform.host_interfaces.ADMXPL;
import espam.datamodel.platform.host_interfaces.XUPV5LX110T;
import espam.datamodel.platform.host_interfaces.ML505;
import espam.datamodel.platform.host_interfaces.ML605;
import espam.datamodel.platform.communication.AXICrossbar;
import espam.datamodel.platform.ports.AXIPort;
import espam.datamodel.platform.memories.CM_AXI;
import espam.datamodel.platform.controllers.CM_CTRL;
import espam.datamodel.platform.controllers.AXI_CM_CTRL;
import espam.datamodel.platform.controllers.AXI2AXI_CTRL;
import espam.main.UserInterface;

import espam.visitor.PlatformVisitor;
import espam.visitor.dot.platform.PlatformDotVisitor;
import espam.visitor.xml.cdpn.CDPNXmlVisitor;
import espam.visitor.yapiPN.YapiStatementVisitor;
import espam.visitor.ymlPN.YmlNetworkVisitor;


//////////////////////////////////////////////////////////////////////////
//// Platform Mhs Visitor

/**
 *  This class is a class for a visitor that is used to generate
 *  Microprocessor Hardware Specification for Xps tool.
 *
 * @author  Wei Zhong, Todor Stefanov, Hristo Nikolov, Joris Huizer
 * @version  $Id: MhsVisitor.java,v 1.15 2012/05/09 08:06:29 tzhai Exp $
 */

public class MhsVisitor extends PlatformVisitor {

    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///

    /**
     *  Constructor for the MhsVisitor object
     */
    public MhsVisitor(Mapping mapping)
        throws FileNotFoundException,EspamException {

    	_ui = UserInterface.getInstance();
	_mapping = mapping;
        _targetBoard = _getBoard( mapping.getPlatform() );

        _printStream = _openFile("system", "mhs");
        _printStream.println("## File automatically generated by ESPAM");
        _printStream.println("");
        _printStream.println("");

    }

    /**
     *  Print a Mhs file in the correct format for MHS.
     *
     * @param  x The platform that needs to be rendered.
     */
    public void visitComponent(Platform x) {

        _prefixInc();

        Iterator j;
        //Visit all processes
        Resource resourceCheck;
        j = x.getResourceList().iterator();
        while( j.hasNext() ) {
            resourceCheck = (Resource) j.next();
            if ( resourceCheck instanceof ZBTMemoryController ) {
            	_numZbtCtrl++;
            }
            if ( resourceCheck instanceof MicroBlaze ) {
            	_numMb++;
            }
            if ( resourceCheck instanceof Uart ) {
            	_numUart++;
            }
            if ( resourceCheck instanceof CompaanHWNode){
            	_numHWNode++;
            }
        }

        _printStream.println("PARAMETER VERSION = 2.1.0\n");

        if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {

	        if ( _numZbtCtrl == 0 ) {
            	_printStream.println(
                		" PORT sys_clk = sys_clk_s, DIR = IN, SIGIS = CLK\n" +
                		" PORT system_reset = net_design_rst, DIR = IN");
            } else {
            	_printStream.println(
            		" PORT lclk = lclk, DIR = IN\n" +
            		" PORT mclk = mclk, DIR = IN\n" +
            		" PORT ramclki = ramclki, VEC = [1:0], DIR = IN\n" +
            		" PORT ramclko = ramclko, VEC = [1:0], DIR = OUT\n" +
            		" PORT lreseto_l = lreseto_l, DIR = IN\n" +
            		" PORT lwrite = lwrite, DIR = IN\n" +
            		" PORT lads_l = lads_l, DIR = IN\n" +
            		" PORT lblast_l = lblast_l, DIR = IN\n" +
            		" PORT lbterm_l = lbterm_l, DIR = INOUT\n" +
            		" PORT ld = ld, VEC = [31:0], DIR = INOUT\n" +
            		" PORT la = la, VEC = [23:2], DIR = IN\n" +
            		" PORT lreadyi_l = lreadyi_l, DIR = OUT\n" +
            		" PORT lbe_l = lbe_l, VEC = [3:0], DIR = IN\n" +
            		" PORT fholda = fholda, DIR = IN\n" +
            		" PORT ra0 = ra0, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd0 = rd0, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc0 = rc0, VEC = [8:0], DIR = OUT\n" +
            		" PORT ra1 = ra1, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd1 = rd1, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc1 = rc1, VEC = [8:0], DIR = OUT\n" +
            		" PORT ra2 = ra2, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd2 = rd2, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc2 = rc2, VEC = [8:0], DIR = OUT\n" +
            		" PORT ra3 = ra3, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd3 = rd3, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc3 = rc3, VEC = [8:0], DIR = OUT\n" +
            		" PORT ra4 = ra4, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd4 = rd4, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc4 = rc4, VEC = [8:0], DIR = OUT\n" +
            		" PORT ra5 = ra5, VEC = [19:0], DIR = OUT\n" +
            		" PORT rd5 = rd5, VEC = [31:0], DIR = INOUT\n" +
            		" PORT rc5 = rc5, VEC = [8:0], DIR = OUT");
            }

            for (int i = 1; i <= _numUart; i++) {
		_printStream.println(
		        " PORT RS232_Uart_" + i + "_RX = RS232_Uart_" + i + "_RX, DIR = I\n" +
		        " PORT RS232_Uart_" + i + "_TX = RS232_Uart_" + i + "_TX, DIR = O");
            }
        } else if( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") ) {

		    String sigIn = "sin";
		    String sigOut = "sout";
		    if(  _targetBoard.equals("ML505") ) {
			    sigIn = "RX";
			    sigOut = "TX";
		    }

            if ( _numZbtCtrl == 1 ) {
	             _printStream.println(
	            " PORT fpga_0_SRAM_Mem_A_pin = fpga_0_SRAM_Mem_A, DIR = O, VEC = [7:30]\n" +
	            " PORT fpga_0_SRAM_Mem_DQ_pin = fpga_0_SRAM_Mem_DQ, DIR = IO, VEC = [0:31]\n" +
	            " PORT fpga_0_SRAM_Mem_BEN_pin = fpga_0_SRAM_Mem_BEN, DIR = O, VEC = [0:3]\n" +
	            " PORT fpga_0_SRAM_Mem_OEN_pin = fpga_0_SRAM_Mem_OEN, DIR = O\n" +
	            " PORT fpga_0_SRAM_Mem_CEN_pin = fpga_0_SRAM_Mem_CEN, DIR = O\n" +
	            " PORT fpga_0_SRAM_Mem_ADV_LDN_pin = fpga_0_SRAM_Mem_ADV_LDN, DIR = O\n" +
	            " PORT fpga_0_SRAM_Mem_WEN_pin = fpga_0_SRAM_Mem_WEN, DIR = O\n" +
	            " PORT fpga_0_SRAM_CLK = ZBT_CLK_OUT_s, DIR = O\n" +
	            " PORT fpga_0_SRAM_CLK_FB = ZBT_CLK_FB_s, DIR = I, SIGIS = CLK, CLK_FREQ = 125000000");
	        }

                    _printStream.println(
	        " PORT fpga_0_RS232_Uart_1_" + sigIn + "_pin = fpga_0_RS232_Uart_1_sin, DIR = I\n" +
	        " PORT fpga_0_RS232_Uart_1_" + sigOut + "_pin = fpga_0_RS232_Uart_1_sout, DIR = O\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_ODT_pin = fpga_0_DDR2_SDRAM_DDR2_ODT, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_Addr_pin = fpga_0_DDR2_SDRAM_DDR2_Addr, DIR = O, VEC = [12:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_BankAddr_pin = fpga_0_DDR2_SDRAM_DDR2_BankAddr, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_CAS_n_pin = fpga_0_DDR2_SDRAM_DDR2_CAS_n, DIR = O\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_CE_pin = fpga_0_DDR2_SDRAM_DDR2_CE, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_CS_n_pin = fpga_0_DDR2_SDRAM_DDR2_CS_n, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_RAS_n_pin = fpga_0_DDR2_SDRAM_DDR2_RAS_n, DIR = O\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_WE_n_pin = fpga_0_DDR2_SDRAM_DDR2_WE_n, DIR = O\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_Clk_pin = fpga_0_DDR2_SDRAM_DDR2_Clk, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_Clk_n_pin = fpga_0_DDR2_SDRAM_DDR2_Clk_n, DIR = O, VEC = [1:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_DM_pin = fpga_0_DDR2_SDRAM_DDR2_DM, DIR = O, VEC = [7:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_DQS_pin = fpga_0_DDR2_SDRAM_DDR2_DQS_pin, DIR = IO, VEC = [7:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_DQS_n_pin = fpga_0_DDR2_SDRAM_DDR2_DQS_n_pin, DIR = IO, VEC = [7:0]\n" +
	        " PORT fpga_0_DDR2_SDRAM_DDR2_DQ_pin = fpga_0_DDR2_SDRAM_DDR2_DQ_pin, DIR = IO, VEC = [63:0]\n" +
	        " PORT sys_clk_pin = dcm_clk_s, DIR = I, SIGIS = CLK, CLK_FREQ = 100000000\n" +
	        " PORT sys_rst_pin = sys_rst_s, DIR = I, RST_POLARITY = 0, SIGIS = RST");
	}
    else if (_targetBoard.equals("ML605")) {
//            if(_commInterface.equals("UART") {
		    _printStream.println(
			" PORT fpga_0_RS232_Uart_1_RX_pin = fpga_0_RS232_Uart_1_RX_pin, DIR = I\n" +
			" PORT fpga_0_RS232_Uart_1_TX_pin = fpga_0_RS232_Uart_1_TX_pin, DIR = O");
//            } else 
            if( _commInterface.equals("USB") ) {
		    _printStream.println(
			" PORT PRH_CS_n = xps_epc_0_PRH_CS_n_int, DIR = O\n" +
			" PORT usb_oen = usb_rdn, DIR = O\n" +
			" PORT usb_wen = usb_wrn, DIR = O\n" +
			" PORT usb_d = usb_data_int, VEC = [15:0], DIR = IO\n" +
			" PORT usb_a = usb_addr, DIR = O, VEC = [0:1]\n");
            }
            
            if( _isAXICrossbar ) {

 		    _printStream.println(
			" PORT axi_iic_0_Sda_pin = axi_iic_0_Sda, DIR = IO\n" +
			" PORT axi_iic_0_Scl_pin = axi_iic_0_Scl, DIR = IO\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Clk_pin = ddr_memory_clk, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Clk_n_pin = ddr_memory_clk_n, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CE_pin = ddr_memory_cke, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CS_n_pin = ddr_memory_cs_n, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_ODT_pin = ddr_memory_odt, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_RAS_n_pin = ddr_memory_ras_n, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CAS_n_pin = ddr_memory_cas_n, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_WE_n_pin = ddr_memory_we_n, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DM_pin = ddr_memory_dm, DIR = O, VEC = [7:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_BankAddr_pin = ddr_memory_ba, DIR = O, VEC = [2:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Addr_pin = ddr_memory_addr, DIR = O, VEC = [12:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Reset_n_pin = ddr_memory_ddr3_rst, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQ_pin = fpga_0_DDR3_SDRAM_DDR3_DQ_pin, DIR = IO, VEC = [63:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_pin = fpga_0_DDR3_SDRAM_DDR3_DQS_pin, DIR = IO, VEC = [7:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin = fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin, DIR = IO, VEC = [7:0]\n" +
// 			" PORT fpga_0_DDR3_SDRAM_DDR3_DQ_pin = ddr_memory_dq, DIR = IO, VEC = [63:0]\n" +
// 			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_pin = ddr_memory_dqs, DIR = IO, VEC = [7:0]\n" +
// 			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin = ddr_memory_dqs_n, DIR = IO, VEC = [7:0]\n" +
			" PORT fpga_0_clk_1_sys_clk_p_pin = CLK_S, DIR = I, SIGIS = CLK, DIFFERENTIAL_POLARITY = P, CLK_FREQ = 200000000\n" +
			" PORT fpga_0_clk_1_sys_clk_n_pin = CLK_S, DIR = I, SIGIS = CLK, DIFFERENTIAL_POLARITY = N, CLK_FREQ = 200000000\n" +
			" PORT fpga_0_rst_1_sys_rst_pin = sys_rst_s, DIR = I, SIGIS = RST, RST_POLARITY = 1\n");


            } else { 
		    _printStream.println(
			" PORT fpga_0_DDR3_SDRAM_DDR3_Clk_pin = fpga_0_DDR3_SDRAM_DDR3_Clk_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Clk_n_pin = fpga_0_DDR3_SDRAM_DDR3_Clk_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CE_pin = fpga_0_DDR3_SDRAM_DDR3_CE_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CS_n_pin = fpga_0_DDR3_SDRAM_DDR3_CS_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_ODT_pin = fpga_0_DDR3_SDRAM_DDR3_ODT_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_RAS_n_pin = fpga_0_DDR3_SDRAM_DDR3_RAS_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_CAS_n_pin = fpga_0_DDR3_SDRAM_DDR3_CAS_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_WE_n_pin = fpga_0_DDR3_SDRAM_DDR3_WE_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_BankAddr_pin = fpga_0_DDR3_SDRAM_DDR3_BankAddr_pin, DIR = O, VEC = [2:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Addr_pin = fpga_0_DDR3_SDRAM_DDR3_Addr_pin, DIR = O, VEC = [12:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQ_pin = fpga_0_DDR3_SDRAM_DDR3_DQ_pin, DIR = IO, VEC = [31:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DM_pin = fpga_0_DDR3_SDRAM_DDR3_DM_pin, DIR = O, VEC = [3:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_Reset_n_pin = fpga_0_DDR3_SDRAM_DDR3_Reset_n_pin, DIR = O\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_pin = fpga_0_DDR3_SDRAM_DDR3_DQS_pin, DIR = IO, VEC = [3:0]\n" +
			" PORT fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin = fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin, DIR = IO, VEC = [3:0]\n" +
			" PORT fpga_0_clk_1_sys_clk_p_pin = CLK_S, DIR = I, SIGIS = CLK, DIFFERENTIAL_POLARITY = P, CLK_FREQ = 200000000\n" +
			" PORT fpga_0_clk_1_sys_clk_n_pin = CLK_S, DIR = I, SIGIS = CLK, DIFFERENTIAL_POLARITY = N, CLK_FREQ = 200000000\n" +
			" PORT fpga_0_rst_1_sys_rst_pin = sys_rst_s, DIR = I, SIGIS = RST, RST_POLARITY = 1\n");
             }
    }



        _printStream.println("");

	Iterator i;

        // Visit all processes
        Resource resource;
        i = x.getResourceList().iterator();
        while( i.hasNext() ) {
            resource = (Resource) i.next();
            resource.accept(this);
        }

        _printStream.println("");

        _prefixDec();
        _printStream.println("");
    }
/*---------------------------------------- Processors --------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(PowerPC x) {

    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(MicroBlaze x) {

       Iterator i;
       i = x.getPortList().iterator();

       String dLmbLinkName = "";
       String iLmbLinkName = "";
       String opbLinkName = "";
       String plbLinkName = "";
       String axiLinkName = "";
       String clkSignal = "sys_clk_s";

       while (i.hasNext()) {
	   String activeRST = "";
	   String rstSignal = "";
           if( _isAXICrossbar) {
               clkSignal = x.getName() + "_clk";
           } 
	   if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		activeRST = "0";
		rstSignal = "net_design_rst";

			} else if( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") || _targetBoard.equals("ML605")) {
		activeRST = "1";
		rstSignal = "sys_bus_reset";
	   }
           Port port = (Port) i.next();
           if ( port instanceof DLMBPort ) {
              dLmbLinkName = port.getLink().getName();
              _printStream.println(
      		       "BEGIN lmb_v10\n" +
    		       " PARAMETER INSTANCE = " + dLmbLinkName + "\n" +
    		       " PARAMETER HW_VER = 2.00.b\n" +
    		       " PARAMETER C_EXT_RESET_HIGH = " + activeRST + "\n" +
    		       " PORT SYS_Rst = " + rstSignal +"\n" +
    		       " PORT LMB_Clk = " + clkSignal + "\n" +
    		       "END\n");
           }
           if ( port instanceof ILMBPort ) {
              iLmbLinkName = port.getLink().getName();

              _printStream.println(
      		       "BEGIN lmb_v10\n" +
    		       " PARAMETER INSTANCE = " + iLmbLinkName + "\n" +
    		       " PARAMETER HW_VER = 2.00.b\n" +
    		       " PARAMETER C_EXT_RESET_HIGH = " + activeRST +"\n" +
    		       " PORT SYS_Rst = " + rstSignal +"\n" +
    		       " PORT LMB_Clk = " + clkSignal + "\n" +
    		       "END\n");
           }
           if ( port instanceof OPBPort ) {
               opbLinkName = port.getLink().getName();
               _printStream.println(
       		       "BEGIN opb_v20\n" +
     		       " PARAMETER INSTANCE = " + opbLinkName + "\n" +
     		       " PARAMETER HW_VER = 1.10.c\n" +
     		       " PARAMETER C_EXT_RESET_HIGH = 0\n" +
     		       " PORT SYS_Rst = net_design_rst\n" +
     		       " PORT OPB_Clk = " + clkSignal + "\n" +
     		       "END\n");
            }
           if ( port instanceof PLBPort && ( _targetBoard.equals("XUPV5-LX110T") ) ) {
               plbLinkName = port.getLink().getName();
               _printStream.println(
       		       "BEGIN plb_v46\n" +
     		       " PARAMETER INSTANCE = " + plbLinkName + "\n" +
     		       " PARAMETER HW_VER = 1.05.a\n" +
     		       " PORT SYS_Rst = sys_bus_reset\n" +
     		       " PORT PLB_Clk = " + clkSignal + "\n" +
     		       "END\n");
            }

           if ( port instanceof PLBPort && ( _targetBoard.equals("ML505") ) ) {
               plbLinkName = port.getLink().getName();
               _printStream.println(
       		       "BEGIN plb_v46\n" +
     		       " PARAMETER INSTANCE = " + plbLinkName + "\n" +
     		       " PARAMETER HW_VER = 1.05.a\n" +
     		       " PORT SYS_Rst = sys_bus_reset\n" +
     		       " PORT PLB_Clk = " + clkSignal + "\n" +
     		       "END\n");
            }

           if ( port instanceof PLBPort && ( _targetBoard.equals("ML605") ) ) {
               plbLinkName = port.getLink().getName();
               _printStream.println(
       		       "BEGIN plb_v46\n" +
     		       " PARAMETER INSTANCE = " + plbLinkName + "\n" +
     		       " PARAMETER HW_VER = 1.05.a\n" +
     		       " PORT SYS_Rst = sys_bus_reset\n" +
     		       " PORT PLB_Clk = " + clkSignal + "\n" +
     		       "END\n");
            }

           if ( port instanceof AXIPort && ( _targetBoard.equals("ML605") ) ) {
               axiLinkName = x.getName() + "_axi4lite_DP";
               _printStream.println(
       		       "BEGIN axi_interconnect\n" +
     		       " PARAMETER INSTANCE = " + axiLinkName + "\n" +
     		       " PARAMETER HW_VER = 1.03.a\n" +
                       " PARAMETER C_INTERCONNECT_CONNECTIVITY_MODE = 0\n" +
                       " PORT INTERCONNECT_ARESETN = sys_Interconnect_aresetn\n" +
                       " PORT INTERCONNECT_ACLK = sys_clk_100_MHz\n" +
     		       "END\n");
            }

       }

       _printStream.println(
   		       "BEGIN fin_ctrl\n" +
 		       " PARAMETER INSTANCE = fin_ctrl_P" + _numFinCtrl + "\n" +
 		       " PARAMETER HW_VER = 1.00.a\n" +
 		       " PARAMETER C_BASEADDR = 0xf9000000\n" +
 		       " PARAMETER C_HIGHADDR = 0xf900000f\n" +
 		       " PARAMETER C_AB = 8\n" +
 		       " BUS_INTERFACE SLMB = " + dLmbLinkName);

        if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		_printStream.println(
 		       " PORT ENABLE = net_vcc");
	} else {
		_printStream.println(
 		       " PORT ENABLE = net_enable_MBs");
	}

       _printStream.println(
 		       " PORT FinOut = net_fin_signal_P" + _numFinCtrl + "\n" +
 		       "END\n");

       if( _ui.getDebuggerFlag() ) {
    	   _printStream.println(
       		       "BEGIN clock_cycle_counter\n" +
     		       " PARAMETER INSTANCE = clock_cycle_counter_P" + _numFinCtrl + "\n" +
     		       " PARAMETER HW_VER = 1.00.a\n" +
     		       " PARAMETER C_BASEADDR = 0xf8000000\n" +
     		       " PARAMETER C_HIGHADDR = 0xf8000003\n" +
     		       " BUS_INTERFACE SLMB = " + dLmbLinkName + "\n" +
     		       " PORT LMB_Clk = " + clkSignal + "\n" +
     		       "END\n");

		}

       _numFinCtrl++;

       if ( _mapping.getProcessor(x.getName()).getScheduleType() == 1 ) {

           if ( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {

		_printStream.println(
			"BEGIN opb_timer\n" +
			" PARAMETER INSTANCE = opb_timer_" + _numTimers + "\n" +
			" PARAMETER HW_VER = 1.00.b\n" +
			" PARAMETER C_BASEADDR = 0xF1000000\n" +
			" PARAMETER C_HIGHADDR = 0xF100FFFF\n" +
			" BUS_INTERFACE SOPB = " + opbLinkName + "\n" +
			" PORT Interrupt = " + x.getName() + "_INTERRUPT\n" +
			"END\n");
		_numTimers++;

           } else if ( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") || _targetBoard.equals("ML605")) {
// not completed to support OS...
                if( !plbLinkName.equals("") ) {
		     _printStream.println(
			"BEGIN xps_timer\n" +
			" PARAMETER INSTANCE = xps_timer_" + _numTimers + "\n" +
			" PARAMETER HW_VER = 1.02.a\n" +
			" PARAMETER C_COUNT_WIDTH = 32\n" +
			" PARAMETER C_ONE_TIMER_ONLY = 1\n" +
			" PARAMETER C_BASEADDR = 0xF1000000\n" +
			" PARAMETER C_HIGHADDR = 0xF100FFFF\n" +
			" BUS_INTERFACE SPLB = " + plbLinkName + "\n" +
			" PORT Interrupt = " + x.getName() + "_INTERRUPT\n" +
			"END\n\n");
		     _numTimers++;
                }
           }
 	}
      if ( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {

            _printStream.println(
		"BEGIN microblaze\n" +
		" PARAMETER INSTANCE = " + x.getName() + "\n" +
		" PARAMETER HW_VER = 4.00.a\n" +
		" PARAMETER C_NUMBER_OF_PC_BRK = 1\n" +
		" PARAMETER C_NUMBER_OF_RD_ADDR_BRK = 0\n" +
		" PARAMETER C_NUMBER_OF_WR_ADDR_BRK = 0");

      } else if ( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") ) {

            _printStream.println(
			"BEGIN microblaze\n" +
			" PARAMETER INSTANCE = " + x.getName() + "\n" +
			" PARAMETER C_INSTANCE = " + x.getName() + "\n" +
			" PARAMETER HW_VER = 8.20.a\n" +
			" PARAMETER C_FAMILY = virtex5\n" +
			" PARAMETER C_DEBUG_ENABLED = 0\n" +
			" PARAMETER C_INTERCONNECT = 1\n" );

			if ( !plbLinkName.equals("") ) {
				_printStream.println(
				" BUS_INTERFACE DPLB = " + plbLinkName + "\n" +
				" BUS_INTERFACE IPLB = " + plbLinkName );
			}
      } else if ( _targetBoard.equals("ML605") ) {
			_printStream.println(
			"BEGIN microblaze\n" +
			" PARAMETER INSTANCE = " + x.getName() + "\n" +
			" PARAMETER HW_VER = 8.20.a\n" +
			" PARAMETER C_FAMILY = virtex6\n" +		
			" PARAMETER C_USE_BARREL = 1\n" +
			" PARAMETER C_USE_FPU = 1\n" +
			" PARAMETER C_DEBUG_ENABLED = 0\n" +
			" PARAMETER C_USE_ICACHE = 0\n" +
			" PARAMETER C_USE_DCACHE = 0\n" +
			" PARAMETER C_USE_DIV = 1" );

			if ( !plbLinkName.equals("") ) {
				_printStream.println(
                                " PARAMETER C_INTERCONNECT = 1\n" +
				" BUS_INTERFACE DPLB = " + plbLinkName + "\n" +
				" BUS_INTERFACE IPLB = " + plbLinkName );
			}
			if ( !axiLinkName.equals("") ) {
				_printStream.println(
                                " PARAMETER C_INTERCONNECT = 2\n" +
				" PARAMETER C_INTERCONNECT_M_AXI_DC_AW_REGISTER = 0\n" +
				" PARAMETER C_INTERCONNECT_M_AXI_DC_W_REGISTER = 0\n" +
				" PARAMETER C_PVR = 1\n" +
				" PARAMETER C_PVR_USER1 = 0x01\n" +
				" BUS_INTERFACE M_AXI_DP = " + axiLinkName + "\n" +
                " PORT INTERRUPT = " + x.getName() + "_intc_Irq");
			}


		}

      i = x.getPortList().iterator();
      int numReadFsl = 0;
      int numWriteFsl = 0;

      while (i.hasNext()) {
           Port port = (Port) i.next();

           if ( port instanceof FifoReadPort ) {
		Iterator j = x.getMemoryMapList().iterator();
                while (j.hasNext()) {
                    MemoryMap memoryMap = (MemoryMap) j.next();

//System.out.println( memoryMap.getPort().getName() );
//System.out.println( port.getName() );

                    if (memoryMap.getPort().getName().equals(port.getName())) {
                	  Page page = (Page) memoryMap.getPageList().get(0);
                	  _printStream.println(
              				" BUS_INTERFACE SFSL" + page.getBaseAddress() + " = " + page.getReadResource().getName() );
                	  numReadFsl++;
                    }
                }
           }
//System.out.println();

           if ( port instanceof FifoWritePort ) {
        	   Iterator j = x.getMemoryMapList().iterator();
               while (j.hasNext()) {
                  MemoryMap memoryMap = (MemoryMap) j.next();
                  if (memoryMap.getPort().getName().equals(port.getName())) {
                	  Page page = (Page) memoryMap.getPageList().get(0);
                	  _printStream.println(
              				" BUS_INTERFACE MFSL" + page.getBaseAddress() + " = " + page.getWriteResource().getName() );
                	  numWriteFsl++;
                  }

               }

           }
	}

        int total = (numReadFsl > numWriteFsl) ? numReadFsl : numWriteFsl;

        _printStream.println(
			  " BUS_INTERFACE DLMB = " + dLmbLinkName + "\n" +
			  " BUS_INTERFACE ILMB = " + iLmbLinkName );
        if ( !opbLinkName.equals("") ) {
             _printStream.println(
			  " BUS_INTERFACE DOPB = " + opbLinkName );
        }
        _printStream.println(
			  " PARAMETER C_FSL_LINKS = " + total + "\n" +
			  " PORT CLK = " + clkSignal );

        if ( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") || _targetBoard.equals("ML605")) {
                _printStream.println(
			  " PORT MB_RESET = mb_reset");
        }
	if ( _mapping.getProcessor(x.getName()).getScheduleType() == 1 ) {
             if( _targetBoard.equals("ML505") ) {
		_printStream.println(
			  " PORT INTERRUPT = " + x.getName() + "_INTERRUPT");
             } 

	}
	_printStream.println("END\n");

        if( !axiLinkName.equals("") ) {
        
        
                _printStream.println(
              "BEGIN axi_intc\n" +
              " PARAMETER INSTANCE = " + x.getName() + "_intc\n" +
              " PARAMETER HW_VER = 1.01.a\n" +
              " PARAMETER C_BASEADDR = 0xF2000000\n" +
              " PARAMETER C_HIGHADDR = 0xF200FFFF\n" +
              " BUS_INTERFACE S_AXI = " + axiLinkName + "\n"+
              " PORT Intr = " + x.getName() + "_INTERRUPT\n" +
              " PORT Irq = " + x.getName() + "_intc_Irq\n" +
              " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
              "END\n");
              
                _printStream.println(
			  "BEGIN axi_timer\n" +
			  " PARAMETER INSTANCE = " + x.getName() + "_timer\n" +
			  " PARAMETER HW_VER = 1.02.a\n" +
			  " PARAMETER C_BASEADDR = 0xF1000000\n" +
			  " PARAMETER C_HIGHADDR = 0xF100FFFF\n" +
			  " BUS_INTERFACE S_AXI = " + axiLinkName + "\n" +
			  " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
			  " PORT Interrupt = " + x.getName() + "_INTERRUPT\n" +
			  "END\n" );

// clock generation per MicroBlaze

	    if( !_first ) {

                _printStream.println(
			  "BEGIN clock_generator\n" +
			  " PARAMETER INSTANCE = " + x.getName() + "_clock_generator\n" +
			  " PARAMETER HW_VER = 4.02.a\n" +
			  " PARAMETER C_CLKIN_FREQ = 200000000\n" +
			  " PARAMETER C_CLKOUT0_FREQ = 100000000\n" +
			  " PARAMETER C_CLKOUT0_GROUP = MMCM0\n" +
			  " PARAMETER C_CLKOUT0_BUF = TRUE\n" +
			  " PORT RST = sys_rst_s\n" +
			  " PORT CLKIN = CLK_S\n" +
			  " PORT CLKOUT0 = " + x.getName() + "_clk\n" +
			  " PORT LOCKED = clock_locked_port_" + ++_cntr + "\n" +
			  "END\n");

   
                _printStream.println(
			  "BEGIN util_vector_logic\n" +
			  " PARAMETER INSTANCE = dcm_clock_locked_" + (_cntr-2) + "\n" +
			  " PARAMETER HW_VER = 1.00.a\n" +
			  " PARAMETER C_OPERATION = and\n" +
			  " PARAMETER C_SIZE = 1\n" +
			  " PORT Op1 = clock_locked_port_" + (_cntr-2) + "_" + (_cntr-1) + "\n" +
			  " PORT Op2 = clock_locked_port_" + _cntr + "\n" +
			  " PORT Res = clock_locked_port_" + (_cntr-1) + "_" + _cntr + "\n" +
			  "END\n");
	    } else {
		_first = false;
                _printStream.println(
			  "BEGIN clock_generator\n" +
			  " PARAMETER INSTANCE = " + x.getName() + "_clock_generator\n" +
			  " PARAMETER HW_VER = 4.02.a\n" +
			  " PARAMETER C_CLKIN_FREQ = 200000000\n" +
			  " PARAMETER C_CLKOUT0_FREQ = 100000000\n" +
			  " PARAMETER C_CLKOUT0_GROUP = MMCM0\n" +
			  " PARAMETER C_CLKOUT0_BUF = TRUE\n" +
			  " PORT RST = sys_rst_s\n" +
			  " PORT CLKIN = CLK_S\n" +
			  " PORT CLKOUT0 = " + x.getName() + "_clk\n" +
			  " PORT LOCKED = clock_locked_port_" + _cntr++ + "_" + _cntr + "\n" +
			  "END\n");

	    }



        }

    }
/*--------------------------------------- CompaanHWNode -------------------------------------------------------*/
    /**
     *  Print lines for the Compaan Hardware Node in the correct format for MHS.
     *
     * @param  x The Compaan Hardware Node that needs to be rendered.
     */
    public void visitComponent(CompaanHWNode x) {

	   String activeRST = "";
	   String rstSignal = "";
	   if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		activeRST = "0";
		rstSignal = "net_design_rst";
	   } else if( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") ) {
		activeRST = "0";
		rstSignal = "reset_IP";
	   }

	   _printStream.println(
    	    	"BEGIN " + x.getName() + "\n" +
    	    	"  PARAMETER INSTANCE = " + x.getName() + "_ip" + "\n" +
    	    	"  PARAMETER HW_VER = 1.00.a" + "\n" +
    	    	"  PARAMETER RESET_HIGH = " + activeRST + "\n" +
    	    	"  PARAMETER PAR_WIDTH = 16" + "\n" +
    	    	"  PARAMETER QUANT = 32");

    	//in mhs, the right side is the fsl fifo name because it is not regarded as a component
    	    	Vector portList = x.getPortList();
    			Iterator i = portList.iterator();
    			while(i.hasNext()){
    				Port p = (Port) i.next();

    				Iterator j = p.getLink().getPortList().iterator();
    				Fifo f = null;
    				while(j.hasNext()){
    					Port port = (Port) j.next();
                        //the port connect to the link which is not compaan port is the fifo port
    					if (! (port instanceof CompaanInPort) && !( port instanceof CompaanOutPort)){
    						f = (Fifo) port.getResource();
    					}
    				}
    				_printStream.println("  BUS_INTERFACE " + p.getName() + " = " + f.getName());
    			}

    	_printStream.println(
		"  BUS_INTERFACE PAR_BUS = PARBUS" + "\n" +
    		"  PORT CLK = sys_clk_s" + "\n" +
    	    	"  PORT RST = " + rstSignal + "\n" +
    	    	"  PORT STOP = net_fin_signal_IP_" + _numFinIP + "\n" +
    	    	"END\n");

    	_numFinIP++;



    }
/*---------------------------------------- Memories ----------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(MultiFifo x) {

        int procType    = 0;
	String busType  = "";
	String slave    = "";
	String slaveBus = "";
	String vbBus    = "";
	int n_ch        = x.getFifoList().size();
	int nmbr        = 1;

	Iterator i;
        i = x.getPortList().iterator();
        while (i.hasNext()) {

            Port port = (Port) i.next();
	    if( port instanceof LMBPort ) {
	        procType = 1;
	        busType  = "lmb";
		slave    = "CTRL_BUS";
		slaveBus = port.getLink().getName();

	    } else if( port instanceof PLBPort ) {
	        procType = 0;
	        busType  = "plb";
		slave    = "PLB2IP";
		slaveBus = port.getLink().getName();

	    } else {
	        vbBus = port.getLink().getName();
	    }
	}

	_printStream.println(
        		"BEGIN vb_wrapper\n" +
        		" PARAMETER INSTANCE = " + x.getName() + "\n" +
        		" PARAMETER HW_VER = 1.00.a\n" +
        		" PARAMETER PROCESSOR_TYPE = " + procType + "\n" +
        		" PARAMETER N_CH = " + n_ch);

        i = x.getFifoList().iterator();
        while (i.hasNext()) {

            Fifo fifo = (Fifo) i.next();
	    int fifoSize = fifo.getSize();
	    _printStream.println(" PARAMETER CH_SIZE_" + nmbr++ + " = " + fifoSize );

	}

        _printStream.println(" BUS_INTERFACE " + slave + " = " + slaveBus);
        _printStream.println(" BUS_INTERFACE CB_BUS = " + vbBus);
        _printStream.println("END\n");

    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(Fifo x) {

	String version = "";
	String activeRST = "";
	String rstSignal = "";

// Different versions due to different EDK versions used with the different boards

	if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		version = "2.00.a";
		activeRST = "0";
		rstSignal = "net_design_rst";
	} else if( _targetBoard.equals("XUPV5-LX110T") ) {
                version = "2.11.e";
		activeRST = "1";
		rstSignal = "sys_bus_reset";
	} else if( _targetBoard.equals("ML505") ) {
                version = "2.11.e";
		activeRST = "1";
		rstSignal = "sys_bus_reset";
	} else if( _targetBoard.equals("ML605") ) {
			version = "2.11.e";
			activeRST = "1";
			rstSignal = "sys_bus_reset";
	}

        int fifoSize = _greaterPowerOfTwo(x.getSize());
        if( fifoSize < 512 ) {
		fifoSize = 512;
	}

    	_printStream.println(
    			"BEGIN fsl_v20\n" +
    			" PARAMETER HW_VER = " + version + "\n" +
    			" PARAMETER INSTANCE = " + x.getName() + "\n" +
    			" PARAMETER C_EXT_RESET_HIGH = " + activeRST +"\n" +
    			" PARAMETER C_ASYNC_CLKS = 0\n" +
    			" PARAMETER C_IMPL_STYLE = 1\n" +
    			" PARAMETER C_USE_CONTROL = 0\n" +
    			" PARAMETER C_FSL_DWIDTH = " + x.getDataWidth() + "\n" +
//    			" PARAMETER C_FSL_DEPTH = " + x.getSize() + "\n" +
    			" PARAMETER C_FSL_DEPTH = " + fifoSize + "\n" +
    			" PORT FSL_Clk = sys_clk_s\n" +
    			" PORT SYS_Rst = " + rstSignal + "\n" +
    			"END\n");

    }

     /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(BRAM x) {

		String version = "";
		if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
			version = "1.00.a";
		} else if( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") || _targetBoard.equals("ML605")) {
			version = "1.00.a";
		}

    	_printStream.println(
    			"BEGIN bram_block\n" +
    			" PARAMETER INSTANCE = " + x.getName() + "\n" +
    			" PARAMETER HW_VER = " + version );

    	Iterator i;
        i = x.getPortList().iterator();

        Port port = (Port) i.next();
        String lmbCtrlLinkAName = port.getLink().getName();
    	_printStream.println(
    			" BUS_INTERFACE PORTA = " + lmbCtrlLinkAName );

        if (i.hasNext()) {
            port = (Port) i.next();
            String lmbCtrlLinkBName = port.getLink().getName();
            _printStream.println(
        			" BUS_INTERFACE PORTB = " + lmbCtrlLinkBName );
        }

    	_printStream.println(
    			"END\n");
    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(ZBT x) {

    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(CM_AXI x) {

            _printStream.println(
		  "BEGIN bram_block\n" +
		  " PARAMETER INSTANCE = " + x.getName() + "\n" +
		  " PARAMETER HW_VER = 1.00.a");

	    Iterator i;
	    i = x.getPortList().iterator();

	    Port port = (Port) i.next();
	    String lmbCtrlLinkAName = port.getLink().getName();
	    _printStream.println(
		" BUS_INTERFACE PORTA = " + lmbCtrlLinkAName );
	    if (i.hasNext()) {
		port = (Port) i.next();
		String lmbCtrlLinkBName = port.getLink().getName();
		_printStream.println(
		" BUS_INTERFACE PORTB = " + lmbCtrlLinkBName );
	    }
	    _printStream.println("END\n");
     }



/*--------------------------------------- Controllers -------------------------------------------------------*/
    /**
     *  Print a line for a memory controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(MemoryController x) {

    	Iterator i = x.getPortList().iterator();

        String procLinkName = "";
        String memLinkName = "";
        String busType  = "";

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();

            Iterator j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( lPort.getResource() instanceof MicroBlaze ) {
            		procLinkName = link.getName();
                        busType  = "lmb";
            	} else if ( lPort.getResource() instanceof PowerPC ) {
            		procLinkName = link.getName();
                        busType  = "plb";
            	} else if ( lPort.getResource() instanceof BRAM ) {
            		memLinkName = link.getName();
            	}
            }
        }

	String version = "";
	if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		version = "1.00.b";
	} else if( _targetBoard.equals("XUPV5-LX110T") ) {
		version = "3.00.b";
	} else if( _targetBoard.equals("ML505") ) {
		version = "3.00.a";
	} else if( _targetBoard.equals("ML605") ) {
		version = "3.00.b";
	}

        _printStream.println(
                    "BEGIN " + busType + "_bram_if_cntlr\n" +
                    " PARAMETER INSTANCE = " + x.getName() + "\n" +
		    " PARAMETER HW_VER = " + version + "\n" +
		    " PARAMETER C_MASK = 0xff000000\n" +
        	    " PARAMETER C_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
        	    " PARAMETER C_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + x.getSize() - 1, 8) + "\n" +
		    " BUS_INTERFACE SLMB = " + procLinkName + "\n" +
		    " BUS_INTERFACE BRAM_PORT = " + memLinkName + "\n" +
		    "END\n");

    }


    /**
     *  Print a line for a communication memory controller (LMB) in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(CM_CTRL x) {

    	Iterator i = x.getPortList().iterator();

        String procLinkName = "";
        String memLinkName = "";

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();

            Iterator j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( lPort.getResource() instanceof MicroBlaze ) {
            		procLinkName = link.getName();
            	} else if ( lPort.getResource() instanceof CM_AXI ) {
            		memLinkName = link.getName();
            	}
            }
        }

        _printStream.println(
                "BEGIN lmb_bram_if_cntlr\n" +
		" PARAMETER INSTANCE = " + x.getName() + "\n" +
		" PARAMETER HW_VER = 3.00.b\n" +
		" PARAMETER C_BASEADDR = 0xe0000000\n" +
		" PARAMETER C_HIGHADDR = 0xe000FFFF\n" +
		" BUS_INTERFACE SLMB = " + procLinkName + "\n" +
   	        " BUS_INTERFACE BRAM_PORT = " + memLinkName + "\n" +
		"END\n");
    }

    /**
     *  Print a line for an AXI communication memory controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(AXI_CM_CTRL x) {


        String memLinkName = "";

    	Iterator i = x.getPortList().iterator();
        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();

            Iterator j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
                if ( lPort.getResource() instanceof CM_AXI ) {
            		memLinkName = link.getName();
            	}
            }
        }

        String pName = "";
        String strAXI = " PARAMETER C_INTERCONNECT_S_AXI_MASTERS = ";

        Platform platform = (Platform) x.getLevelUpResource();
        i = platform.getResourceList().iterator();
        while( i.hasNext() ) {
            Resource res = (Resource) i.next();
            if( res instanceof MicroBlaze ) {  
                 pName = res.getName();
                 strAXI += pName + "_axi2axi_connector.M_AXI & ";
            }
        } 
        // remove the last 3 characters
        strAXI = strAXI.substring(0, strAXI.length()-2);

        _printStream.println(
                "BEGIN axi_bram_ctrl\n" +
		" PARAMETER INSTANCE = " + x.getName() + "\n" +
		" PARAMETER HW_VER = 1.02.a\n" +
                " PARAMETER C_SINGLE_PORT_BRAM = 1\n" +  
	        " PARAMETER C_S_AXI_BASEADDR = 0x" + _digitToStringHex(_axiCMBaseAddress, 8) + "\n" +
		" PARAMETER C_S_AXI_HIGHADDR = 0x" + _digitToStringHex(_axiCMBaseAddress + 0xFFFF, 8) + "\n" +
                strAXI + "\n" +
                " BUS_INTERFACE S_AXI = CB_axi\n" +
   	        " BUS_INTERFACE BRAM_PORTA = " + memLinkName + "\n" +
                " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
		"END\n");

       // update the axi base address of the next communication memory
       _axiCMBaseAddress += 0x00010000;
    }

    /**
     *  Print a line for an AXI2AXI controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(AXI2AXI_CTRL x) {

        String pName = "";
    	Iterator i = x.getPortList().iterator();
        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();

            Iterator j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
                if ( lPort.getResource() instanceof MicroBlaze ) {
            		pName = lPort.getResource().getName();
            	}
            }
        }
        
        _printStream.println(
		"BEGIN axi2axi_connector\n" +
		" PARAMETER INSTANCE = " + pName + "_axi2axi_connector\n" +
		" PARAMETER HW_VER = 1.00.a\n" +
		" PARAMETER C_S_AXI_NUM_ADDR_RANGES = 1\n" +
		" PARAMETER C_S_AXI_PROTOCOL = AXI4LITE\n" +
		" PARAMETER C_S_AXI_RNG00_BASEADDR = 0x80000000\n" +
		" PARAMETER C_S_AXI_RNG00_HIGHADDR = 0x8FFFFFFF\n" +
		" BUS_INTERFACE S_AXI = " + pName + "_axi4lite_DP\n" +
		" BUS_INTERFACE M_AXI = CB_axi\n" +
		"END\n");
    }

    /**
     *  Print a line for a ReadCrossbar controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(ReadCrossbarController x) {

    }

    /**
     *  Print a line for a multi-fifo controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(MultiFifoController x) {

        String busType  = "";
        String slave    = "";
        String slaveBus = "";
        String vbBus    = "";

        Iterator i = x.getPortList().iterator();

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();

            Iterator j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( lPort.getResource() instanceof MicroBlaze ) {
	                busType  = "lmb";
                        slave    = "SLMB";
			slaveBus = link.getName();
            	} else if ( lPort.getResource() instanceof PowerPC ) {
	                busType  = "plb";
                        slave    = "PLB2IP";
                        slaveBus = link.getName();
            	} else if ( lPort.getResource() instanceof MultiFifo ) {
                    vbBus = link.getName();
                }
            }
        }

        _printStream.println(
                    "BEGIN " + busType + "_vb_ctrl\n" +
                    " PARAMETER INSTANCE = " + x.getName() + "\n" +
                    " PARAMETER HW_VER = 1.00.a\n" +
                    " PARAMETER C_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
                    " PARAMETER C_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + _greaterPowerOfTwo(x.getSize()) - 1, 8) + "\n" +
                    " PARAMETER C_AB = 8\n" +
		    " PARAMETER C_AWIDTH   = 32\n" +
                    " PARAMETER C_DWIDTH   = 32");
        _printStream.println(" BUS_INTERFACE " + slave + " = " + slaveBus);
        _printStream.println(" BUS_INTERFACE VB_BUS = " + vbBus);
        _printStream.println("END\n");
    }

    /**
     *  Print a line for a fifos controller in the correct format for MHS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(FifosController x) {

        _printStream.println(
        	"BEGIN fifo_if_ctrl\n" +
        	" PARAMETER INSTANCE = " + x.getName() + "\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
		" PARAMETER C_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
		" PARAMETER C_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + _greaterPowerOfTwo(x.getSize()) - 1, 8) + "\n" +
        	" PARAMETER C_AB = 8\n" +
        	" PARAMETER C_FIFO_WRITE = " + x.getNumberFifoWritePorts() + "\n" +
        	" PARAMETER C_FIFO_READ = " + x.getNumberFifoReadPorts() );

    	Iterator i;
        i = x.getFifoReadPorts().iterator();

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();
            Iterator j;
            j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( lPort.getResource() instanceof Fifo ) {
            		_fifoList.add(lPort.getResource());
            	}
            }
        }

        Iterator k = x.getPageList().iterator();

        while (k.hasNext()) {

        	Page page = (Page) k.next();

        	if (page.getReadResource() instanceof Fifo) {

        		Iterator l = _fifoList.iterator();
        		while (l.hasNext()) {
        			Fifo fifo = (Fifo) l.next();
        			if (page.getReadResource().getName().equals(fifo.getName())) {
        				int baseAddr = page.getBaseAddress();
        				int tempAddr = baseAddr & 0x0000ffff;
        				int num = ( tempAddr / 8 ) + 1;
        				_printStream.println(
        						" BUS_INTERFACE FIFO_READ_" + num + " = " + fifo.getName() );
        				l.remove();
        			}

        		}

        	}
        }

        _fifoList.clear();
        i = x.getFifoWritePorts().iterator();

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();
            Iterator j;
            j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( lPort.getResource() instanceof Fifo ) {
            		_fifoList.add(lPort.getResource());
            	}
            }
        }

        k = x.getPageList().iterator();

        while (k.hasNext()) {

        	Page page = (Page) k.next();

        	if (page.getWriteResource() instanceof Fifo) {

        		Iterator l = _fifoList.iterator();
        		while (l.hasNext()) {
        			Fifo fifo = (Fifo) l.next();
        			if (page.getWriteResource().getName().equals(fifo.getName())) {
        				int baseAddr = page.getBaseAddress();
        				int tempAddr = baseAddr & 0x0000ffff;
        				int num = ( tempAddr / 8 ) + 1;
        				_printStream.println(
        						" BUS_INTERFACE FIFO_WRITE_" + num + " = " + fifo.getName() );
        				l.remove();
        			}

        		}

        	}
        }

        i = x.getPortList().iterator();
        String lmbLink = "";

        while (i.hasNext()) {
            Port port = (Port) i.next();
            Link link = port.getLink();
            Iterator j;
            j = link.getPortList().iterator();
            while (j.hasNext()) {
            	Port lPort = (Port) j.next();
            	if ( !(lPort.getResource() instanceof Fifo) &&
            			!(lPort.getResource() instanceof FifosController) ) {
            		lmbLink = link.getName();
            	}
            }
        }

        _printStream.println(
        		" BUS_INTERFACE SLMB = " + lmbLink + "\n" +
        		"END\n");

    }


/*--------------------------------------- Communication -------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(Crossbar x) {

        String activeRST = "";
	String rstSignal = "";
        if ( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
		activeRST = "0";
		rstSignal = "net_design_rst";
	} else {
		activeRST = "1";
		rstSignal = "sys_bus_reset";
	}

        _printStream.println(
        		"BEGIN cb_wrapper\n" +
        		" PARAMETER INSTANCE = " + x.getName() + "\n" +
        		" PARAMETER HW_VER = 1.00.a\n" +
			" PARAMETER C_EXT_RESET_HIGH = " + activeRST +"\n" +
    		        " PORT RST = " + rstSignal +"\n" +
    		        " PORT CLK = sys_clk_s");

    	Iterator i;
        i = x.getPortList().iterator();
        while (i.hasNext()) {

            Port port = (Port) i.next();
            Link link = port.getLink();

	    _printStream.println(" BUS_INTERFACE " + port.getName() + " = " + port.getLink().getName());
        }
	 _printStream.println("END\n");
    }

    /**
     *  Print a line for the AXI Crossbar in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(AXICrossbar x) {

        _printStream.println(
        		"BEGIN axi_interconnect\n" +
			" PARAMETER INSTANCE = CB_axi\n" +
			" PARAMETER HW_VER = 1.03.a\n" +
			" PORT INTERCONNECT_ACLK = sys_clk_100_MHz\n" +
			" PORT INTERCONNECT_ARESETN = sys_Interconnect_aresetn\n" +
			"END\n");
    }
/*---------------------------------------- Link --------------------------------------------------------------*/
    /**
     *  Print a line for the channel in the correct format for MHS.
     *
     * @param  x The channel that needs to be rendered.
     */
    public void visitComponent(Link x) {

    }
/*---------------------------------------- Host Interface------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(XUPV5LX110T x) {
// Here we currently need to 'print' 1 Microblaze with UART and Iterrupt to PLB, a HOST IP connected to DLMB.
// Also, we need all the FIN controllers connected to the host and MPMC. To the latter we connect the control
// microblaze + the MB processors need to have access to off-chip memory.

// Instantiate the control microblaze and the needed peripheral
	_printStream.println(
		"BEGIN microblaze\n" +
		" PARAMETER INSTANCE = host_if_mb\n" +
		" PARAMETER C_INSTANCE = host_if_mb\n" +
		" PARAMETER HW_VER = 8.20.a\n" +
		" PARAMETER C_FAMILY = virtex5\n" +
		" PARAMETER C_DEBUG_ENABLED = 0\n" +
		" PARAMETER C_INTERCONNECT = 1\n" +
		" BUS_INTERFACE DPLB = host_if_mb_plb\n" +
		" BUS_INTERFACE IPLB = host_if_mb_plb\n" +
		" BUS_INTERFACE DLMB = host_if_mb_dlmb\n" +
		" BUS_INTERFACE ILMB = host_if_mb_ilmb\n" +
		" PORT MB_RESET = mb_reset\n" +
		" PORT CLK = sys_clk_s\n" +
		" PORT Interrupt = Interrupt\n" +
		"END\n");

	_printStream.println(
		"BEGIN plb_v46\n" +
		" PARAMETER INSTANCE = host_if_mb_plb\n" +
		" PARAMETER HW_VER = 1.05.a\n" +
		" PORT PLB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_v10\n" +
		" PARAMETER INSTANCE = host_if_mb_ilmb\n" +
		" PARAMETER HW_VER = 2.00.b\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_v10\n" +
		" PARAMETER INSTANCE = host_if_mb_dlmb\n" +
		" PARAMETER HW_VER = 2.00.b\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_bram_if_cntlr\n" +
		" PARAMETER INSTANCE = dlmb_cntlr\n" +
		" PARAMETER HW_VER = 3.00.b\n" +
		" PARAMETER C_BASEADDR = 0x00000000\n" +
		" PARAMETER C_HIGHADDR = 0x00001fff\n" +
		" BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
		" BUS_INTERFACE BRAM_PORT = dlmb_port\n" +
		"END\n\n" +

		"BEGIN lmb_bram_if_cntlr\n" +
		" PARAMETER INSTANCE = ilmb_cntlr\n" +
		" PARAMETER HW_VER = 3.00.b\n" +
		" PARAMETER C_BASEADDR = 0x00000000\n" +
		" PARAMETER C_HIGHADDR = 0x00001fff\n" +
		" BUS_INTERFACE SLMB = host_if_mb_ilmb\n" +
		" BUS_INTERFACE BRAM_PORT = ilmb_port\n" +
		"END\n\n" +

		"BEGIN bram_block\n" +
		" PARAMETER INSTANCE = lmb_bram\n" +
		" PARAMETER HW_VER = 1.00.a\n" +
		" BUS_INTERFACE PORTA = ilmb_port\n" +
		" BUS_INTERFACE PORTB = dlmb_port\n" +
		"END\n\n" +

		"BEGIN clock_cycle_counter\n" +
		" PARAMETER INSTANCE = cycle_counter_host_if_mb\n" +
		" PARAMETER HW_VER = 1.00.a\n" +
		" PARAMETER C_BASEADDR = 0xf8000000\n" +
		" PARAMETER C_HIGHADDR = 0xf8000003\n" +
		" BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		"END\n\n" +

		"BEGIN xps_uart16550\n" +
		" PARAMETER INSTANCE = RS232_Uart_1\n" +
		" PARAMETER HW_VER = 3.00.a\n" +
		" PARAMETER C_IS_A_16550 = 1\n" +
		" PARAMETER C_BASEADDR = 0x83e20000\n" +
		" PARAMETER C_HIGHADDR = 0x83e2ffff\n" +
		" BUS_INTERFACE SPLB = host_if_mb_plb\n" +
		" PORT sin = fpga_0_RS232_Uart_1_sin\n" +
		" PORT sout = fpga_0_RS232_Uart_1_sout\n" +
		" PORT IP2INTC_Irpt = RS232_Uart_1_IP2INTC_Irpt\n" +
		"END\n\n" +

		"BEGIN xps_intc\n" +
		" PARAMETER INSTANCE = xps_intc_0\n" +
		" PARAMETER HW_VER = 2.01.a\n" +
		" PARAMETER C_BASEADDR = 0x81800000\n" +
		" PARAMETER C_HIGHADDR = 0x8180ffff\n" +
		" BUS_INTERFACE SPLB = host_if_mb_plb\n" +
		" PORT Irq = Interrupt\n" +
		" PORT Intr = RS232_Uart_1_IP2INTC_Irpt\n" +
		"END\n");


// Instantiate the host controller
	_printStream.println(
        	"BEGIN lmb_host_ctrl\n" +
        	" PARAMETER INSTANCE = lmb_host_interface_ctrl\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER C_BASEADDR = 0x0A000000\n" +
        	" PARAMETER C_HIGHADDR = 0x0A00000f\n" +
        	" PARAMETER C_AB = 8\n" +
        	" PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
        	" BUS_INTERFACE SLMB = host_if_mb_dlmb");

		if( _numHWNode > 0 ) {
		   _printStream.println(
			" BUS_INTERFACE PAR_BUS = PARBUS\n" +
			" PORT RST_OUT = reset_IP");
		}

        _printStream.println(
	   	" PORT ENABLE_MB = net_enable_MBs");

	for (int i = 1; i <= _numMb; i++) {
	       _printStream.println(
	   	" PORT FIN_" + ( i - 1 ) + " = net_fin_signal_P" + i);
	}

	for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
    	      _printStream.println(
		" PORT FIN_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
	}

	_printStream.println(
        	"END\n");

// Instantiate the clock generator and the reset block
	_printStream.println(
		"BEGIN clock_generator\n" +
		" PARAMETER INSTANCE = clock_generator_0\n" +
		" PARAMETER HW_VER = 4.02.a\n" +
		" PARAMETER C_EXT_RESET_HIGH = 1\n" +
		" PARAMETER C_CLKIN_FREQ = 100000000\n" +
		" PARAMETER C_CLKOUT0_FREQ = 125000000\n" +
		" PARAMETER C_CLKOUT0_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT0_PHASE = 0\n" +
		" PARAMETER C_CLKOUT0_GROUP = PLL0\n" +
		" PARAMETER C_CLKOUT1_FREQ = 125000000\n" +
		" PARAMETER C_CLKOUT1_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT1_PHASE = 90\n" +
		" PARAMETER C_CLKOUT1_GROUP = PLL0\n" +
		" PARAMETER C_CLKOUT2_FREQ = 200000000\n" +
		" PARAMETER C_CLKOUT2_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT2_PHASE = 0\n" +
		" PARAMETER C_CLKOUT2_GROUP = NONE\n" +
		" PARAMETER C_CLKOUT3_FREQ = 62500000\n" +
		" PARAMETER C_CLKOUT3_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT3_PHASE = 0\n" +
		" PARAMETER C_CLKOUT3_GROUP = NONE");

	if ( _numZbtCtrl == 1 ) {
	    _printStream.println(
		" PARAMETER C_CLKFBIN_FREQ = 125000000\n" +
		" PARAMETER C_CLKFBOUT_FREQ = 125000000\n" +
		" PARAMETER C_CLKFBOUT_BUF = TRUE");
	}

	    _printStream.println(
		" PORT CLKOUT0 = sys_clk_s\n" +
		" PORT CLKOUT1 = DDR2_SDRAM_mpmc_clk_90_s\n" +
		" PORT CLKOUT2 = clk_200mhz_s\n" +
		" PORT CLKOUT3 = DDR2_SDRAM_MPMC_Clk_Div2\n" +
		" PORT CLKIN = dcm_clk_s\n" +
		" PORT LOCKED = Dcm_all_locked\n" +
		" PORT RST = net_gnd");

	if( _numZbtCtrl == 1 ) {
	    _printStream.println(
		" PORT CLKFBIN = ZBT_CLK_FB_s\n" +
		" PORT CLKFBOUT = ZBT_CLK_OUT_s");
	}

	_printStream.println(
		"END\n");

	_printStream.println(
		"BEGIN proc_sys_reset\n" +
		" PARAMETER INSTANCE = proc_sys_reset_0\n" +
		" PARAMETER HW_VER = 3.00.a\n" +
		" PARAMETER C_EXT_RESET_HIGH = 0\n" +
		" PORT Slowest_sync_clk = sys_clk_s\n" +
		" PORT Dcm_locked = Dcm_all_locked\n" +
		" PORT Ext_Reset_In = sys_rst_s\n" +
		" PORT MB_Reset = mb_reset\n" +
		" PORT Bus_Struct_Reset = sys_bus_reset\n" +
		" PORT Peripheral_Reset = sys_periph_reset\n" +
		"END\n");
// We need a multi-port memory controller to connect MB processors to off-chip memory,
// used also by the interface MB to communicate data with the host

	int numPorts = 1; // The interface MicroBlaze is always connected to the MPMC
    	Iterator i;
        i = x.getPortList().iterator();

        while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port.getMemSize() > 0 ) {
		numPorts++;
	    }
	}

	_printStream.println(
		"BEGIN mpmc\n" +
		" PARAMETER INSTANCE = DDR2_SDRAM\n" +
		" PARAMETER HW_VER = 6.04.a\n" +
		" PARAMETER C_NUM_PORTS = " + numPorts + "\n" +
		" PARAMETER C_MEM_PARTNO = mt4htf3264h-53e\n" +
		" PARAMETER C_NUM_IDELAYCTRL = 3\n" +
		" PARAMETER C_IDELAYCTRL_LOC = IDELAYCTRL_X0Y6-IDELAYCTRL_X0Y2-IDELAYCTRL_X0Y1\n" +
//		" PARAMETER C_MEM_DQS_IO_COL = 0b000000000000000000000000000000000000000000000000000000000000000000000000\n" +
//		" PARAMETER C_MEM_DQ_IO_MS = 0b00000000_01110101_00111101_00001111_00011110_00101110_11000011_11000001_10111100\n" +
		" PARAMETER C_DDR2_DQSN_ENABLE = 1\n" +
		" PARAMETER C_MEM_CE_WIDTH = 2\n" +
		" PARAMETER C_MEM_CS_N_WIDTH = 2\n" +
		" PARAMETER C_MEM_CLK_WIDTH = 2\n" +
		" PARAMETER C_MEM_ODT_WIDTH = 2\n" +
		" PARAMETER C_MEM_ODT_TYPE = 1");

	for( int k=0; k<numPorts; k++ ) {
	    _printStream.println(
		" PARAMETER C_PIM" + k + "_BASETYPE = 2");
	}

	_printStream.println(
		" PARAMETER C_MPMC_CLK0_PERIOD_PS = 8000\n" +
		" PARAMETER C_ALL_PIMS_SHARE_ADDRESSES = 1\n" +
		" PARAMETER C_MPMC_BASEADDR = 0x90000000\n" +
		" PARAMETER C_MPMC_HIGHADDR = 0x9FFFFFFF\n" +

		" BUS_INTERFACE SPLB0 = host_if_mb_plb");

// connect the processors that need off-chip memory

	numPorts = 1;
        String mpmcPorts = "";

        i = x.getPortList().iterator();
        while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port.getMemSize() > 0 ) {
		mpmcPorts += " BUS_INTERFACE SPLB" + numPorts + " = " + port.getLink().getName() + "\n";
		numPorts++;
	    }
	}
	_printStream.print( mpmcPorts );

	_printStream.println(
		" PORT DDR2_ODT = fpga_0_DDR2_SDRAM_DDR2_ODT\n" +
		" PORT DDR2_Addr = fpga_0_DDR2_SDRAM_DDR2_Addr\n" +
		" PORT DDR2_BankAddr = fpga_0_DDR2_SDRAM_DDR2_BankAddr\n" +
		" PORT DDR2_CAS_n = fpga_0_DDR2_SDRAM_DDR2_CAS_n\n" +
		" PORT DDR2_CE = fpga_0_DDR2_SDRAM_DDR2_CE\n" +
		" PORT DDR2_CS_n = fpga_0_DDR2_SDRAM_DDR2_CS_n\n" +
		" PORT DDR2_RAS_n = fpga_0_DDR2_SDRAM_DDR2_RAS_n\n" +
		" PORT DDR2_WE_n = fpga_0_DDR2_SDRAM_DDR2_WE_n\n" +
		" PORT DDR2_Clk = fpga_0_DDR2_SDRAM_DDR2_Clk\n" +
		" PORT DDR2_Clk_n = fpga_0_DDR2_SDRAM_DDR2_Clk_n\n" +
		" PORT DDR2_DM = fpga_0_DDR2_SDRAM_DDR2_DM\n" +
		" PORT DDR2_DQS = fpga_0_DDR2_SDRAM_DDR2_DQS_pin\n" +
		" PORT DDR2_DQS_n = fpga_0_DDR2_SDRAM_DDR2_DQS_n_pin\n" +
		" PORT DDR2_DQ = fpga_0_DDR2_SDRAM_DDR2_DQ_pin\n" +
		" PORT MPMC_Clk0 = sys_clk_s\n" +
		" PORT MPMC_Clk90 = DDR2_SDRAM_mpmc_clk_90_s\n" +
		" PORT MPMC_Clk_200MHz = clk_200mhz_s\n" +
		" PORT MPMC_Clk0_DIV2 = DDR2_SDRAM_MPMC_Clk_Div2\n" +
		" PORT MPMC_Rst = sys_periph_reset\n" +
		"END\n");

    }



    /**
     *  Print a line for the Host interface component in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(ML605 x) {

        if( _isAXICrossbar ) {
            _visit_ML605_AXI( x );
        } else { // PLB platform
            visitML605PLB(x);
        } // end platform: AXI or PLB
    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(ML505 x) {

// Here we currently need to 'print' 1 Microblaze with UART and Iterrupt to PLB, a HOST IP connected to DLMB.
// Also, we need all the FIN controllers connected to the host and MPMC. To the latter we connect the control
// microblaze + the MB processors need to have access to off-chip memory.

// Instantiate the control microblaze and the needed peripheral
	_printStream.println(
		"BEGIN microblaze\n" +
		" PARAMETER INSTANCE = host_if_mb\n" +
		" PARAMETER C_INSTANCE = host_if_mb\n" +
		" PARAMETER HW_VER = 8.20.a\n" +
		" PARAMETER C_FAMILY = virtex5\n" +
		" PARAMETER C_DEBUG_ENABLED = 0\n" +
		" PARAMETER C_INTERCONNECT = 1\n" +
		" BUS_INTERFACE DPLB = host_if_mb_plb\n" +
		" BUS_INTERFACE IPLB = host_if_mb_plb\n" +
		" BUS_INTERFACE DLMB = host_if_mb_dlmb\n" +
		" BUS_INTERFACE ILMB = host_if_mb_ilmb\n" +
		" PORT MB_RESET = mb_reset\n" +
		" PORT CLK = sys_clk_s\n" +
		" PORT Interrupt = Interrupt\n" +
		"END\n");

	_printStream.println(
		"BEGIN plb_v46\n" +
		" PARAMETER INSTANCE = host_if_mb_plb\n" +
		" PARAMETER HW_VER = 1.02.a\n" +
		" PORT PLB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_v10\n" +
		" PARAMETER INSTANCE = host_if_mb_ilmb\n" +
		" PARAMETER HW_VER = 2.00.b\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_v10\n" +
		" PARAMETER INSTANCE = host_if_mb_dlmb\n" +
		" PARAMETER HW_VER = 2.00.b\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		" PORT SYS_Rst = sys_bus_reset\n" +
		"END\n\n" +

		"BEGIN lmb_bram_if_cntlr\n" +
		" PARAMETER INSTANCE = dlmb_cntlr\n" +
		" PARAMETER HW_VER = 3.00.b\n" +
		" PARAMETER C_BASEADDR = 0x00000000\n" +
		" PARAMETER C_HIGHADDR = 0x00001fff\n" +
		" BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
		" BUS_INTERFACE BRAM_PORT = dlmb_port\n" +
		"END\n\n" +

		"BEGIN lmb_bram_if_cntlr\n" +
		" PARAMETER INSTANCE = ilmb_cntlr\n" +
		" PARAMETER HW_VER = 3.00.b\n" +
		" PARAMETER C_BASEADDR = 0x00000000\n" +
		" PARAMETER C_HIGHADDR = 0x00001fff\n" +
		" BUS_INTERFACE SLMB = host_if_mb_ilmb\n" +
		" BUS_INTERFACE BRAM_PORT = ilmb_port\n" +
		"END\n\n" +

		"BEGIN bram_block\n" +
		" PARAMETER INSTANCE = lmb_bram\n" +
		" PARAMETER HW_VER = 1.00.a\n" +
		" BUS_INTERFACE PORTA = ilmb_port\n" +
		" BUS_INTERFACE PORTB = dlmb_port\n" +
		"END\n\n" +

		"BEGIN clock_cycle_counter\n" +
		" PARAMETER INSTANCE = cycle_counter_host_if_mb\n" +
		" PARAMETER HW_VER = 1.00.a\n" +
		" PARAMETER C_BASEADDR = 0xf8000000\n" +
		" PARAMETER C_HIGHADDR = 0xf8000003\n" +
		" BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
		" PORT LMB_Clk = sys_clk_s\n" +
		"END\n\n" +

		"BEGIN xps_uart16550\n" +
		" PARAMETER INSTANCE = RS232_Uart_1\n" +
		" PARAMETER HW_VER = 3.00.a\n" +
		" PARAMETER C_BASEADDR = 0x83e20000\n" +
		" PARAMETER C_HIGHADDR = 0x83e2ffff\n" +
		" BUS_INTERFACE SPLB = host_if_mb_plb\n" +
		" PORT sin = fpga_0_RS232_Uart_1_sin\n" +
		" PORT sout = fpga_0_RS232_Uart_1_sout\n" +
		" PORT IP2INTC_Irpt = RS232_Uart_1_IP2INTC_Irpt\n" +
		"END\n\n" +

		"BEGIN xps_intc\n" +
		" PARAMETER INSTANCE = xps_intc_0\n" +
		" PARAMETER HW_VER = 2.01.a\n" +
		" PARAMETER C_BASEADDR = 0x81800000\n" +
		" PARAMETER C_HIGHADDR = 0x8180ffff\n" +
		" BUS_INTERFACE SPLB = host_if_mb_plb\n" +
		" PORT Irq = Interrupt\n" +
		" PORT Intr = RS232_Uart_1_IP2INTC_Irpt\n" +
		"END\n");


// Instantiate the host controller
	_printStream.println(
        	"BEGIN lmb_host_ctrl\n" +
        	" PARAMETER INSTANCE = lmb_host_interface_ctrl\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER C_BASEADDR = 0x0A000000\n" +
        	" PARAMETER C_HIGHADDR = 0x0A00000f\n" +
        	" PARAMETER C_AB = 8\n" +
        	" PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
        	" BUS_INTERFACE SLMB = host_if_mb_dlmb");

		if( _numHWNode > 0 ) {
		   _printStream.println(
			" BUS_INTERFACE PAR_BUS = PARBUS\n" +
			" PORT RST_OUT = reset_IP");
		}

        _printStream.println(
	   	" PORT ENABLE_MB = net_enable_MBs");

	for (int i = 1; i <= _numMb; i++) {
	       _printStream.println(
	   	" PORT FIN_" + ( i - 1 ) + " = net_fin_signal_P" + i);
	}

	for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
    	      _printStream.println(
		" PORT FIN_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
	}

	_printStream.println(
        	"END\n");

// Instantiate the clock generator and the reset block
	_printStream.println(
		"BEGIN clock_generator\n" +
		" PARAMETER INSTANCE = clock_generator_0\n" +
		" PARAMETER HW_VER = 4.01.a\n" +
		" PARAMETER C_EXT_RESET_HIGH = 1\n" +
		" PARAMETER C_CLKIN_FREQ = 100000000\n" +
		" PARAMETER C_CLKOUT0_FREQ = 125000000\n" +
		" PARAMETER C_CLKOUT0_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT0_PHASE = 0\n" +
		" PARAMETER C_CLKOUT0_GROUP = PLL0\n" +
		" PARAMETER C_CLKOUT1_FREQ = 125000000\n" +
		" PARAMETER C_CLKOUT1_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT1_PHASE = 90\n" +
		" PARAMETER C_CLKOUT1_GROUP = PLL0\n" +
		" PARAMETER C_CLKOUT2_FREQ = 200000000\n" +
		" PARAMETER C_CLKOUT2_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT2_PHASE = 0\n" +
		" PARAMETER C_CLKOUT2_GROUP = NONE\n" +
		" PARAMETER C_CLKOUT3_FREQ = 62500000\n" +
		" PARAMETER C_CLKOUT3_BUF = TRUE\n" +
		" PARAMETER C_CLKOUT3_PHASE = 0\n" +
		" PARAMETER C_CLKOUT3_GROUP = NONE");

	if( _numZbtCtrl == 1 ) {
	    _printStream.println(
		" PARAMETER C_CLKFBIN_FREQ = 125000000\n" +
		" PARAMETER C_CLKFBOUT_FREQ = 125000000\n" +
		" PARAMETER C_CLKFBOUT_BUF = TRUE");
	}

	    _printStream.println(
		" PORT CLKOUT0 = sys_clk_s\n" +
		" PORT CLKOUT1 = DDR2_SDRAM_mpmc_clk_90_s\n" +
		" PORT CLKOUT2 = clk_200mhz_s\n" +
		" PORT CLKOUT3 = DDR2_SDRAM_MPMC_Clk_Div2\n" +
		" PORT CLKIN = dcm_clk_s\n" +
		" PORT LOCKED = Dcm_all_locked\n" +
		" PORT RST = net_gnd");

	if( _numZbtCtrl == 1 ) {
	    _printStream.println(
		" PORT CLKFBIN = ZBT_CLK_FB_s\n" +
		" PORT CLKFBOUT = ZBT_CLK_OUT_s");
	}

	_printStream.println(
		"END\n");

	_printStream.println(
		"BEGIN proc_sys_reset\n" +
		" PARAMETER INSTANCE = proc_sys_reset_0\n" +
		" PARAMETER HW_VER = 3.00.a\n" +
		" PARAMETER C_EXT_RESET_HIGH = 0\n" +
		" PORT Slowest_sync_clk = sys_clk_s\n" +
		" PORT Dcm_locked = Dcm_all_locked\n" +
		" PORT Ext_Reset_In = sys_rst_s\n" +
		" PORT MB_Reset = mb_reset\n" +
		" PORT Bus_Struct_Reset = sys_bus_reset\n" +
		" PORT Peripheral_Reset = sys_periph_reset\n" +
		"END\n");
// We need a multi-port memory controller to connect MB processors to off-chip memory,
// used also by the interface MB to communicate data with the host

	int numPorts = 1; // The interface MicroBlaze is always connected to the MPMC
    	Iterator i;
        i = x.getPortList().iterator();

        while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port.getMemSize() > 0 ) {
		numPorts++;
	    }
	}


	_printStream.println(
		"BEGIN mpmc\n" +
		" PARAMETER INSTANCE = DDR2_SDRAM\n" +
		" PARAMETER HW_VER = 6.03.a\n" +
		" PARAMETER C_NUM_PORTS = " + numPorts + "\n" +
		" PARAMETER C_MEM_PARTNO = mt4htf3264h-53e\n" +
		" PARAMETER C_NUM_IDELAYCTRL = 3\n" +
		" PARAMETER C_IDELAYCTRL_LOC = IDELAYCTRL_X0Y5-IDELAYCTRL_X0Y1-IDELAYCTRL_X0Y0\n" +
		" PARAMETER C_MEM_DQS_IO_COL = 0b00_0000_0000_0000_0000\n" +
		" PARAMETER C_MEM_DQ_IO_MS = 0b00000000_01110101_00111101_00001111_00011110_00101110_11000011_11000001_10111100\n" +
		" PARAMETER C_DDR2_DQSN_ENABLE = 1\n" +
		" PARAMETER C_MEM_CE_WIDTH = 2\n" +
		" PARAMETER C_MEM_CS_N_WIDTH = 2\n" +
		" PARAMETER C_MEM_CLK_WIDTH = 2\n" +
		" PARAMETER C_MEM_ODT_WIDTH = 2\n" +
		" PARAMETER C_MEM_ODT_TYPE = 1");

	for( int k=0; k<numPorts; k++ ) {
	    _printStream.println(
		" PARAMETER C_PIM" + k + "_BASETYPE = 2");
	}

	_printStream.println(
		" PARAMETER C_MPMC_CLK0_PERIOD_PS = 8000\n" +
		" PARAMETER C_ALL_PIMS_SHARE_ADDRESSES = 1\n" +
		" PARAMETER C_MPMC_BASEADDR = 0x90000000\n" +
		" PARAMETER C_MPMC_HIGHADDR = 0x9FFFFFFF\n" +

		" BUS_INTERFACE SPLB0 = host_if_mb_plb");

// connect the processors that need off-chip memory

	numPorts = 1;
        String mpmcPorts = "";

        i = x.getPortList().iterator();
        while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port.getMemSize() > 0 ) {
		mpmcPorts += " BUS_INTERFACE SPLB" + numPorts + " = " + port.getLink().getName() + "\n";
		numPorts++;
	    }
	}
	_printStream.print( mpmcPorts );

	_printStream.println(
		" PORT DDR2_ODT = fpga_0_DDR2_SDRAM_DDR2_ODT\n" +
		" PORT DDR2_Addr = fpga_0_DDR2_SDRAM_DDR2_Addr\n" +
		" PORT DDR2_BankAddr = fpga_0_DDR2_SDRAM_DDR2_BankAddr\n" +
		" PORT DDR2_CAS_n = fpga_0_DDR2_SDRAM_DDR2_CAS_n\n" +
		" PORT DDR2_CE = fpga_0_DDR2_SDRAM_DDR2_CE\n" +
		" PORT DDR2_CS_n = fpga_0_DDR2_SDRAM_DDR2_CS_n\n" +
		" PORT DDR2_RAS_n = fpga_0_DDR2_SDRAM_DDR2_RAS_n\n" +
		" PORT DDR2_WE_n = fpga_0_DDR2_SDRAM_DDR2_WE_n\n" +
		" PORT DDR2_Clk = fpga_0_DDR2_SDRAM_DDR2_Clk\n" +
		" PORT DDR2_Clk_n = fpga_0_DDR2_SDRAM_DDR2_Clk_n\n" +
		" PORT DDR2_DM = fpga_0_DDR2_SDRAM_DDR2_DM\n" +
		" PORT DDR2_DQS = fpga_0_DDR2_SDRAM_DDR2_DQS\n" +
		" PORT DDR2_DQS_n = fpga_0_DDR2_SDRAM_DDR2_DQS_n\n" +
		" PORT DDR2_DQ = fpga_0_DDR2_SDRAM_DDR2_DQ\n" +
		" PORT MPMC_Clk0 = sys_clk_s\n" +
		" PORT MPMC_Clk90 = DDR2_SDRAM_mpmc_clk_90_s\n" +
		" PORT MPMC_Clk_200MHz = clk_200mhz_s\n" +
		" PORT MPMC_Clk0_DIV2 = DDR2_SDRAM_MPMC_Clk_Div2\n" +
		" PORT MPMC_Rst = sys_periph_reset\n" +
		"END\n");
    }

    /**
     *  Print a line for the process in the correct format for MHS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(ADMXRCII x) {
/*
	_printStream.println(
        	"BEGIN zbt_main\n" +
        	" PARAMETER INSTANCE = host_zbt_main\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" BUS_INTERFACE HOST_BUFF_0_PORT = buff_rd_0\n" +
        	" BUS_INTERFACE HOST_BUFF_1_PORT = buff_rd_1\n" +
        	" BUS_INTERFACE HOST_BUFF_2_PORT = buff_rd_2\n" +
        	" BUS_INTERFACE HOST_BUFF_3_PORT = buff_rd_3\n" +
        	" BUS_INTERFACE HOST_BUFF_4_PORT = buff_rd_4\n" +
        	" BUS_INTERFACE HOST_BUFF_5_PORT = buff_rd_5\n" +
        	" BUS_INTERFACE HOST_MUX_PORT = mux_to_host\n" +
        	" PORT lclk = lclk\n" +
        	" PORT mclk = mclk\n" +
        	" PORT ramclko = ramclko\n" +
        	" PORT ramclki = ramclki\n" +
        	" PORT lreseto_l = lreseto_l\n" +
        	" PORT lwrite = lwrite\n" +
        	" PORT lads_l = lads_l\n" +
        	" PORT lblast_l = lblast_l\n" +
        	" PORT lbterm_l = lbterm_l\n" +
        	" PORT ld = ld\n" +
        	" PORT la = la\n" +
        	" PORT lreadyi_l = lreadyi_l\n" +
        	" PORT lbe_l = lbe_l\n" +
        	" PORT fholda = fholda\n" +
        	" PORT CLK_out = sys_clk_s\n" +
        	" PORT RST_out = sys_rst_s\n" +
        	" PORT COMMAND_REG = net_command\n" +
        	" PORT DESIGN_STAT_REG = net_design_status\n" +
        	" PORT PARAMETER_REG = net_parameter\n" +
        	"END\n");

	_printStream.println(
        	"BEGIN host_design_ctrl\n" +
        	" PARAMETER INSTANCE = host_design_controller\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
        	" PARAMETER PAR_WIDTH  = 16" + "\n" +
        	" PORT RST = sys_rst_s\n" +
        	" PORT COMMAND_REG = net_command\n" +
        	" PORT STATUS_REG = net_design_status\n" +
        	" PORT PARAMETER_REG = net_parameter\n" +
        	" PORT RST_OUT = net_design_rst");

	for (int i = 1; i <= _numMb; i++) {
	    _printStream.println(
		" PORT FIN_REG_" + ( i - 1 ) + " = net_fin_signal_P" + i);
	}

	for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
    	    _printStream.println(
		" PORT FIN_REG_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
	}

	if(_numHWNode > 0){
    	    _printStream.println(" BUS_INTERFACE PAR_BUS = PARBUS");
	}

	_printStream.println(
        	"END\n");

	_printStream.println(
        	"BEGIN mux\n" +
        	" PARAMETER INSTANCE = multiplexer\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER N_MUX = " + _numZbtCtrl + "\n" +
        	" BUS_INTERFACE MUX_BUFF_PORT = buff_to_mux");

	for (int i = 0; i < _numZbtCtrl; i++) {
    	   _printStream.println(
		" BUS_INTERFACE MUX_DESIGN_" + i + "_PORT = mux_design_" + i);
	}

	_printStream.println(
        	" BUS_INTERFACE MUX_HOST_PORT = mux_to_host\n" +
        	" PORT ra0 = ra0\n" +
        	" PORT ra1 = ra1\n" +
        	" PORT ra2 = ra2\n" +
        	" PORT ra3 = ra3\n" +
        	" PORT ra4 = ra4\n" +
        	" PORT ra5 = ra5\n" +
        	" PORT rc0 = rc0\n" +
        	" PORT rc1 = rc1\n" +
        	" PORT rc2 = rc2\n" +
        	" PORT rc3 = rc3\n" +
        	" PORT rc4 = rc4\n" +
        	" PORT rc5 = rc5\n" +
        	" PORT RST = sys_rst_s\n" +
        	" PORT CNTRL = net_command\n" +
        	"END\n");

	_printStream.println(
		"BEGIN buffers\n" +
        	" PARAMETER INSTANCE = buff\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" BUS_INTERFACE BUFF_MUX_PORT = buff_to_mux\n" +
        	" BUS_INTERFACE BUFF_RD_0_PORT = buff_rd_0\n" +
        	" BUS_INTERFACE BUFF_RD_1_PORT = buff_rd_1\n" +
        	" BUS_INTERFACE BUFF_RD_2_PORT = buff_rd_2\n" +
        	" BUS_INTERFACE BUFF_RD_3_PORT = buff_rd_3\n" +
        	" BUS_INTERFACE BUFF_RD_4_PORT = buff_rd_4\n" +
        	" BUS_INTERFACE BUFF_RD_5_PORT = buff_rd_5\n" +
        	" PORT rd0 = rd0\n" +
        	" PORT rd1 = rd1\n" +
        	" PORT rd2 = rd2\n" +
        	" PORT rd3 = rd3\n" +
        	" PORT rd4 = rd4\n" +
        	" PORT rd5 = rd5\n" +
        	"END\n");
*/
   }



/*---------------------------------------- Peripherals --------------------------------------------------------------*/
    /**
     *  Print a line for the ZBTMemoryController in the correct format for MHS.
     *
     * @param  x The ZBTMemoryController that needs to be rendered.
     */
    public void visitComponent(ZBTMemoryController x) {
       if( _targetBoard.equals("ADM-XRC-II") ) {
// This should be moved to the ADMXRCII host interface component
          if( _zbtInterfaceFlag == 0 ) {
	    _printStream.println(
        	"BEGIN zbt_main\n" +
        	" PARAMETER INSTANCE = host_zbt_main\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" BUS_INTERFACE HOST_BUFF_0_PORT = buff_rd_0\n" +
        	" BUS_INTERFACE HOST_BUFF_1_PORT = buff_rd_1\n" +
        	" BUS_INTERFACE HOST_BUFF_2_PORT = buff_rd_2\n" +
        	" BUS_INTERFACE HOST_BUFF_3_PORT = buff_rd_3\n" +
        	" BUS_INTERFACE HOST_BUFF_4_PORT = buff_rd_4\n" +
        	" BUS_INTERFACE HOST_BUFF_5_PORT = buff_rd_5\n" +
        	" BUS_INTERFACE HOST_MUX_PORT = mux_to_host\n" +
        	" PORT lclk = lclk\n" +
        	" PORT mclk = mclk\n" +
        	" PORT ramclko = ramclko\n" +
        	" PORT ramclki = ramclki\n" +
        	" PORT lreseto_l = lreseto_l\n" +
        	" PORT lwrite = lwrite\n" +
        	" PORT lads_l = lads_l\n" +
        	" PORT lblast_l = lblast_l\n" +
        	" PORT lbterm_l = lbterm_l\n" +
        	" PORT ld = ld\n" +
        	" PORT la = la\n" +
        	" PORT lreadyi_l = lreadyi_l\n" +
        	" PORT lbe_l = lbe_l\n" +
        	" PORT fholda = fholda\n" +
        	" PORT CLK_out = sys_clk_s\n" +
        	" PORT RST_out = sys_rst_s\n" +
        	" PORT COMMAND_REG = net_command\n" +
        	" PORT DESIGN_STAT_REG = net_design_status\n" +
        	" PORT PARAMETER_REG = net_parameter\n" +
        	"END\n");

	    _printStream.println(
        	"BEGIN host_design_ctrl\n" +
        	" PARAMETER INSTANCE = host_design_controller\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
        	" PARAMETER PAR_WIDTH  = 16" + "\n" +
        	" PORT RST = sys_rst_s\n" +
        	" PORT COMMAND_REG = net_command\n" +
        	" PORT STATUS_REG = net_design_status\n" +
        	" PORT PARAMETER_REG = net_parameter\n" +
        	" PORT RST_OUT = net_design_rst");

	    for (int i = 1; i <= _numMb; i++) {
	       _printStream.println(
	   	" PORT FIN_REG_" + ( i - 1 ) + " = net_fin_signal_P" + i);
	    }

	    for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
    	      _printStream.println(
		" PORT FIN_REG_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
	    }

	    if(_numHWNode > 0){
    	      _printStream.println(" BUS_INTERFACE PAR_BUS = PARBUS");
	    }

	    _printStream.println(
        	"END\n");

	    _printStream.println(
        	"BEGIN mux\n" +
        	" PARAMETER INSTANCE = multiplexer\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" PARAMETER N_MUX = " + _numZbtCtrl + "\n" +
        	" BUS_INTERFACE MUX_BUFF_PORT = buff_to_mux");

	    for (int i = 0; i < _numZbtCtrl; i++) {
    	      _printStream.println(
		" BUS_INTERFACE MUX_DESIGN_" + i + "_PORT = mux_design_" + i);
	    }

	    _printStream.println(
        	" BUS_INTERFACE MUX_HOST_PORT = mux_to_host\n" +
        	" PORT ra0 = ra0\n" +
        	" PORT ra1 = ra1\n" +
        	" PORT ra2 = ra2\n" +
        	" PORT ra3 = ra3\n" +
        	" PORT ra4 = ra4\n" +
        	" PORT ra5 = ra5\n" +
        	" PORT rc0 = rc0\n" +
        	" PORT rc1 = rc1\n" +
        	" PORT rc2 = rc2\n" +
        	" PORT rc3 = rc3\n" +
        	" PORT rc4 = rc4\n" +
        	" PORT rc5 = rc5\n" +
        	" PORT RST = sys_rst_s\n" +
        	" PORT CNTRL = net_command\n" +
        	"END\n");

	    _printStream.println(
		"BEGIN buffers\n" +
        	" PARAMETER INSTANCE = buff\n" +
        	" PARAMETER HW_VER = 1.00.a\n" +
        	" BUS_INTERFACE BUFF_MUX_PORT = buff_to_mux\n" +
        	" BUS_INTERFACE BUFF_RD_0_PORT = buff_rd_0\n" +
        	" BUS_INTERFACE BUFF_RD_1_PORT = buff_rd_1\n" +
        	" BUS_INTERFACE BUFF_RD_2_PORT = buff_rd_2\n" +
        	" BUS_INTERFACE BUFF_RD_3_PORT = buff_rd_3\n" +
        	" BUS_INTERFACE BUFF_RD_4_PORT = buff_rd_4\n" +
        	" BUS_INTERFACE BUFF_RD_5_PORT = buff_rd_5\n" +
        	" PORT rd0 = rd0\n" +
        	" PORT rd1 = rd1\n" +
        	" PORT rd2 = rd2\n" +
        	" PORT rd3 = rd3\n" +
        	" PORT rd4 = rd4\n" +
        	" PORT rd5 = rd5\n" +
        	"END\n");
	  }
          _zbtInterfaceFlag++;
//====================================================================

    	  Iterator i;
          i = x.getPortList().iterator();

          String opbLinkName = "";

          while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port instanceof OPBPort ) {
                opbLinkName = port.getLink().getName();
            	_printStream.println(
            			"BEGIN opb_zbt_controller\n" +
            			" PARAMETER INSTANCE = " + x.getName() + "\n" +
            			" PARAMETER HW_VER = 1.00.a\n" +
            			" PARAMETER C_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
				" PARAMETER C_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + _greaterPowerOfTwo(x.getSize()) - 1, 8) + "\n" +
            			" PARAMETER C_EXTERNAL_DLL = 1\n" +
            			" PARAMETER C_ZBT_ADDR_SIZE = 20\n" +
            			" BUS_INTERFACE SOPB = " + opbLinkName + "\n" +
            			" BUS_INTERFACE DESIGN_BUFF_PORT = buff_rd_" + _numZbtCtrlVisit + "\n" +
            			" BUS_INTERFACE DESIGN_MUX_PORT = mux_design_" + _numZbtCtrlVisit + "\n" +
            			"END\n");
             }
          }

          _numZbtCtrlVisit++;

       } else if( _targetBoard.equals("XUPV5-LX110T") || _targetBoard.equals("ML505") ) {

          String plbLinkName = "";
	  String version = "";

	  if( _targetBoard.equals("XUPV5-LX110T") ) {
		version = "3.00.a";
	  } else if( _targetBoard.equals("ML505") ) {
                version = "1.00.1\n PARAMETER C_MCH_PLB_CLK_PERIOD_PS = 8000";
	  }

    	  Iterator i;
          i = x.getPortList().iterator();
          while (i.hasNext()) {
            Port port = (Port) i.next();
            if ( port instanceof PLBPort ) {
                plbLinkName = port.getLink().getName();
            	_printStream.println(
            			"BEGIN xps_mch_emc\n" +
            			" PARAMETER INSTANCE = SRAM\n" +
            			" PARAMETER HW_VER = " + version + "\n" +
//            			" PARAMETER HW_VER = 3.00.a\n" +
////            			" PARAMETER C_MCH_PLB_CLK_PERIOD_PS = 8000\n" +
            			" PARAMETER C_NUM_BANKS_MEM = 1\n" +
            			" PARAMETER C_MAX_MEM_WIDTH = 32\n" +
            			" PARAMETER C_MEM0_WIDTH = 32\n" +
            			" PARAMETER C_INCLUDE_DATAWIDTH_MATCHING_0 = 0\n" +
            			" PARAMETER C_SYNCH_MEM_0 = 1\n" +
            			" PARAMETER C_TCEDV_PS_MEM_0 = 0\n" +
            			" PARAMETER C_TWC_PS_MEM_0 = 0\n" +
            			" PARAMETER C_TAVDV_PS_MEM_0 = 0\n" +
            			" PARAMETER C_TWP_PS_MEM_0 = 0\n" +
            			" PARAMETER C_THZCE_PS_MEM_0 = 0\n" +
            			" PARAMETER C_THZOE_PS_MEM_0 = 0\n" +
            			" PARAMETER C_TLZWE_PS_MEM_0 = 0\n" +
            			" PARAMETER C_MEM0_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
				" PARAMETER C_MEM0_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + _greaterPowerOfTwo(x.getSize()) - 1, 8) + "\n" +
            			" PARAMETER C_NUM_CHANNELS = 0\n" +
            			" BUS_INTERFACE SPLB = " + plbLinkName + "\n" +
            			" PORT Mem_A = fpga_0_SRAM_Mem_A_split\n" +
            			" PORT Mem_BEN = fpga_0_SRAM_Mem_BEN\n" +
            			" PORT Mem_WEN = fpga_0_SRAM_Mem_WEN\n" +
            			" PORT Mem_OEN = fpga_0_SRAM_Mem_OEN\n" +
            			" PORT Mem_DQ = fpga_0_SRAM_Mem_DQ\n" +
            			" PORT Mem_CEN = fpga_0_SRAM_Mem_CEN\n" +
            			" PORT Mem_ADV_LDN = fpga_0_SRAM_Mem_ADV_LDN\n" +
            			" PORT RdClk = sys_clk_s\n" +
            			"END\n\n" +

            			"BEGIN util_bus_split\n" +
            			" PARAMETER INSTANCE = SRAM_util_bus_split_1\n" +
            			" PARAMETER HW_VER = 1.00.a\n" +
            			" PARAMETER C_SIZE_IN = 32\n" +
            			" PARAMETER C_LEFT_POS = 7\n" +
            			" PARAMETER C_SPLIT = 31\n" +
            			" PORT Sig = fpga_0_SRAM_Mem_A_split\n" +
            			" PORT Out1 = fpga_0_SRAM_Mem_A\n" +
            			"END\n");
             }
          }
       }
    }


    /**
     *  Print a line for the Uart in the correct format for MHS.
     *
     * @param  x The Uart that needs to be rendered.
     */
    public void visitComponent(Uart x) {

       if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ADM-XPL") ) {
    	  Iterator i;
          i = x.getPortList().iterator();

          String opbLinkName = "";

          while (i.hasNext()) {
             Port port = (Port) i.next();
             if ( port instanceof OPBPort ) {
                opbLinkName = port.getLink().getName();
            	_printStream.println(
            			"BEGIN opb_uartlite\n" +
            			" PARAMETER INSTANCE = " + x.getName() + "\n" +
            			" PARAMETER HW_VER = 1.00.b\n" +
            			" PARAMETER C_BASEADDR = 0x" + _digitToStringHex(x.getBaseAddress(), 8) + "\n" +
				" PARAMETER C_HIGHADDR = 0x" + _digitToStringHex(x.getBaseAddress() + _greaterPowerOfTwo(x.getSize()) - 1, 8) + "\n" +
            			" PARAMETER C_CLK_FREQ = 100000000\n" +
            			" PARAMETER C_DATA_BITS = 8\n" +
            			" PARAMETER C_BAUDRATE = 9600\n" +
            			" PARAMETER C_ODD_PARITY = 0\n" +
            			" PARAMETER C_USE_PARITY = 0\n" +
            			" BUS_INTERFACE SOPB = " + opbLinkName + "\n" +
            			" PORT RX = RS232_Uart_" + _numUartVisit + "_RX\n" +
            			" PORT TX = RS232_Uart_" + _numUartVisit + "_TX\n" +
            			" PORT OPB_Clk = sys_clk_s\n" +
            			"END\n");
             }
          }

          _numUartVisit++;
       } else if( _targetBoard.equals("ADM-XRC-II") || _targetBoard.equals("ML505") ) {
       // The UART is used by the host interface microblaze for communication with a host PC
       }
    }

    ///////////////////////////////////////////////////////////////////
    ////                         private methods                    ///

    /**
     *  convert to hexical string
     *  @param xLong long value to be changed
     *  @param format length of the digit format
     */
    private String _digitToStringHex(int xInt, int format) {
        String binStr = Integer.toHexString(xInt);
        int binStrlength = binStr.length();
        if (format < binStrlength) {
            System.out.println(
                "Error!!!!: The value can not be represented as " + format + " digit hex");
        }
        String returnStr = new String();
        for (int i = 0; i < (format - binStrlength); i++) {
            returnStr = returnStr + '0';
        }
        returnStr = returnStr + binStr;
        return returnStr;
    }

    /**
     *  convert integer value to nearest power of 2 number greater than this value
     *  @param xInt integer value to be convert
     *  @return  the nearest power of 2 number greater than xInt
     */
    private int _greaterPowerOfTwo(int xInt) {
        int i = 0;
    	while ( Math.pow( 2.0, (double)i ) < xInt ) {
        	i++;
        }
    	return (int)Math.pow( 2.0, (double)i );
    }

    private int _log2(int xInt) {
        int i = 0;
    	while ( Math.pow( 2.0, (double)i ) < xInt ) {
        	i++;
        }
    	return i;
    }

    /**
     *  Description of the Method
     *
     * @param  fileName Description of the Parameter
     * @param  extension Description of the Parameter
     * @return  Description of the Return Value
     * @exception  FileNotFoundException Description of the Exception
     */
    private static PrintStream _openFile( String fileName, String extension )
            throws FileNotFoundException {

        PrintStream printStream = null;
        UserInterface ui = UserInterface.getInstance();
        String fullFileName = "";

	// Create the directory indicated by the '-o' option. Otherwise
        // select the orignal filename. (REFACTOR)
        if( ui.getOutputFileName() == "" ) {
            fullFileName =
                ui.getBasePath() + File.separatorChar +
                ui.getFileName() + File.separatorChar + fileName + "." + extension;
        } else {
            fullFileName =
                ui.getBasePath() + File.separatorChar +
                ui.getOutputFileName() + File.separatorChar + fileName + "." + extension;
        }

        System.out.println(" -- OPEN FILE: " + fullFileName);

        if( fileName.equals("") ) {
            printStream = new PrintStream( System.out );
        } else {
            OutputStream file = null;

            file = new FileOutputStream( fullFileName );
            printStream = new PrintStream( file );
        }

        return printStream;
    }


    /**
     *  Get the target FPGA board
     *  @param platform
     */
    private String _getBoard( Platform x ) {

	String board = "";
        Iterator j = x.getResourceList().iterator();
    	while (j.hasNext()) {
            Resource resource = (Resource)j.next();
            if( resource instanceof ADMXRCII ) {
               board = "ADM-XRC-II";
               _commInterface = ((ADMXRCII)resource).getCommInterface();
            } else if( resource instanceof ADMXPL ) {
               board = "ADM-XPL";
               _commInterface = ((ADMXPL)resource).getCommInterface();
            } else if( resource instanceof XUPV5LX110T ) {
               board = "XUPV5-LX110T";
               _commInterface = ((XUPV5LX110T)resource).getCommInterface();
            } else if( resource instanceof ML505 ) {
               board = "ML505";
               _commInterface = ((ML505)resource).getCommInterface();
            } else if( resource instanceof ML605 ) {
               board = "ML605";
               _commInterface = ((ML605)resource).getCommInterface();
            } else if( resource instanceof AXICrossbar ) {
               _isAXICrossbar = true;
            }
        }

	return board;
    }

    /**
     *  Generates the host interface subsystem using an AXI BUS
     *  @param host_interface
     */    
    private void _visit_ML605_AXI( ML605 x ) {


	_printStream.println(
	      "BEGIN microblaze\n" +
	      " PARAMETER INSTANCE = host_if_mb\n" +
	      " PARAMETER HW_VER = 8.20.a\n" +
	      " PARAMETER C_INTERCONNECT = 2\n" +
	      " PARAMETER C_INTERCONNECT_M_AXI_DC_AW_REGISTER = 0\n" +
	      " PARAMETER C_INTERCONNECT_M_AXI_DC_W_REGISTER = 0\n" +
	      " BUS_INTERFACE M_AXI_DP = host_if_mb_axi4lite_DP\n" +
// 	      " BUS_INTERFACE M_AXI_DC = DDR3_axi4_DC\n" +
	      " BUS_INTERFACE DLMB = host_if_mb_dlmb\n" +
	      " BUS_INTERFACE ILMB = host_if_mb_ilmb\n" +
	      " PORT MB_RESET = mb_reset\n" +
	      " PORT CLK = sys_clk_100_MHz\n" +  // sys_cls_s
	      " PORT Interrupt = host_if_mb_timer_int\n" +
	      "END\n\n" +

	      "BEGIN lmb_v10\n" +
	      " PARAMETER INSTANCE = host_if_mb_ilmb\n" +
	      " PARAMETER HW_VER = 2.00.b\n" +
	      " PORT SYS_RST = sys_bus_reset\n" +
	      " PORT LMB_CLK = sys_clk_100_MHz\n" +
	      "END\n\n" +

	      "BEGIN lmb_v10\n" +
	      " PARAMETER INSTANCE = host_if_mb_dlmb\n" +
	      " PARAMETER HW_VER = 2.00.b\n" +
	      " PORT SYS_RST = sys_bus_reset\n" +
	      " PORT LMB_CLK = sys_clk_100_MHz\n" +
	      "END\n\n" +

	      "BEGIN lmb_bram_if_cntlr\n" +
	      " PARAMETER INSTANCE = host_if_mb_ilmb_ctrl_bram_0\n" +
	      " PARAMETER HW_VER = 3.00.b\n" +
	      " PARAMETER C_BASEADDR = 0x00000000\n" +
	      " PARAMETER C_HIGHADDR = 0x00003FFF\n" +
	      " BUS_INTERFACE SLMB = host_if_mb_ilmb\n" +
	      " BUS_INTERFACE BRAM_PORT = host_if_mb_ilmb_ctrl_bram_PORT\n" +
	      "END\n\n" +

	      "BEGIN lmb_bram_if_cntlr\n" +
	      " PARAMETER INSTANCE = host_if_mb_dlmb_ctrl_bram_0\n" +
	      " PARAMETER HW_VER = 3.00.b\n" +
	      " PARAMETER C_BASEADDR = 0x00000000\n" +
	      " PARAMETER C_HIGHADDR = 0x00003FFF\n" +
	      " BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
	      " BUS_INTERFACE BRAM_PORT = host_if_mb_dlmb_ctrl_bram_PORT\n" +
	      "END\n\n" +

	      "BEGIN bram_block\n" +
	      " PARAMETER INSTANCE = host_if_mb_bram_0\n" +
	      " PARAMETER HW_VER = 1.00.a\n" +
	      " BUS_INTERFACE PORTA = host_if_mb_ilmb_ctrl_bram_PORT\n" +
	      " BUS_INTERFACE PORTB = host_if_mb_dlmb_ctrl_bram_PORT\n" +
	      "END\n\n" +
/*
"BEGIN clock_cycle_counter
" PARAMETER INSTANCE = clock_cycle_counter_host_if_mb
" PARAMETER HW_VER = 1.00.a
" PARAMETER C_BASEADDR = 0xB0000000
" PARAMETER C_HIGHADDR = 0xB0000003
" BUS_INTERFACE SLMB = host_if_mb_dlmb
" PORT LMB_Clk = sys_clk_100_MHz
"END
*/
	      "BEGIN axi_interconnect\n" +
	      " PARAMETER INSTANCE = host_if_mb_axi4lite_DP\n" +
	      " PARAMETER HW_VER = 1.03.a\n" +
	      " PARAMETER C_INTERCONNECT_CONNECTIVITY_MODE = 0\n" +
	      " PORT INTERCONNECT_ARESETN = sys_Interconnect_aresetn\n" +
	      " PORT INTERCONNECT_ACLK = sys_clk_100_MHz\n" +
	      "END\n\n" +

	      "BEGIN axi_timer\n" +
	      " PARAMETER INSTANCE = host_if_mb_timer\n" +
	      " PARAMETER HW_VER = 1.02.a\n" +
	      " PARAMETER C_BASEADDR = 0x40000000\n" +
	      " PARAMETER C_HIGHADDR = 0x4000FFFF\n" +
	      " BUS_INTERFACE S_AXI = host_if_mb_axi4lite_DP\n" +
	      " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
	      " PORT Interrupt = host_if_mb_timer_int\n" +
	      "END\n\n" +

	      "BEGIN axi_uartlite\n" +
	      " PARAMETER INSTANCE = host_if_mb_RS232_Uart\n" +
	      " PARAMETER HW_VER = 1.02.a\n" +
	      " PARAMETER C_BAUDRATE = 115200\n" +
	      " PARAMETER C_DATA_BITS = 8\n" +
	      " PARAMETER C_USE_PARITY = 0\n" +
	      " PARAMETER C_ODD_PARITY = 1\n" +
	      " PARAMETER C_BASEADDR = 0xB1000000\n" +
	      " PARAMETER C_HIGHADDR = 0xB100FFFF\n" +
	      " BUS_INTERFACE S_AXI = DDR_axi\n" +
	      " PORT TX = fpga_0_RS232_Uart_1_TX_pin\n" +
	      " PORT RX = fpga_0_RS232_Uart_1_RX_pin\n" +
	      " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
	      "END\n\n" +

	      "BEGIN axi_iic\n" +
	      " PARAMETER INSTANCE = host_if_mb_axi_iic_0\n" +
	      " PARAMETER HW_VER = 1.01.a\n" +
	      " PARAMETER C_BASEADDR = 0x60000000\n" +
	      " PARAMETER C_HIGHADDR = 0x6000FFFF\n" +
	      " BUS_INTERFACE S_AXI = host_if_mb_axi4lite_DP\n" +
	      " PORT S_AXI_ACLK = sys_clk_100_MHz\n" +
	      " PORT Sda = axi_iic_0_Sda\n" +
	      " PORT Scl = axi_iic_0_Scl\n" +
	      "END\n");

// Instantiate the host controller
	_printStream.println(
	      "BEGIN lmb_host_ctrl\n" +
	      " PARAMETER INSTANCE = lmb_host_interface_ctrl\n" +
	      " PARAMETER HW_VER = 1.00.a\n" +
	      " PARAMETER C_BASEADDR = 0x0A000000\n" +
	      " PARAMETER C_HIGHADDR = 0x0A00000f\n" +
	      " PARAMETER C_AB = 8\n" +
	      " PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
	      " BUS_INTERFACE SLMB = host_if_mb_dlmb");

	      if( _numHWNode > 0 ) {
		  _printStream.println(
			" BUS_INTERFACE PAR_BUS = PARBUS\n" +
			" PORT RST_OUT = reset_IP");
	      }

        _printStream.println(
	      " PORT ENABLE_MB = net_enable_MBs");

	for (int i = 1; i <= _numMb; i++) {
	      _printStream.println(
		  " PORT FIN_" + ( i - 1 ) + " = net_fin_signal_P" + i);
	}

	for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
    	      _printStream.println(
		  " PORT FIN_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
	}
	_printStream.println("END\n");

//------------------------------------
// DDR3
//------------------------------------
/*
        String pName = "";
        String strAXI = " PARAMETER C_INTERCONNECT_S_AXI_MASTERS = MB_Master.M_AXI_DC";

        Platform platform = (Platform) x.getLevelUpResource();
        Iterator i = platform.getResourceList().iterator();
        while( i.hasNext() ) {
            Resource res = (Resource) i.next();
            if( res instanceof MicroBlaze ) {  
                 pName = res.getName();
                 strAXI += " & " + pName + ".M_AXI_DC";
            }
        } 
*/
	_printStream.println(
	      "BEGIN axi_v6_ddrx\n" +
	      " PARAMETER INSTANCE = DDR3_SDRAM\n" +
	      " PARAMETER HW_VER = 1.03.a\n" +
	      " PARAMETER C_MEM_PARTNO = MT4JSF6464HY-1G1\n" +
	      " PARAMETER C_INTERCONNECT_S_AXI_AR_REGISTER = 1\n" +
	      " PARAMETER C_INTERCONNECT_S_AXI_AW_REGISTER = 1\n" +
	      " PARAMETER C_INTERCONNECT_S_AXI_R_REGISTER = 1\n" +
	      " PARAMETER C_INTERCONNECT_S_AXI_W_REGISTER = 1\n" +
	      " PARAMETER C_INTERCONNECT_S_AXI_B_REGISTER = 1\n" +
	      " PARAMETER C_DM_WIDTH = 8\n" +
	      " PARAMETER C_DQS_WIDTH = 8\n" +
	      " PARAMETER C_DQ_WIDTH = 64\n" +
	      " PARAMETER C_MMCM_EXT_LOC = MMCM_ADV_X0Y8\n" +
// 	      strAXI + "\n" +
	      " PARAMETER C_S_AXI_BASEADDR = 0xA0000000\n" +
	      " PARAMETER C_S_AXI_HIGHADDR = 0xAfffffff\n" +
	      " BUS_INTERFACE S_AXI = DDR_axi\n" +
	      " PORT ddr_ck_p = ddr_memory_clk\n" +
	      " PORT ddr_ck_n = ddr_memory_clk_n\n" +
	      " PORT ddr_cke = ddr_memory_cke\n" +
	      " PORT ddr_cs_n = ddr_memory_cs_n\n" +
	      " PORT ddr_odt = ddr_memory_odt\n" +
	      " PORT ddr_ras_n = ddr_memory_ras_n\n" +
	      " PORT ddr_cas_n = ddr_memory_cas_n\n" +
	      " PORT ddr_we_n = ddr_memory_we_n\n" +
	      " PORT ddr_dm = ddr_memory_dm\n" +
	      " PORT ddr_ba = ddr_memory_ba\n" +
	      " PORT ddr_addr = ddr_memory_addr\n" +
	      " PORT ddr_reset_n = ddr_memory_ddr3_rst\n" +
	      " PORT ddr_dq = fpga_0_DDR3_SDRAM_DDR3_DQ_pin\n" +
	      " PORT ddr_dqs_p = fpga_0_DDR3_SDRAM_DDR3_DQS_pin\n" +
	      " PORT ddr_dqs_n = fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin\n" +
	      " PORT clk = sys_clk_200_MHz\n" +
	      " PORT clk_ref = sys_clk_200_MHz\n" +
	      " PORT clk_mem = sys_clk_400_MHz\n" +
	      " PORT clk_rd_base = sys_clk_400_MHz_nobuf_varphase\n" +
	      " PORT PD_PSEN = psen\n" +
	      " PORT PD_PSINCDEC = psincdec\n" +
	      " PORT PD_PSDONE = psdone\n" +
	      "END\n\n" +

	      "BEGIN axi_interconnect\n" +
	      " PARAMETER INSTANCE = DDR_axi\n" +
	      " PARAMETER HW_VER = 1.03.a\n" +
	      " PARAMETER C_INTERCONNECT_CONNECTIVITY_MODE = 0\n" +
	      " PORT INTERCONNECT_ARESETN = sys_Interconnect_aresetn\n" +
	      " PORT INTERCONNECT_ACLK = sys_clk_100_MHz\n" +
	      "END\n\n" +

	      "BEGIN axi2axi_connector\n" +
	      " PARAMETER INSTANCE = host_if_mb_ddr_axi2axi_connector\n" +
	      " PARAMETER HW_VER = 1.00.a\n" +
	      " PARAMETER C_S_AXI_NUM_ADDR_RANGES = 1\n" +
	      " PARAMETER C_S_AXI_RNG00_BASEADDR = 0xA0000000\n" +
	      " PARAMETER C_S_AXI_RNG00_HIGHADDR = 0xBFFFFFFF\n" +
	      " PARAMETER C_S_AXI_PROTOCOL = AXI4LITE\n" +
	      " BUS_INTERFACE S_AXI = host_if_mb_axi4lite_DP\n" +
	      " BUS_INTERFACE M_AXI = DDR_axi\n" +
	      "END\n");

        Platform platform = (Platform) x.getLevelUpResource();
        Iterator i = platform.getResourceList().iterator();
        while( i.hasNext() ) {
            Resource res = (Resource) i.next();
            if( res instanceof MicroBlaze ) {  
                 String pName = res.getName();
                 _printStream.println(
			"BEGIN axi2axi_connector\n" +
			" PARAMETER INSTANCE = " + pName + "_ddr_axi2axi_connector\n" +
			" PARAMETER HW_VER = 1.00.a\n" +
			" PARAMETER C_S_AXI_NUM_ADDR_RANGES = 1\n" +
			" PARAMETER C_S_AXI_RNG00_BASEADDR = 0xA0000000\n" +
			" PARAMETER C_S_AXI_RNG00_HIGHADDR = 0xBFFFFFFF\n" +
			" PARAMETER C_S_AXI_PROTOCOL = AXI4LITE\n" +
			" BUS_INTERFACE S_AXI = " + pName + "_axi4lite_DP\n" +
			" BUS_INTERFACE M_AXI = DDR_axi\n" +
			"END\n");
            }
        } 


//----------------------------
// CLK & RST
//----------------------------

	_printStream.println(
	      "BEGIN clock_generator\n" +
	      " PARAMETER INSTANCE = sys_clock_generator\n" +
	      " PARAMETER HW_VER = 4.02.a\n" +
	      " PARAMETER C_CLKIN_FREQ = 200000000\n" +
	      " PARAMETER C_CLKOUT0_FREQ = 100000000\n" +
	      " PARAMETER C_CLKOUT0_GROUP = MMCM0\n" +
	      " PARAMETER C_CLKOUT1_FREQ = 200000000\n" +
	      " PARAMETER C_CLKOUT1_GROUP = MMCM0\n" +
	      " PARAMETER C_CLKOUT2_FREQ = 400000000\n" +
	      " PARAMETER C_CLKOUT2_GROUP = MMCM0\n" +
	      " PARAMETER C_CLKOUT3_FREQ = 400000000\n" +
	      " PARAMETER C_CLKOUT3_GROUP = MMCM0\n" +
	      " PARAMETER C_CLKOUT3_BUF = FALSE\n" +
	      " PARAMETER C_CLKOUT3_VARIABLE_PHASE = TRUE\n" +
	      " PARAMETER C_CLKOUT4_FREQ = 50000000\n" +
	      " PARAMETER C_CLKOUT4_GROUP = MMCM0\n" +
	      " PORT RST = sys_rst_s\n" +
	      " PORT CLKIN = CLK_S\n" +
	      " PORT CLKOUT0 = sys_clk_100_MHz\n" +
	      " PORT CLKOUT1 = sys_clk_200_MHz\n" +
	      " PORT CLKOUT2 = sys_clk_400_MHz\n" +
	      " PORT CLKOUT3 = sys_clk_400_MHz_nobuf_varphase\n" +
	      " PORT CLKOUT4 = sys_clk_50_MHz\n" +
	      " PORT LOCKED = sys_dcm_locked_port\n" +
	      " PORT PSCLK = sys_clk_100_MHz\n" +
	      " PORT PSEN = psen\n" +
	      " PORT PSINCDEC = psincdec\n" +
	      " PORT PSDONE = psdone\n" +
	      "END\n\n" +


// CHECK THE CLOCK GENERATION SCHEME!!!!!!!!!

	      "BEGIN util_vector_logic\n" +
	      " PARAMETER INSTANCE = dcm_clock_locked_last\n" +
	      " PARAMETER HW_VER = 1.00.a\n" +
	      " PARAMETER C_OPERATION = and\n" +
	      " PARAMETER C_SIZE = 1\n" +
	      " PORT Op1 = sys_dcm_locked_port\n" +
//               " PORT Op2 = mb_1_mb_2_mb_3_clock_locked_port\n" + // ????????????????????????
              " PORT Op2 = clock_locked_port_" + (_numMb-1) + "_" + _numMb +"\n" + 
	      " PORT Res = rst_dcm_locked_port\n" +
	      "END\n\n" +

	      "BEGIN proc_sys_reset\n" +
	      " PARAMETER INSTANCE = sys_reset_circuit\n" +
	      " PARAMETER HW_VER = 3.00.a\n" +
	      " PARAMETER C_EXT_RESET_HIGH = 1\n" +
	      " PORT Ext_Reset_In = sys_rst_s\n" +
	      " PORT MB_Reset = mb_reset\n" +
	      " PORT Slowest_sync_clk = sys_clk_50_MHz\n" +  // sys_clk_s ?!?!?!??!
	      " PORT Interconnect_aresetn = sys_Interconnect_aresetn\n" +
	      " PORT Dcm_locked = rst_dcm_locked_port\n" +
	      " PORT BUS_STRUCT_RESET = sys_bus_reset\n" +
	      "END\n");


    }
   
    private void visitML605PLB(ML605 x){
    
        String memorySize = "0x00001fff";
        if( _commInterface.equals("USB") ) {
            memorySize = "0x00003fff";
        }

        // Instantiate the control microblaze and the needed peripheral
        _printStream.println(
            "BEGIN microblaze\n" +
            " PARAMETER INSTANCE = host_if_mb\n" +
            " PARAMETER C_INSTANCE = host_if_mb\n" +
            " PARAMETER HW_VER = 8.20.a\n" +
            " PARAMETER C_FAMILY = virtex6\n" +
            " PARAMETER C_DEBUG_ENABLED = 0\n" +
            " PARAMETER C_INTERCONNECT = 1\n" +
            " BUS_INTERFACE DPLB = host_if_mb_plb\n" +
            " BUS_INTERFACE IPLB = host_if_mb_plb\n" +
            " BUS_INTERFACE DLMB = host_if_mb_dlmb\n" +
            " BUS_INTERFACE ILMB = host_if_mb_ilmb\n" +
            " PORT MB_RESET = mb_reset\n" +
            " PORT CLK = sys_clk_s\n" +
            " PORT Interrupt = Interrupt\n" +
            "END\n");

        _printStream.println(
            "BEGIN plb_v46\n" +
            " PARAMETER INSTANCE = host_if_mb_plb\n" +
            " PARAMETER HW_VER = 1.05.a\n" +
            " PORT PLB_Clk = sys_clk_s\n" +
            " PORT SYS_Rst = sys_bus_reset\n" +
            "END\n\n" +

            "BEGIN lmb_v10\n" +
            " PARAMETER INSTANCE = host_if_mb_ilmb\n" +
            " PARAMETER HW_VER = 2.00.b\n" +
            " PORT LMB_Clk = sys_clk_s\n" +
            " PORT SYS_Rst = sys_bus_reset\n" +
            "END\n\n" +

            "BEGIN lmb_v10\n" +
            " PARAMETER INSTANCE = host_if_mb_dlmb\n" +
            " PARAMETER HW_VER = 2.00.b\n" +
            " PORT LMB_Clk = sys_clk_s\n" +
            " PORT SYS_Rst = sys_bus_reset\n" +
            "END\n\n" +

            "BEGIN lmb_bram_if_cntlr\n" +
            " PARAMETER INSTANCE = dlmb_cntlr\n" +
            " PARAMETER HW_VER = 3.00.b\n" +
            " PARAMETER C_BASEADDR = 0x00000000\n" +
            " PARAMETER C_HIGHADDR = " + memorySize + "\n" +
            " BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
            " BUS_INTERFACE BRAM_PORT = dlmb_port\n" +
            "END\n\n" +

            "BEGIN lmb_bram_if_cntlr\n" +
            " PARAMETER INSTANCE = ilmb_cntlr\n" +
            " PARAMETER HW_VER = 3.00.b\n" +
            " PARAMETER C_BASEADDR = 0x00000000\n" +
            " PARAMETER C_HIGHADDR = " + memorySize + "\n" +
            " BUS_INTERFACE SLMB = host_if_mb_ilmb\n" +
            " BUS_INTERFACE BRAM_PORT = ilmb_port\n" +
            "END\n\n" +

            "BEGIN bram_block\n" +
            " PARAMETER INSTANCE = lmb_bram\n" +
            " PARAMETER HW_VER = 1.00.a\n" +
            " BUS_INTERFACE PORTA = ilmb_port\n" +
            " BUS_INTERFACE PORTB = dlmb_port\n" +
            "END\n\n" +

            "BEGIN clock_cycle_counter\n" +
            " PARAMETER INSTANCE = cycle_counter_host_if_mb\n" +
            " PARAMETER HW_VER = 1.00.a\n" +
            " PARAMETER C_BASEADDR = 0xf8000000\n" +
            " PARAMETER C_HIGHADDR = 0xf8000003\n" +
            " BUS_INTERFACE SLMB = host_if_mb_dlmb\n" +
            " PORT LMB_Clk = sys_clk_s\n" +
            "END\n\n" +

            "BEGIN xps_uart16550\n" +
            " PARAMETER INSTANCE = host_if_mb_RS232_Uart\n" +
            " PARAMETER HW_VER = 3.00.a\n" +
            " PARAMETER C_IS_A_16550 = 1\n" +
            " PARAMETER C_BASEADDR = 0x83e20000\n" +
            " PARAMETER C_HIGHADDR = 0x83e2ffff\n" +
            " BUS_INTERFACE SPLB = host_if_mb_plb\n" +
            " PORT sin = fpga_0_RS232_Uart_1_RX_pin\n" +
            " PORT sout = fpga_0_RS232_Uart_1_TX_pin\n" +
            " PORT IP2INTC_Irpt = RS232_Uart_1_IP2INTC_Irpt\n" +
            "END\n\n" +

            "BEGIN xps_intc\n" +
            " PARAMETER INSTANCE = xps_intc_0\n" +
            " PARAMETER HW_VER = 2.01.a\n" +
            " PARAMETER C_BASEADDR = 0x81800000\n" +
            " PARAMETER C_HIGHADDR = 0x8180ffff\n" +
            " BUS_INTERFACE SPLB = host_if_mb_plb\n" +
            " PORT Irq = Interrupt\n" +
            " PORT Intr = RS232_Uart_1_IP2INTC_Irpt\n" +
            "END\n");

            if( _commInterface.equals("USB") ) {
            _printStream.println(
                "BEGIN xps_epc\n" +
                " PARAMETER INSTANCE = usb_periph_cntlr\n" +
                " PARAMETER HW_VER = 1.02.a\n" +
                " PARAMETER C_PRH_MAX_AWIDTH = 4\n" +
                " PARAMETER C_PRH_MAX_DWIDTH = 16\n" +
                " PARAMETER C_PRH_MAX_ADWIDTH = 16\n" +
                " PARAMETER C_PRH0_AWIDTH = 4\n" +
                " PARAMETER C_PRH0_DWIDTH = 16\n" +
                " PARAMETER C_PRH0_DWIDTH_MATCH = 1\n" +
                " PARAMETER C_PRH0_SYNC = 0\n" +
                " PARAMETER C_PRH0_ADDR_TSU = 6000\n" +
                " PARAMETER C_PRH0_ADDR_TH = 6000\n" +
                " PARAMETER C_PRH0_ADS_WIDTH = 10000\n" +
                " PARAMETER C_PRH0_CSN_TSU = 6000\n" +
                " PARAMETER C_PRH0_CSN_TH = 6000\n" +
                " PARAMETER C_PRH0_WRN_WIDTH = 15000\n" +
                " PARAMETER C_PRH0_WR_CYCLE = 30000\n" +
                " PARAMETER C_PRH0_DATA_TSU = 10000\n" +
                " PARAMETER C_PRH0_DATA_TH = 5000\n" +
                " PARAMETER C_PRH0_RDN_WIDTH = 30000\n" +
                " PARAMETER C_PRH0_RD_CYCLE = 150000\n" +
                " PARAMETER C_PRH0_DATA_TOUT = 5000\n" +
                " PARAMETER C_PRH0_DATA_TINV = 10000\n" +
                " PARAMETER C_PRH0_RDY_TOUT = 10000\n" +
                " PARAMETER C_PRH0_RDY_WIDTH = 500000\n" +
                " PARAMETER C_PRH0_BASEADDR = 0xA5000000\n" +
                " PARAMETER C_PRH0_HIGHADDR = 0xA500FFFF\n" +
                " PARAMETER C_SPLB_CLK_PERIOD_PS = 10000\n" +
                " BUS_INTERFACE SPLB = host_if_mb_plb\n" +
                " PORT PRH_Rdy = net_vcc\n" +
                " PORT PRH_Clk = net_vcc\n" +
                " PORT PRH_Burst = xps_epc_0_PRH_Burst\n" +
                " PORT PRH_BE = xps_epc_0_PRH_BE\n" +
                " PORT PRH_ADS = xps_epc_0_PRH_ADS\n" +
                " PORT PRH_RNW = xps_epc_0_PRH_RNW\n" +
                " PORT PRH_Addr = usb_addr_split\n" +
                " PORT PRH_Rd_n = usb_rdn\n" +
                " PORT PRH_Wr_n = usb_wrn\n" +
                " PORT PRH_CS_n = xps_epc_0_PRH_CS_n_int\n" +
                " PORT PRH_Data = usb_data_int\n" +
                " END\n" +
                " \n" +
                "BEGIN util_bus_split\n" +
                " PARAMETER INSTANCE = usb_periph_addr_split\n" +
                " PARAMETER HW_VER = 1.00.a\n" +
                " PARAMETER C_SIZE_IN = 4\n" +
                " PARAMETER C_SPLIT = 2\n" +
                " PARAMETER C_LEFT_POS = 0\n" +
                " PORT Sig = usb_addr_split\n" +
                " PORT Out1 = usb_addr\n" +
                "END\n");
        }


        // Instantiate the host controller
        _printStream.println(
                "BEGIN lmb_host_ctrl\n" +
                " PARAMETER INSTANCE = lmb_host_interface_ctrl\n" +
                " PARAMETER HW_VER = 1.00.a\n" +
                " PARAMETER C_BASEADDR = 0x0A000000\n" +
                " PARAMETER C_HIGHADDR = 0x0A00000f\n" +
                " PARAMETER C_AB = 8\n" +
                " PARAMETER N_FIN = " + (_numMb + _numHWNode) + "\n" +
                " BUS_INTERFACE SLMB = host_if_mb_dlmb");

            if( _numHWNode > 0 ) {
            _printStream.println(
                " BUS_INTERFACE PAR_BUS = PARBUS\n" +
                " PORT RST_OUT = reset_IP");
            }

            _printStream.println(
            " PORT ENABLE_MB = net_enable_MBs");

        for (int i = 1; i <= _numMb; i++) {
            _printStream.println(
            " PORT FIN_" + ( i - 1 ) + " = net_fin_signal_P" + i);
        }

        for (int i = _numMb ; i < _numMb + _numHWNode; i++) {
                _printStream.println(
            " PORT FIN_" + i + " = net_fin_signal_IP_" + (i - _numMb + 1));
        }

        _printStream.println(
                "END\n");

        // Instantiate the clock generator and the reset block
        _printStream.println(
            "BEGIN clock_generator\n" +
            " PARAMETER INSTANCE = clock_generator_0\n" +
            " PARAMETER C_CLKIN_FREQ = 200000000\n" +
            " PARAMETER C_CLKOUT0_FREQ = 100000000\n" +
            " PARAMETER C_CLKOUT0_PHASE = 0\n" +
            " PARAMETER C_CLKOUT0_GROUP = MMCM0\n" +
            " PARAMETER C_CLKOUT0_BUF = TRUE\n" +
            " PARAMETER C_CLKOUT1_FREQ = 200000000\n" +
            " PARAMETER C_CLKOUT1_PHASE = 0\n" +
            " PARAMETER C_CLKOUT1_GROUP = MMCM0\n" +
            " PARAMETER C_CLKOUT1_BUF = TRUE\n" +
            " PARAMETER C_CLKOUT2_FREQ = 400000000\n" +
            " PARAMETER C_CLKOUT2_PHASE = 0\n" +
            " PARAMETER C_CLKOUT2_GROUP = MMCM0\n" +
            " PARAMETER C_CLKOUT2_BUF = TRUE\n" +
            " PARAMETER C_CLKOUT3_FREQ = 400000000\n" +
            " PARAMETER C_CLKOUT3_PHASE = 0\n" +
            " PARAMETER C_CLKOUT3_GROUP = MMCM0\n" +
            " PARAMETER C_CLKOUT3_BUF = FALSE\n" +
            " PARAMETER C_CLKOUT3_VARIABLE_PHASE = TRUE\n" +
            " PARAMETER C_PSDONE_GROUP = MMCM0\n" +
            " PARAMETER C_EXT_RESET_HIGH = 1\n" +
            " PARAMETER HW_VER = 4.02.a\n" +
            " PORT CLKIN = CLK_S\n" +
            " PORT CLKOUT0 = sys_clk_s\n" +
            " PORT CLKOUT1 = clk_200_0000MHzMMCM0\n" +
            " PORT CLKOUT2 = clk_400_0000MHzMMCM0\n" +
            " PORT CLKOUT3 = clk_400_0000MHzMMCM0_nobuf_varphase\n" +
            " PORT PSCLK = clk_200_0000MHzMMCM0\n" +
            " PORT PSEN = MPMC_DCM_PSEN\n" +
            " PORT PSINCDEC = MPMC_DCM_PSINCDEC\n" +
            " PORT PSDONE = MPMC_DCM_PSDONE\n" +
            " PORT RST = sys_rst_s\n" +
            " PORT LOCKED = Dcm_all_locked");

        if ( _numZbtCtrl == 1 ) {
            _printStream.println(
            " PARAMETER C_CLKFBIN_FREQ = 125000000\n" +
            " PARAMETER C_CLKFBOUT_FREQ = 125000000\n" +
            " PARAMETER C_CLKFBOUT_BUF = TRUE");
        }


        if( _numZbtCtrl == 1 ) {
            _printStream.println(
            " PORT CLKFBIN = ZBT_CLK_FB_s\n" +
            " PORT CLKFBOUT = ZBT_CLK_OUT_s");
        }

        _printStream.println(
            "END\n");

        _printStream.println(
            "BEGIN proc_sys_reset\n" +
            " PARAMETER INSTANCE = proc_sys_reset_0\n" +
            " PARAMETER HW_VER = 3.00.a\n" +
            " PARAMETER C_EXT_RESET_HIGH = 1\n" +
            " PORT Slowest_sync_clk = sys_clk_s\n" +
            " PORT Dcm_locked = Dcm_all_locked\n" +
            " PORT Ext_Reset_In = sys_rst_s\n" +
            " PORT MB_Reset = mb_reset\n" +
            " PORT Bus_Struct_Reset = sys_bus_reset\n" +
            " PORT Peripheral_Reset = sys_periph_reset\n" +
            "END\n");
            
        // We need a multi-port memory controller to connect MB processors to off-chip memory,
        // used also by the interface MB to communicate data with the host
        int numPorts = 1; // The interface MicroBlaze is always connected to the MPMC
            Iterator i;
            i = x.getPortList().iterator();

            while (i.hasNext()) {
                Port port = (Port) i.next();
                if ( port.getMemSize() > 0 ) {
            numPorts++;
            }
        }

        _printStream.println(
            "BEGIN mpmc\n" +
            " PARAMETER INSTANCE = DDR3_SDRAM\n" +
            " PARAMETER HW_VER = 6.04.a\n" +
            " PARAMETER C_MMCM_EXT_LOC = MMCM_ADV_X0Y9\n" +
            " PARAMETER C_MEM_TYPE = DDR3\n" +
            " PARAMETER C_NUM_PORTS = " + numPorts + "\n" +
            " PARAMETER C_MEM_PARTNO = MT4JSF6464HY-1G1\n" +
            " PARAMETER C_MEM_ODT_TYPE = 1\n" +
            " PARAMETER C_MEM_REG_DIMM = 0\n" +
            " PARAMETER C_MEM_CLK_WIDTH = 1\n" +
            " PARAMETER C_MEM_ODT_WIDTH = 1\n" +
            " PARAMETER C_MEM_CE_WIDTH = 1\n" +
            " PARAMETER C_MEM_CS_N_WIDTH = 1\n" +
            " PARAMETER C_MEM_DATA_WIDTH = 32\n" +
            " PARAMETER C_MEM_NDQS_COL0 = 3\n" +
            " PARAMETER C_MEM_NDQS_COL1 = 1\n" +
            " PARAMETER C_MEM_DQS_LOC_COL0 = 0x000000000000000000000000000000020100\n" +
            " PARAMETER C_MEM_DQS_LOC_COL1 = 0x000000000000000000000000000000000003"
            );

        for( int k=0; k<numPorts; k++ ) {
            _printStream.println(
            " PARAMETER C_PIM" + k + "_BASETYPE = 2");
        }

        _printStream.println(
            " PARAMETER C_ALL_PIMS_SHARE_ADDRESSES = 1\n" +
            " PARAMETER C_MPMC_BASEADDR = 0x90000000\n" +
            " PARAMETER C_MPMC_HIGHADDR = 0x9FFFFFFF\n" +

            " BUS_INTERFACE SPLB0 = host_if_mb_plb");

        // connect the processors that need off-chip memory

        numPorts = 1;
            String mpmcPorts = "";

            i = x.getPortList().iterator();
            while (i.hasNext()) {
                Port port = (Port) i.next();
                if ( port.getMemSize() > 0 ) {
            mpmcPorts += " BUS_INTERFACE SPLB" + numPorts + " = " + port.getLink().getName() + "\n";
            numPorts++;
            }
        }
        _printStream.print( mpmcPorts );

        _printStream.println(
            " PORT MPMC_Clk0 = clk_200_0000MHzMMCM0\n" +
            " PORT MPMC_Clk_200MHz = clk_200_0000MHzMMCM0\n" +
            " PORT MPMC_Rst = sys_periph_reset\n" +
            " PORT MPMC_Clk_Mem = clk_400_0000MHzMMCM0\n" +
            " PORT MPMC_Clk_Rd_Base = clk_400_0000MHzMMCM0_nobuf_varphase\n" +
            " PORT MPMC_DCM_PSEN = MPMC_DCM_PSEN\n" +
            " PORT MPMC_DCM_PSINCDEC = MPMC_DCM_PSINCDEC\n" +
            " PORT MPMC_DCM_PSDONE = MPMC_DCM_PSDONE\n" +
            " PORT DDR3_Clk = fpga_0_DDR3_SDRAM_DDR3_Clk_pin\n" +
            " PORT DDR3_Clk_n = fpga_0_DDR3_SDRAM_DDR3_Clk_n_pin\n" +
            " PORT DDR3_CE = fpga_0_DDR3_SDRAM_DDR3_CE_pin\n" +
            " PORT DDR3_CS_n = fpga_0_DDR3_SDRAM_DDR3_CS_n_pin\n" +
            " PORT DDR3_ODT = fpga_0_DDR3_SDRAM_DDR3_ODT_pin\n" +
            " PORT DDR3_RAS_n = fpga_0_DDR3_SDRAM_DDR3_RAS_n_pin\n" +
            " PORT DDR3_CAS_n = fpga_0_DDR3_SDRAM_DDR3_CAS_n_pin\n" +
            " PORT DDR3_WE_n = fpga_0_DDR3_SDRAM_DDR3_WE_n_pin\n" +
            " PORT DDR3_BankAddr = fpga_0_DDR3_SDRAM_DDR3_BankAddr_pin\n" +
            " PORT DDR3_Addr = fpga_0_DDR3_SDRAM_DDR3_Addr_pin\n" +
            " PORT DDR3_DQ = fpga_0_DDR3_SDRAM_DDR3_DQ_pin\n" +
            " PORT DDR3_DM = fpga_0_DDR3_SDRAM_DDR3_DM_pin\n" +
            " PORT DDR3_Reset_n = fpga_0_DDR3_SDRAM_DDR3_Reset_n_pin\n" +
            " PORT DDR3_DQS = fpga_0_DDR3_SDRAM_DDR3_DQS_pin\n" +
            " PORT DDR3_DQS_n = fpga_0_DDR3_SDRAM_DDR3_DQS_n_pin\n" +
            "END\n");
    }

    ///////////////////////////////////////////////////////////////////
    ////                         private variables                  ///

    private Vector _fifoList  = new Vector();

    private int _zbtInterfaceFlag = 0;

    private int _numZbtCtrl = 0;

    private int _numZbtCtrlVisit = 0;

    private int _numMb = 0;

    private int _numHWNode = 0;

    private int _numUart = 0;

    private int _numUartVisit = 1;

    private int _numFinCtrl = 1;

    private int _numFinIP = 1;

    private int _numTimers = 0;

    private Mapping _mapping = null;

    private static UserInterface _ui = null;

    private String _targetBoard = "";

    private String _commInterface = "";

    private static int _axiCMBaseAddress = 0x80010000;

    private boolean _isAXICrossbar = false;

    private static int _cntr = 0;
    private static boolean _first = true;
}
