/*******************************************************************\

The ESPAM Software Tool 
Copyright (c) 2004-2008 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the 
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by 
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

package espam.visitor.xps.platform;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Iterator;

import espam.datamodel.EspamException;
import espam.datamodel.mapping.Mapping;
import espam.datamodel.platform.Platform;
import espam.datamodel.platform.Port;
import espam.datamodel.platform.Resource;
import espam.datamodel.platform.Link;
import espam.datamodel.platform.peripherals.ZBTMemoryController;
import espam.datamodel.platform.peripherals.Uart;
import espam.datamodel.platform.ports.DLMBPort;
import espam.datamodel.platform.ports.ILMBPort;
import espam.datamodel.platform.ports.OPBPort;
import espam.datamodel.platform.processors.PowerPC;
import espam.datamodel.platform.processors.MicroBlaze;
import espam.datamodel.platform.memories.MultiFifo;
import espam.datamodel.platform.memories.Memory;
import espam.datamodel.platform.memories.Fifo;
import espam.datamodel.platform.memories.BRAM;
import espam.datamodel.platform.memories.ZBT;
import espam.datamodel.platform.communication.Crossbar;
import espam.datamodel.platform.hwnodecompaan.CompaanHWNode;
import espam.datamodel.platform.controllers.MemoryController;
import espam.datamodel.platform.controllers.FifosController;
import espam.datamodel.platform.controllers.MultiFifoController;
import espam.datamodel.platform.controllers.ReadCrossbarController;
import espam.main.UserInterface;

import espam.visitor.PlatformVisitor;

//////////////////////////////////////////////////////////////////////////
//// Platform Mss Visitor

/**
 *  This class is a class for a visitor that is used to generate
 *  Microprocessor Software Specification for Xps tool.
 *
 * @author  Wei Zhong, Joris Huizer
 * @version  $Id: MssVisitor.java,v 1.4 2009/06/26 14:37:31 stefanov Exp $
 */

public class MssVisitor extends PlatformVisitor {

    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///

    /**
     *  Constructor for the MssVisitor object
     */
    public MssVisitor(Mapping mapping)
        throws FileNotFoundException,EspamException { 
        
    	_ui = UserInterface.getInstance();
	_mapping = mapping;
    	
        _printStream = _openFile("system", "mss");
        _printStream.println("## File automatically generated by ESPAM");
        _printStream.println("");
        _printStream.println("");
    	
    }
    
    /**
     *  Print a Mss file in the correct format for MSS.
     *
     * @param  x The platform that needs to be rendered.
     */
    public void visitComponent(Platform x) {

        _prefixInc();
        _printStream.println( 
        		" PARAMETER VERSION = 2.2.0");
        _printStream.println("");

	    Iterator i;

        // Visit all processes
        Resource resource;
        i = x.getResourceList().iterator();
        while( i.hasNext() ) {
            resource = (Resource) i.next();
            resource.accept(this);
        }

        _printStream.println("");
        
        _prefixDec();
        _printStream.println("");
    }
/*---------------------------------------- Processors --------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(PowerPC x) {

    }

    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(MicroBlaze x) {

           String uartName = "";
	   String opbLinkName = "";
	   Iterator i;
	   
	   if ( _mapping.getProcessor(x.getName()).getScheduleType() == 1 ) {
		   _printStream.print(
				"BEGIN OS\n" +
				" PARAMETER OS_NAME = xilkernel\n" +
				" PARAMETER OS_VER = 3.00.a\n" +
				" PARAMETER PROC_INSTANCE = " + x.getName() + "\n" +
				" PARAMETER enhanced_features = true\n" +
				" PARAMETER systmr_dev = opb_timer_" + _numTimers + "\n" +
				" PARAMETER config_yield = true\n" +
				" PARAMETER max_pthreads = " + (_mapping.getProcessor(x.getName()).getProcessList().size() + 2) + "\n" +
				" PARAMETER systmr_interval = 500\n" +
				" PARAMETER pthread_stack_size = 1000\n" +
				" PARAMETER static_pthread_table = ((thread_main,1))\n");
	   } else {
		   _printStream.print(
				"BEGIN OS\n" +
				" PARAMETER OS_NAME = standalone\n" +
				" PARAMETER OS_VER = 1.00.a\n" +
				" PARAMETER PROC_INSTANCE = " + x.getName() + "\n");
	   }

           i = x.getPortList().iterator();
           while (i.hasNext()) {
               Port port = (Port) i.next();
               if ( port instanceof OPBPort ) {
                    Iterator j = port.getLink().getPortList().iterator();
                    while (j.hasNext()) {
                         Port lp = (Port) j.next();
                         Resource rs = lp.getResource();
                         if ( rs instanceof Uart  ) {
                              uartName = rs.getName();
			      _printStream.print(
						" PARAMETER STDOUT = " + uartName + "\n" +
						" PARAMETER STDIN = " + uartName + "\n");
                         }
                    }
               }
           }
	   _printStream.println(
				"END\n" +
				"\n" +
				"BEGIN PROCESSOR\n" +
				" PARAMETER DRIVER_NAME = cpu\n" +
				" PARAMETER DRIVER_VER = 1.00.a\n" +
				" PARAMETER HW_INSTANCE = " + x.getName() + "\n" +
				" PARAMETER COMPILER = mb-gcc\n" +
				" PARAMETER ARCHIVER = mb-ar\n" +
				"END\n" );
	   
	
	if ( _mapping.getProcessor(x.getName()).getScheduleType() == 1 ) {
		   _printStream.println(
				"BEGIN DRIVER\n" +
				" PARAMETER DRIVER_NAME = tmrctr\n" +
				" PARAMETER DRIVER_VER = 1.00.b\n" +
				" PARAMETER HW_INSTANCE = opb_timer_" + _numTimers + "\n" +
				"END\n");
		   _numTimers++;
	   }


       i = x.getPortList().iterator();
       while (i.hasNext()) {
           Port port = (Port) i.next();
           if ( port instanceof OPBPort ) {
               opbLinkName = port.getLink().getName();
               _printStream.println(
            		"BEGIN DRIVER\n" +
           			" PARAMETER DRIVER_NAME = opbarb\n" +
           			" PARAMETER DRIVER_VER = 1.02.a\n" +
           			" PARAMETER HW_INSTANCE = " + opbLinkName + "\n" +
           			"END\n");
            }
       }
       
       _printStream.println(
    		   "BEGIN DRIVER\n" +
      			" PARAMETER DRIVER_NAME = generic\n" +
      			" PARAMETER DRIVER_VER = 1.00.a\n" +
      			" PARAMETER HW_INSTANCE = fin_ctrl_P" + _numFinCtrl + "\n" +
      			"END\n");
       
       if( _ui.getDebuggerFlag() ) {
    	   
    	   _printStream.println(
        		   "BEGIN DRIVER\n" +
          			" PARAMETER DRIVER_NAME = generic\n" +
          			" PARAMETER DRIVER_VER = 1.00.a\n" +
          			" PARAMETER HW_INSTANCE = clock_cycle_counter_P" + _numFinCtrl + "\n" +
          			"END\n");
		    
		}
       
       _numFinCtrl++;
	   
    }
/*--------------------------------------- CompaanHWNode -------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(CompaanHWNode x) {

    }
/*---------------------------------------- Memories ----------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(MultiFifo x) {

    }

    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(Fifo x) {

    	_printStream.println(
    			"BEGIN DRIVER\n" +
    			" PARAMETER DRIVER_NAME = generic\n" +
    			" PARAMETER DRIVER_VER = 1.00.a\n" +
    			" PARAMETER HW_INSTANCE = " + x.getName() + "\n" +
    			"END\n");
    	
    }

     /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(BRAM x) {

    }

    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(ZBT x) {

    }

    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(Memory x) {

    }

/*--------------------------------------- Controllers -------------------------------------------------------*/
    /**
     *  Print a line for a memory controller in the correct format for MSS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(MemoryController x) {
    	
    	_printStream.println(
    			"BEGIN DRIVER\n" +
    			" PARAMETER DRIVER_NAME = bram\n" +
    			" PARAMETER DRIVER_VER = 1.00.a\n" +
    			" PARAMETER HW_INSTANCE = " + x.getName() + "\n" +
    			"END\n" );

    }

    /**
     *  Print a line for a ReadCrossbar controller in the correct format for MSS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(ReadCrossbarController x) {

    }

    /**
     *  Print a line for a multi-fifo controller in the correct format for MSS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(MultiFifoController x) {

    }

    /**
     *  Print a line for a fifos controller in the correct format for MSS.
     *
     * @param  x The controller that needs to be rendered.
     */
    public void visitComponent(FifosController x) {
        
        _printStream.println(
        		"BEGIN DRIVER\n" +
        		" PARAMETER DRIVER_NAME = generic\n" +
        		" PARAMETER DRIVER_VER = 1.00.a\n" +
        		" PARAMETER HW_INSTANCE = " + x.getName() + "\n" + 
        		"END\n" );

    }


/*--------------------------------------- Communication -------------------------------------------------------*/
    /**
     *  Print a line for the process in the correct format for MSS.
     *
     * @param  x The process that needs to be rendered.
     */
    public void visitComponent(Crossbar x) {

    }
/*---------------------------------------- Link --------------------------------------------------------------*/
    /**
     *  Print a line for the channel in the correct format for MSS.
     *
     * @param  x The channel that needs to be rendered.
     */
    public void visitComponent(Link x) {

    }
    
    /*---------------------------------------- Peripherals --------------------------------------------------------------*/
    /**
     *  Print a line for the ZBTMemoryController in the correct format for MSS.
     *
     * @param  x The ZBTMemoryController that needs to be rendered.
     */
    public void visitComponent(ZBTMemoryController x) {
    	if (_zbtInterfaceFlag == 0) {
    		_printStream.println(
    				"BEGIN DRIVER\n" +
            		" PARAMETER DRIVER_NAME = generic\n" +
            		" PARAMETER DRIVER_VER = 1.00.a\n" +
            		" PARAMETER HW_INSTANCE = host_zbt_main\n" + 
            		"END\n" );
    		
    		_printStream.println(
    				"BEGIN DRIVER\n" +
            		" PARAMETER DRIVER_NAME = generic\n" +
            		" PARAMETER DRIVER_VER = 1.00.a\n" +
            		" PARAMETER HW_INSTANCE = host_design_controller\n" + 
            		"END\n" );
    		
    		_printStream.println(
    				"BEGIN DRIVER\n" +
            		" PARAMETER DRIVER_NAME = generic\n" +
            		" PARAMETER DRIVER_VER = 1.00.a\n" +
            		" PARAMETER HW_INSTANCE = multiplexer\n" + 
            		"END\n" );
    		
    		_printStream.println(
    				"BEGIN DRIVER\n" +
            		" PARAMETER DRIVER_NAME = generic\n" +
            		" PARAMETER DRIVER_VER = 1.00.a\n" +
            		" PARAMETER HW_INSTANCE = buff\n" + 
            		"END\n" );
    	}
    	
    	_zbtInterfaceFlag++;
    		
    	_printStream.println(
            	"BEGIN DRIVER\n" +
            	" PARAMETER DRIVER_NAME = generic\n" +
            	" PARAMETER DRIVER_VER = 1.00.a\n" +
            	" PARAMETER HW_INSTANCE = " + x.getName() + "\n" + 
            	"END\n" );

    }
    
    /**
     *  Print a line for the Uart in the correct format for MSS.
     *
     * @param  x The Uart that needs to be rendered.
     */
    public void visitComponent(Uart x) {
    	
    	_printStream.println(
            	"BEGIN DRIVER\n" +
            	" PARAMETER DRIVER_NAME = uartlite\n" +
            	" PARAMETER DRIVER_VER = 1.00.b\n" +
            	" PARAMETER HW_INSTANCE = " + x.getName() + "\n" + 
            	"END\n" );

    }
 
    ///////////////////////////////////////////////////////////////////
    ////                         private methods                    ///

    /**
     *  Description of the Method
     *
     * @param  fileName Description of the Parameter
     * @param  extension Description of the Parameter
     * @return  Description of the Return Value
     * @exception  FileNotFoundException Description of the Exception
     */
    private static PrintStream _openFile( String fileName, String extension )
            throws FileNotFoundException {

        PrintStream printStream = null;
        UserInterface ui = UserInterface.getInstance();
        String fullFileName = "";

	// Create the directory indicated by the '-o' option. Otherwise
        // select the orignal filename. (REFACTOR)
        if( ui.getOutputFileName() == "" ) {
            fullFileName =
                ui.getBasePath() + "/" +
                ui.getFileName() + "/" + fileName + "." + extension;
        } else {
            fullFileName =
                ui.getBasePath() + "/" +
                ui.getOutputFileName() + "/" + fileName + "." + extension;
        }

        System.out.println(" -- OPEN FILE: " + fullFileName);

        if( fileName.equals("") ) {
            printStream = new PrintStream( System.out );
        } else {
            OutputStream file = null;

            file = new FileOutputStream( fullFileName );
            printStream = new PrintStream( file );
        }

        return printStream;
    }
    
    ///////////////////////////////////////////////////////////////////
    ////                         private variables                  ///
    
    private int _zbtInterfaceFlag = 0;
    
    private int _numFinCtrl = 1;
    
    private int _numTimers = 0;
    
    private Mapping _mapping = null;
	
    private static UserInterface _ui = null;
    
}
