/*******************************************************************\

The ESPAM Software Tool 
Copyright (c) 2004-2009 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the 
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by 
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

package espam.visitor.ise;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;
import java.util.HashMap;
import java.lang.Math;

import espam.datamodel.EspamException;
import espam.datamodel.LinearizationType;
import espam.datamodel.mapping.*;
import espam.datamodel.domain.IndexVector;
import espam.datamodel.domain.Polytope;
import espam.datamodel.graph.adg.*;
import espam.datamodel.platform.memories.*;
import espam.datamodel.platform.Platform;
import espam.datamodel.platform.Resource;
import espam.datamodel.platform.Port;
import espam.datamodel.platform.ports.*;
import espam.datamodel.platform.hwnodecompaan.*;
import espam.datamodel.pn.cdpn.*;
import espam.datamodel.pn.*;

import espam.main.UserInterface;

import espam.visitor.PlatformVisitor;
import espam.visitor.expression.*;
import espam.visitor.xps.Copier;

import espam.utils.symbolic.expression.*;
import espam.utils.symbolic.matrix.JMatrix;




//////////////////////////////////////////////////////////////////////////
//// Reorder Memory Visitor

/**
 * This class generates a reorder memory in VHDL for a given channel.
 *
 * @author Sven van Haastregt
 * @version $Id: ReorderMemoryVisitor.java,v 1.1 2011/05/17 15:05:35 svhaastr Exp $
 */

public class ReorderMemoryVisitor extends PlatformVisitor {

  // /////////////////////////////////////////////////////////////////
  // // public methods ///

  /**
   * Constructor for the ReorderMemoryVisitor object
   * @param mapping
   *            The mapping of the corresponding platform which contains crucial mapping information.
   */
  public ReorderMemoryVisitor( Mapping mapping, String codeDir ) {
    _ui = UserInterface.getInstance();
    _mapping = mapping;
    _adg = _mapping.getADG();
    _codeDir = codeDir;
  }

  /**
   * Generates a reorder memory for a particular "fifo" channel.
   *
   * @param x
   *            The "FIFO" that needs to be rendered.
   */
  public void visitComponent(Fifo x) {
    try {
      LinearizationType commModel = _mapping.getCDChannel(x).getCommunicationModel();
      if (commModel == LinearizationType.GenericOutOfOrder) {
        System.err.println("WARNING: Out of order not yet supported in ISE visitor.");
      }
      else {
        System.err.println("WARNING: Reorder visitor called, but channel is not GenericOutOfOrder.");
      }
      _coreName = "reorder_" + x.getName().substring(5); // remove leading FIFO_ part from name
      _moduleDir = _coreName;
      File dir = new File(_codeDir + "/" + _moduleDir);
      dir.mkdirs();

      CDChannel cdchan = _mapping.getCDChannel(x);
      assert(cdchan.getAdgEdgeList().size() == 1);    // Multiple ADGEdges for same channel untested/unhandled
      _adgEdge = (ADGEdge) cdchan.getAdgEdgeList().get(0);

      _writeTopLevel(x);

    } catch (Exception e) {
      System.out.println(" In ISE Network Visitor: exception " + "occured: " + e.getMessage());
      e.printStackTrace();
    }

  }








  // /////////////////////////////////////////////////////////////////
  // // private methods ///

  /**
   * Write the toplevel file.
   */
  private void _writeTopLevel(Fifo x) throws FileNotFoundException {
    PrintStream topPS = _openFile(_moduleDir + "/" + _coreName + ".vhd");
    topPS.println("-- Reordering memory for channel " + x.getName());
    topPS.println("-- Generated by ESPAM.");
    topPS.println("-- Sven van Haastregt, LIACS, Leiden University.");
    topPS.println("");
    topPS.println("library IEEE;");
    topPS.println("use IEEE.std_logic_1164.all;");
    topPS.println("");
    topPS.println("entity " + _coreName + " is");
    topPS.println("  generic (");
    topPS.println("    C_EXT_RESET_HIGH    : integer := 1;");
    topPS.println("    C_DWIDTH            : integer := 32;");
    topPS.println("    C_AWIDTH            : integer := 4");
    topPS.println("  );");
    topPS.println("  port (");
    topPS.println("    -- Clock and reset signals");
    topPS.println("    Ext_Clk : in  std_logic;");
    topPS.println("    Ext_Rst : in  std_logic;");
    topPS.println("");
    topPS.println("    -- FSL master signals");
    topPS.println("    FSL_M_Clk     : in  std_logic;");
    topPS.println("    FSL_M_Data    : in  std_logic_vector(0 to C_DWIDTH-1);");
    topPS.println("    FSL_M_Control : in  std_logic;");
    topPS.println("    FSL_M_Write   : in  std_logic;");
    topPS.println("    FSL_M_Full    : out std_logic;");
    topPS.println("");
    topPS.println("    -- FSL slave signals");
    topPS.println("    FSL_S_Clk     : in  std_logic;");
    topPS.println("    FSL_S_Data    : out std_logic_vector(0 to C_DWIDTH-1);");
    topPS.println("    FSL_S_Control : out std_logic;");
    topPS.println("    FSL_S_Read    : in  std_logic;");
    topPS.println("    FSL_S_Exists  : out std_logic");
    topPS.println("  );");
    topPS.println("end entity " + _coreName + ";");
    topPS.println("");
    topPS.println("");
    topPS.println("architecture behaviour of " + _coreName +" is");
    topPS.println("");
    topPS.println("  signal s_rst : std_logic;");
    topPS.println("  signal s_clk : std_logic;");
    topPS.println("");
    topPS.println("begin");
    topPS.println("");
    topPS.println("  s_clk <= Ext_Clk;");
    topPS.println("  s_rst <= Ext_Rst when C_EXT_RESET_HIGH=1 else not Ext_Rst;");
    topPS.println("");

    topPS.println("-- TODO: generate body, this is a playground for now");
    JMatrix m = _adgEdge.getMapping();

    topPS.println("");
    topPS.println("end architecture behaviour;");
  }

  

  /**
   * Open a file to write
   * 
   * @param fileName
   *            the fullpath file name
   */
  private PrintStream _openFile(String fileName) throws FileNotFoundException {
    PrintStream ps = null;
    String fn = "";

    System.out.println(" -- OPEN FILE: " + fileName);

    fn = _codeDir + "/" + fileName;
    if (fileName.equals(""))
      ps = new PrintStream(System.out);
    else
      ps = new PrintStream(new FileOutputStream(fn));

    return ps;
  }


  private boolean _isSource(ADGNode node) {
    return (node.getInPorts().size() == 0);
  }
  
  private boolean _isSink(ADGNode node) {
    return (node.getOutPorts().size() == 0);
  }
  
  
  
  // /////////////////////////////////////////////////////////////////
  // // private variables ///
  private String _coreName;

  private String _moduleName;

  private String _moduleDir;

  private UserInterface _ui = null;

  private String _codeDir;

  private String _projectName;
  
  private Mapping _mapping;

  private ADGraph _adg;
  
  private ADGEdge _adgEdge; //corresponding ADG edge
  
  private Vector _inArgList ;   //in arguments of the ADG function
  
  private Vector _adgInPorts ;      //in ports of the ADG node
  
  private Vector _outArgList ;      //out arguments of the ADG function
  
  private Vector _adgOutPorts ;     //out ports of the ADG node


  ////////////////////////////////////
  // Experimental & hardcoded options:
  ////////////////////////////////////

}
