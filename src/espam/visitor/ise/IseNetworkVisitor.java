/*******************************************************************\

The ESPAM Software Tool 
Copyright (c) 2004-2009 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the 
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by 
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

package espam.visitor.ise;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;
import java.util.HashMap;
import java.lang.Math;

import espam.datamodel.EspamException;
import espam.datamodel.LinearizationType;
import espam.datamodel.mapping.*;
import espam.datamodel.domain.IndexVector;
import espam.datamodel.domain.Polytope;
import espam.datamodel.graph.adg.*;
import espam.datamodel.platform.memories.*;
import espam.datamodel.platform.Platform;
import espam.datamodel.platform.Resource;
import espam.datamodel.platform.Port;
import espam.datamodel.platform.ports.*;
import espam.datamodel.platform.hwnodecompaan.*;
import espam.datamodel.pn.cdpn.*;
import espam.datamodel.pn.*;

import espam.main.UserInterface;

import espam.operations.transformations.*;
import espam.operations.codegeneration.CodeGenerationException;
import espam.operations.codegeneration.Polytope2IfStatements;

import espam.visitor.PlatformVisitor;
import espam.visitor.expression.*;
import espam.visitor.xps.Copier;

import espam.utils.symbolic.expression.*;



//////////////////////////////////////////////////////////////////////////
//// ISE Network Visitor

/**
 * This class is a visitor that is used to generate an ISE project. This
 * visitor is typically used when all nodes of a network are mapped onto
 * CompaanHWNodes. Using this visitor requires specifying the --libxps
 * parameter to ESPAM.
 *
 * @author Sven van Haastregt
 * @version $Id: IseNetworkVisitor.java,v 1.5 2011/06/08 13:16:20 svhaastr Exp $
 */

public class IseNetworkVisitor extends PlatformVisitor {

  // /////////////////////////////////////////////////////////////////
  // // public methods ///

  /**
   * Constructor for the IseNetworkVisitor object
   * @param mapping
   *            The mapping of the corresponding platform which contains crucial mapping information.
   */
  public IseNetworkVisitor( Mapping mapping ) throws FileNotFoundException, EspamException {

    _ui = UserInterface.getInstance();
    _mapping = mapping;
    _adg = _mapping.getADG();

    if (_ui.getOutputFileName() == "") {
      _codeDir = _ui.getBasePath() + "/" + _ui.getFileName();
      _projectName = _ui.getFileName();
    } else {
      _codeDir = _ui.getBasePath() + "/" + _ui.getOutputFileName();
      _projectName = _ui.getOutputFileName();
    }

  }

  /**
   * Generates a script and a VHDL top level module to be used with ISE.
   *
   * @param x
   *            The platform that needs to be rendered.
   */
  public void visitComponent(Platform x) {
    try {
      Iterator i;
      i = x.getResourceList().iterator();
      File dir = new File(_codeDir);
      dir.mkdirs();
      _moddefS = "  ---- Hardware node definitions\n";
      _reorderdefS = "  ---- Reorder memory definitions\n";
      _modinstS = "  ---- Module instantiations\n";
      _siglistS = "  -- Signals\n";
      _fifoInst = "  ---- FSL/Communication Instantiations\n";
      _externalFifoDecls = "";
      _externalFifoPorts = new Vector<String>();

      // Write a stub for the Tcl project generation script
      _iseScriptPS = _openFile("genproject.tcl");
      _iseScriptPS.println("# Automatically generated by the ESPAM ISE visitor");
      _iseScriptPS.println("# This TCL script should be invoked with the Xilinx TCL Shell (xtclsh) to create the ISE project.");
      _iseScriptPS.println("# It assumes the XILINX_EDK environment variable points to the EDK directory.");
      _iseScriptPS.println("project new " + _projectName);
      _iseScriptPS.println("project open " + _projectName);

      _iseScriptPS.println("project set family Virtex5");
      _iseScriptPS.println("project set device XC5vlx110t");
      _iseScriptPS.println("project set package FF1738");
      _iseScriptPS.println("project set speed -2");
      _iseScriptPS.println("");

      if (_synth) {
        // Write a .UCF file if synthesize option is set
        PrintStream ucfPS = _openFile("system.ucf");
        ucfPS.println("NET \"sys_clk_pin\" TNM_NET = \"sys_clk_pin\";");
        ucfPS.println("TIMESPEC \"TS_clk\" = PERIOD \"sys_clk_pin\" 4.450000ns HIGH 50 %;");

        // Add the .ucf file to the project generation script
        _iseScriptPS.println("xfile add system.ucf");

        // Write a Tcl synthesis script
        PrintStream synthPS = _openFile("runsynthesis.tcl");
        synthPS.println("# Automatically generated by the ESPAM ISE visitor");
        synthPS.println("# This TCL script should be invoked with the Xilinx TCL Shell (xtclsh) after creating the ISE project.");
        synthPS.println("project open " + _projectName);
        synthPS.println("project set top system");
        synthPS.println("");

        synthPS.println("# Set following two options to true if you want to connect the system.vhd ports to IOBs");
        synthPS.println("project set \"Add I/O Buffers\" false");
        synthPS.println("project set \"Trim Unconnected Signals\" false");
        synthPS.println("");

        synthPS.println("# PAR effort settings");
        synthPS.println("project set \"Placer Effort Level\" high");
        synthPS.println("project set \"Place & Route Effort Level\" high");
        synthPS.println("#project set \"Placer Extra Effort\" normal");
        synthPS.println("#project set \"Extra Effort (Highest PAR level only)\" normal");
        synthPS.println("");

        synthPS.println("# Show map details");
        synthPS.println("project set \"Generate Detailed MAP Report\" true");
        synthPS.println("");

        synthPS.println("# Run XST,MAP,PAR");
        synthPS.println("process run \"Implement Design\"");
        synthPS.println("");
        synthPS.println("project close");
      }

      _iseScriptPS.println("");
      _iseScriptPS.println("xfile add system.vhd -lib_vhdl work");
      _iseScriptPS.println("");
      _iseScriptPS.println("lib_vhdl new fsl_v20_v2_11_a");
      _iseScriptPS.println("xfile add $::env(XILINX_EDK)/hw/XilinxProcessorIPLib/pcores/fsl_v20_v2_11_a/hdl/vhdl/*.vhd -lib_vhdl fsl_v20_v2_11_a");
      _iseScriptPS.println("");
      _iseScriptPS.println("xfile add " + _commonlauraDir + "/*.vhd -lib_vhdl work");
      _iseScriptPS.println("");

      // Copy the common LAURA processor components from the XPS library
      dir = new File(_codeDir + "/" + _commonlauraDir);
      dir.mkdirs();
      File f = new File(_ui.getXpsLibPath() + "/pcores/HWnode_template_v1_00_a");
      File t = new File(_codeDir + "/" + _commonlauraDir);
      Copier.copy(f, t, 1, true);

      while (i.hasNext()) {

        Resource resource = (Resource) i.next();
        if (resource instanceof CompaanHWNode) {

          CompaanHWNode node = (CompaanHWNode) resource;
          _HWNode = node;
          _coreName = node.getName();

          Iterator j = _mapping.getProcessorList().iterator();
          while(j.hasNext()){
            MProcessor mp = (MProcessor) j.next();
            System.out.println(mp.getResource().getName() + "   " + _coreName);
            if(mp.getResource() instanceof CompaanHWNode){
              if(mp.getResource().getName().equals(_coreName)== true){
                MProcess p = (MProcess)mp.getProcessList().get(0);
                System.out.println(p);
                _adgNode = p.getNode();
                _inArgList = _adgNode.getFunction().getInArgumentList();
                _adgInPorts = _adgNode.getInPorts();
                _outArgList = _adgNode.getFunction().getOutArgumentList();
                _adgOutPorts = _adgNode.getOutPorts();
                break;
              }
            }
          }

            // create the subdirectories
            _moduleName = _coreName + "_v1_00_a";
            _moduleDir = "pcores/" + _moduleName;

            // Now visit the node
            resource.accept(this);
          //}

        }
        else if (resource instanceof Fifo) {
          resource.accept(this);
        }
      }

      _systemPS = _openFile("system.vhd");
      _systemPS.println("-- Generated by the ESPAM ISE visitor");
      _systemPS.println("-- This is the top level HDL module. The designer should modify it into a useful testbench.");
      _systemPS.println("library IEEE;");
      _systemPS.println("use IEEE.STD_LOGIC_1164.ALL;");
      _systemPS.println("use IEEE.numeric_std.ALL;");
      _systemPS.println("");
      _systemPS.println("library UNISIM;");
      _systemPS.println("use UNISIM.VCOMPONENTS.ALL;");
      _systemPS.println("");
      _systemPS.println("library fsl_v20_v2_11_a;");
      _systemPS.println("use fsl_v20_v2_11_a.all;");
      _systemPS.println("");
      _systemPS.println("entity system is");
      _systemPS.println("  port (");
      _systemPS.print(_externalFifoDecls);
      _systemPS.println("    sys_clk_pin : in std_logic;");
      _systemPS.println("    sys_rst_pin : in std_logic");
      _systemPS.println("  );");
      _systemPS.println("end system;");
      _systemPS.println("");
      _systemPS.println("architecture STRUCTURE of system is");
      _systemPS.println("");
      _systemPS.println("  component fsl_v20 is");
      _systemPS.println("    generic (");
      _systemPS.println("      C_EXT_RESET_HIGH : integer;");
      _systemPS.println("      C_ASYNC_CLKS : integer;");
      _systemPS.println("      C_IMPL_STYLE : integer;");
      _systemPS.println("      C_USE_CONTROL : integer;");
      _systemPS.println("      C_FSL_DWIDTH : integer;");
      _systemPS.println("      C_FSL_DEPTH : integer");
      _systemPS.println("    );");
      _systemPS.println("    port (");
      _systemPS.println("      FSL_Clk : in std_logic;");
      _systemPS.println("      SYS_Rst : in std_logic;");
      _systemPS.println("      FSL_Rst : out std_logic;");
      _systemPS.println("      FSL_M_Clk : in std_logic;");
      _systemPS.println("      FSL_M_Data : in std_logic_vector(0 to C_FSL_DWIDTH-1);");
      _systemPS.println("      FSL_M_Control : in std_logic;");
      _systemPS.println("      FSL_M_Write : in std_logic;");
      _systemPS.println("      FSL_M_Full : out std_logic;");
      _systemPS.println("      FSL_S_Clk : in std_logic;");
      _systemPS.println("      FSL_S_Data : out std_logic_vector(0 to C_FSL_DWIDTH-1);");
      _systemPS.println("      FSL_S_Control : out std_logic;");
      _systemPS.println("      FSL_S_Read : in std_logic;");
      _systemPS.println("      FSL_S_Exists : out std_logic;");
      _systemPS.println("      FSL_Full : out std_logic;");
      _systemPS.println("      FSL_Has_Data : out std_logic;");
      _systemPS.println("      FSL_Control_IRQ : out std_logic");
      _systemPS.println("    );");
      _systemPS.println("  end component;");
      _systemPS.println("");
      _systemPS.println(_reorderdefS);
      _systemPS.println("");
      _systemPS.println(_moddefS);

      _systemPS.println("  constant QUANT  : natural := 32;");
      _systemPS.println(_siglistS);
      _systemPS.println("  signal sys_clk_s : std_logic;");
      _systemPS.println("  signal sys_rst_s : std_logic;");
      _systemPS.println("  signal net_gnd0  : std_logic;");
      _systemPS.println("  signal net_gnd16 : std_logic_vector(15 downto 0);");
      _systemPS.println("  signal cycle_counter : unsigned(31 downto 0);");
      _systemPS.println("");
      _systemPS.println("begin");
      _systemPS.println("");
      _systemPS.println("  sys_clk_s <= sys_clk_pin;");
      _systemPS.println("  sys_rst_s <= sys_rst_pin;");
      _systemPS.println("  net_gnd0  <= '0';");
      _systemPS.println("  net_gnd16 <= X\"0000\";");
      _systemPS.println("");
      _systemPS.println(_modinstS);       // HWN instantiations
      _systemPS.println(_fifoInst);       // FSL instantiations

      _systemPS.println("");
      _systemPS.println("  -- A cycle counter, useful for e.g. determining performance statistics");
      _systemPS.println("  process (sys_rst_s,sys_clk_s) begin");
      _systemPS.println("    if (sys_rst_s = '0') then");
      _systemPS.println("      cycle_counter <= X\"00000000\";");
      _systemPS.println("    elsif (rising_edge(sys_clk_s)) then");
      _systemPS.println("      cycle_counter <= cycle_counter + 1;");
      _systemPS.println("    end if;");
      _systemPS.println("  end process;");
      _systemPS.println("");
      _systemPS.println("end architecture STRUCTURE;");


      if (_synth == false) {
        // Add simulation test bench
        PrintStream simtbPS = _openFile("simulationtb.vhd");
        _writeSimulationTB(simtbPS);
        _iseScriptPS.println("xfile add simulationtb.vhd -lib_vhdl work");
        _iseScriptPS.println("");
      }

      // Write final line for the ISE script
      _iseScriptPS.println("project close");

    } catch (Exception e) {
      System.out.println(" In ISE Network Visitor: exception " + "occured: "
          + e.getMessage());
      e.printStackTrace();
    }

  }


  /**
   * Writes VHDL to define and instantiate the given hardware node.
   *
   * @param  x The CompaanHWNode that needs to be rendered.
   */
  public void visitComponent(CompaanHWNode x) {
    // Write HDL file
    if (_omitIONodes && !_isSource(_adgNode) && !_isSink(_adgNode)) {
      _writeComponentDef();
      _writeComponentInst();

      // Add creation of a new library to the ISE script
      //_iseScriptPS.println("lib_vhdl new " + _moduleName);
      //_iseScriptPS.println("xfile add " + _moduleDir + "/" + _hdlDir + "/*.vhd -lib_vhdl " + _moduleName);
      // TODO: Apparently, ISE doesn't like separate libraries... Therefore, just put everything in the work library.
      _iseScriptPS.println("xfile add " + _moduleDir + "/" + _hdlDir + "/*.vhd -lib_vhdl work");
      _iseScriptPS.println();
    }
  }


  /**
   * Generates VHDL for the given FIFO.
   *
   * @param  x The FIFO that needs to be rendered.
   */
  public void visitComponent(Fifo x) {
    ADGInPort  inp  = (ADGInPort)  _mapping.getCDChannel(x).getToGate().getAdgPortList().get(0);
    ADGOutPort outp = (ADGOutPort) _mapping.getCDChannel(x).getFromGate().getAdgPortList().get(0);
    LinearizationType commModel = _mapping.getCDChannel(x).getCommunicationModel();
    if (commModel == LinearizationType.GenericOutOfOrder) {
      System.err.println("WARNING: Out of order support is still experimental!");
      ReorderMemoryVisitor rmv = new ReorderMemoryVisitor(_mapping, _codeDir);
      x.accept(rmv);
      _iseScriptPS.println("xfile add reorder" + x.getName().substring(4) + "/*.vhd -lib_vhdl work");
      _iseScriptPS.println();
      _reorderdefS += "  component reorder" + x.getName().substring(4) + " is\n";
      _reorderdefS += "    generic (\n";
      _reorderdefS += "      C_EXT_RESET_HIGH    : integer;\n";
      _reorderdefS += "      C_DWIDTH            : integer\n";
      _reorderdefS += "    );\n";
      _reorderdefS += "    port (\n";
      _reorderdefS += "      Ext_Clk : in  std_logic;\n";
      _reorderdefS += "      Ext_Rst : in  std_logic;\n";
      _reorderdefS += "      FSL_M_Clk     : in  std_logic;\n";
      _reorderdefS += "      FSL_M_Data    : in  std_logic_vector(0 to C_DWIDTH-1);\n";
      _reorderdefS += "      FSL_M_Control : in  std_logic;\n";
      _reorderdefS += "      FSL_M_Write   : in  std_logic;\n";
      _reorderdefS += "      FSL_M_Full    : out std_logic;\n";
      _reorderdefS += "      FSL_S_Clk     : in  std_logic;\n";
      _reorderdefS += "      FSL_S_Data    : out std_logic_vector(0 to C_DWIDTH-1);\n";
      _reorderdefS += "      FSL_S_Control : out std_logic;\n";
      _reorderdefS += "      FSL_S_Read    : in  std_logic;\n";
      _reorderdefS += "      FSL_S_Exists  : out std_logic\n";
      _reorderdefS += "    );\n";
      _reorderdefS += "  end component;\n";
    }

    ADGEdge edge = (ADGEdge) _mapping.getCDChannel(x).getAdgEdgeList().get(0);
    ADGNode src = (ADGNode) edge.getPortList().get(0).getNode();
    ADGNode dst = (ADGNode) edge.getPortList().get(1).getNode();

    if (_isSource(src)) {
      // Source node
      _externalFifoPorts.addElement(inp.getName());
      _externalFifoDecls += "    -- IN: " + src.getFunction().getName() + "." + inp.getBindVariables().get(0).getName() + "\n";
      _externalFifoDecls += "    s_" + inp.getName() + "_Din    : in  std_logic_vector(31 downto 0);\n";
      _externalFifoDecls += "    s_" + inp.getName() + "_Rd     : out std_logic;\n";
      _externalFifoDecls += "    s_" + inp.getName() + "_Exist  : in  std_logic;\n";
    }

    if (_isSink(dst)) {
      // Sink node
      _externalFifoPorts.addElement(outp.getName());
      _externalFifoDecls += "    -- OUT: " + dst.getFunction().getName() + "." + outp.getBindVariables().get(0).getName() + "\n";
      _externalFifoDecls += "    s_" + outp.getName() + "_Dout   : out std_logic_vector(31 downto 0);\n";
      _externalFifoDecls += "    s_" + outp.getName() + "_Wr     : out std_logic;\n";
      _externalFifoDecls += "    s_" + outp.getName() + "_Full   : in  std_logic;\n";
    }

    // These signals are never exported in the port list, to avoid unnecessary big port lists; hence they always have to be
    // declared as a signal:
    _siglistS += "  signal s_" + inp.getName() + "_CLK   : std_logic;\n";
    _siglistS += "  signal s_" + inp.getName() + "_CTRL  : std_logic;\n";
    _siglistS += "  signal s_" + outp.getName() + "_CLK   : std_logic;\n";
    _siglistS += "  signal s_" + outp.getName() + "_CTRL  : std_logic;\n";

    if (!_isSource(src) && !_isSink(dst)) {
      _siglistS += "  signal s_" + outp.getName() + "_Wr    : std_logic;\n";
      _siglistS += "  signal s_" + outp.getName() + "_Dout  : std_logic_vector(QUANT-1 downto 0);\n";
      _siglistS += "  signal s_" + outp.getName() + "_Full  : std_logic;\n";
      _siglistS += "  signal s_" + inp.getName() + "_Rd    : std_logic;\n";
      _siglistS += "  signal s_" + inp.getName() + "_Din   : std_logic_vector(QUANT-1 downto 0);\n";
      _siglistS += "  signal s_" + inp.getName() + "_Exist : std_logic;\n";

      _fifoInst += "  -- Instantiation of " + x.getName() + "  from " + src.getFunction().getName() + "." + outp.getBindVariables().get(0).getName()
                                                          + " to "    + dst.getFunction().getName() + "." + inp.getBindVariables().get(0).getName() + "\n";
      if (commModel == LinearizationType.GenericOutOfOrder) {
        _fifoInst += "  " + x.getName() + " : reorder" + x.getName().substring(4) + "\n";
        _fifoInst += "    generic map (\n";
        _fifoInst += "      C_EXT_RESET_HIGH => " + _resetHigh + ",\n";
        _fifoInst += "      C_DWIDTH         => 32\n";
        _fifoInst += "    )\n";
        _fifoInst += "    port map (\n";
        _fifoInst += "      Ext_Clk         => sys_clk_s,\n";
        _fifoInst += "      Ext_Rst         => sys_rst_s,\n";
        _fifoInst += "      FSL_M_Clk       => net_gnd0,\n";
        _fifoInst += "      FSL_M_Data      => s_" + outp.getName() + "_Dout,\n";
        _fifoInst += "      FSL_M_Control   => s_" + outp.getName() + "_CTRL,\n";
        _fifoInst += "      FSL_M_Write     => s_" + outp.getName() + "_Wr,\n";
        _fifoInst += "      FSL_M_Full      => s_" + outp.getName() + "_Full,\n";
        _fifoInst += "      FSL_S_Clk       => net_gnd0,\n";
        _fifoInst += "      FSL_S_Data      => s_" + inp.getName() + "_Din,\n";
        _fifoInst += "      FSL_S_Control   => s_" + inp.getName() + "_CTRL,\n";
        _fifoInst += "      FSL_S_Read      => s_" + inp.getName() + "_Rd,\n";
        _fifoInst += "      FSL_S_Exists    => s_" + inp.getName() + "_Exist\n";
        _fifoInst += "    );\n";
        _fifoInst += "\n";
      }
      else {
        // Instantiate regular FIFO
        int fifosize = x.getSize() + 1;
        int implstyle;
        if (fifosize <= 32) {
          implstyle = 0;  // Use LUTRAM/SRL16
        }
        else {
          implstyle = 1;  // Use BRAMs
        }

        _fifoInst += "  " + x.getName() + " : fsl_v20\n";
        _fifoInst += "    generic map (\n";
        _fifoInst += "      C_EXT_RESET_HIGH => " + _resetHigh + ",\n";
        _fifoInst += "      C_ASYNC_CLKS     => 0,\n";
        _fifoInst += "      C_IMPL_STYLE     => " + implstyle + ",\n";
        _fifoInst += "      C_USE_CONTROL    => 0,\n";
        _fifoInst += "      C_FSL_DWIDTH     => 32,\n";
        _fifoInst += "      C_FSL_DEPTH      => " + (implstyle==1 ? 512*(int)Math.ceil( (double)fifosize/512 ) : fifosize) + "  -- " + fifosize + "\n";
        _fifoInst += "    )\n";
        _fifoInst += "    port map (\n";
        _fifoInst += "      FSL_Clk         => sys_clk_s,\n";
        _fifoInst += "      SYS_Rst         => sys_rst_s,\n";
        _fifoInst += "      FSL_Rst         => open,\n";
        _fifoInst += "      FSL_M_Clk       => net_gnd0,\n";
        _fifoInst += "      FSL_M_Data      => s_" + outp.getName() + "_Dout,\n";
        _fifoInst += "      FSL_M_Control   => s_" + outp.getName() + "_CTRL,\n";
        _fifoInst += "      FSL_M_Write     => s_" + outp.getName() + "_Wr,\n";
        _fifoInst += "      FSL_M_Full      => s_" + outp.getName() + "_Full,\n";
        _fifoInst += "      FSL_S_Clk       => net_gnd0,\n";
        _fifoInst += "      FSL_S_Data      => s_" + inp.getName() + "_Din,\n";
        _fifoInst += "      FSL_S_Control   => s_" + inp.getName() + "_CTRL,\n";
        _fifoInst += "      FSL_S_Read      => s_" + inp.getName() + "_Rd,\n";
        _fifoInst += "      FSL_S_Exists    => s_" + inp.getName() + "_Exist,\n";
        _fifoInst += "      FSL_Full        => open,\n";
        _fifoInst += "      FSL_Has_Data    => open,\n";
        _fifoInst += "      FSL_Control_IRQ => open\n";
        _fifoInst += "    );\n";
        _fifoInst += "\n";
      }
    }
  }






  // /////////////////////////////////////////////////////////////////
  // // private methods ///

  /**
   * Writes a simulation test bench file.
   */
  private void _writeSimulationTB(PrintStream simtbPS) {
    simtbPS.println("-- Simulation test bench");
    simtbPS.println("-- Automatically generated by the ESPAM Xilinx ISE visitor.");
    simtbPS.println("library IEEE;");
    simtbPS.println("use IEEE.std_logic_1164.all;");
    simtbPS.println("use IEEE.numeric_std.ALL;");
    simtbPS.println("");
    simtbPS.println("use IEEE.std_logic_textio.all;");
    simtbPS.println("use std.textio.all;");
    simtbPS.println("");
    simtbPS.println("entity simtb is");
    simtbPS.println("end simtb;");
    simtbPS.println("");
    simtbPS.println("architecture behaviour of simtb is");
    simtbPS.println("  component system is");
    simtbPS.println("    port (");
    simtbPS.print(_externalFifoDecls);
    simtbPS.println("      sys_clk_pin : in std_logic;");
    simtbPS.println("      sys_rst_pin : in std_logic");
    simtbPS.println("    );");
    simtbPS.println("  end component;");
    simtbPS.println("");
    String signaldecls = _externalFifoDecls.replaceAll("  s_", "signal s_");
    signaldecls = signaldecls.replaceAll(": in  ", ": ");
    signaldecls = signaldecls.replaceAll(": out ", ": ");
    simtbPS.println(signaldecls);

    simtbPS.println("  signal sys_clk_pin : std_logic := '0';");
    simtbPS.println("  signal sys_rst_pin : std_logic := '0';");
    simtbPS.println("  signal cycle_counter : unsigned(31 downto 0);");
    simtbPS.println("");
    simtbPS.println("  file infile   : TEXT is IN  \"trcinput.txt\";");
    simtbPS.println("  file outfile  : TEXT is OUT \"trcoutput.txt\";");
    simtbPS.println("");
    simtbPS.println("begin");
    simtbPS.println("  sys_clk_pin <= not sys_clk_pin after 5 ns;");
    simtbPS.println("  sys_rst_pin <= '1' after 50 ns;");
    simtbPS.println("  ");
    simtbPS.println("  -- System instantiation");
    simtbPS.println("  sys_ut : system");
    simtbPS.println("    port map (");
    for (int i = 0; i < _externalFifoPorts.size(); i++) {
      String fifoName = _externalFifoPorts.get(i);
      if (fifoName.indexOf("IP") > 0) {
        simtbPS.println("      s_" + fifoName + "_Din => s_" + fifoName + "_Din," );
        simtbPS.println("      s_" + fifoName + "_Rd => s_" + fifoName + "_Rd," );
        simtbPS.println("      s_" + fifoName + "_Exist => s_" + fifoName + "_Exist," );
      }
      else {
        simtbPS.println("      s_" + fifoName + "_Dout => s_" + fifoName + "_Dout," );
        simtbPS.println("      s_" + fifoName + "_Wr => s_" + fifoName + "_Wr," );
        simtbPS.println("      s_" + fifoName + "_Full => s_" + fifoName + "_Full," );
      }
    }
    simtbPS.println("      sys_clk_pin => sys_clk_pin,");
    simtbPS.println("      sys_rst_pin => sys_rst_pin");
    simtbPS.println("    );");
    simtbPS.println("");
    for (int i = 0; i < _externalFifoPorts.size(); i++) {
      String fifoName = _externalFifoPorts.get(i);
      if (fifoName.indexOf("OP") > 0) {
        simtbPS.println("  s_" + fifoName + "_Full <= '0';");
      }
    }
    simtbPS.println("  ");
    simtbPS.println("  -- Process input file");
    simtbPS.println("  -- IMPORTANT: This part requires manual modification to make it fit the actual application.");
    simtbPS.println("  process (sys_rst_pin,sys_clk_pin)");
    simtbPS.println("    variable linevar : line;");
    simtbPS.println("    variable good: boolean;");
    simtbPS.println("    variable val0 : std_logic_vector(31 downto 0);");
    simtbPS.println("  begin");
    simtbPS.println("    if (sys_rst_pin = '0') then");

    String setIpSigs = "";
    for (int i = 0; i < _externalFifoPorts.size(); i++) {
      String fifoName = _externalFifoPorts.get(i);
      if (fifoName.indexOf("IP") > 0) {
        simtbPS.println("      s_" + fifoName + "_Exist <= '0';");
        simtbPS.println("      s_" + fifoName + "_Din <= X\"FFFFFFFF\";");
        setIpSigs += "        s_" + fifoName + "_Exist <= '1';\n";
        setIpSigs += "        s_" + fifoName + "_Din <= val" + i + ";\n";
      }
    }
    simtbPS.println("    elsif (rising_edge(sys_clk_pin)) then");
    simtbPS.println("      if (cycle_counter = X\"00000030\" or s_ND_1IP_ED_0_0_V_0_Rd = '1') then   --TODO");
    simtbPS.println("        readline(infile, linevar);");
    simtbPS.println("        hread(linevar, val0, good);");
    simtbPS.println("        assert good report \"Text I/O read error\" severity ERROR;");
    simtbPS.print(setIpSigs);
    simtbPS.println("      end if;");
    simtbPS.println("    end if;");
    simtbPS.println("  end process;");
    simtbPS.println("");
    simtbPS.println("  -- Write output to file");
    simtbPS.println("  process (sys_rst_pin, sys_clk_pin)");
    simtbPS.println("    variable linevar : line;");
    simtbPS.println("  begin");
    simtbPS.println("    if (sys_rst_pin = '0') then");
    simtbPS.println("    elsif (rising_edge(sys_clk_pin)) then");
    simtbPS.println("      if (s_ND_2OP_ED_2_0_V_1_Wr = '1') then   --TODO");
    simtbPS.println("        hwrite(linevar, s_ND_2OP_ED_2_0_V_1_Dout);   --TODO");
    simtbPS.println("        writeline(outfile, linevar);");
    simtbPS.println("      end if;");
    simtbPS.println("    end if;");
    simtbPS.println("  end process;");
    simtbPS.println("");
    simtbPS.println("  process (sys_rst_pin,sys_clk_pin) begin");
    simtbPS.println("    if (sys_rst_pin = '0') then");
    simtbPS.println("      cycle_counter <= X\"00000000\";");
    simtbPS.println("    elsif (rising_edge(sys_clk_pin)) then");
    simtbPS.println("      cycle_counter <= cycle_counter + 1;");
    simtbPS.println("    end if;");
    simtbPS.println("  end process;");
    simtbPS.println("");
    simtbPS.println("end architecture behaviour;");
  }


  /**
   * Writes the component definition for the current node. Also prepares some strings
   * that will be needed by _writeComponentInst().
   */
  private void _writeComponentDef() {
    // Start with an empty port map
    _portmapS = "";

    _moddefS += "  -- Module definition of node " + _adgNode.getName() + ", core " + _coreName + "\n";
    _moddefS += "  component " + _coreName + " is\n";
    _moddefS += "    generic (\n";
    _moddefS += "      RESET_HIGH : NATURAL;\n";
    _moddefS += "      PAR_WIDTH : NATURAL;\n";
    _moddefS += "      QUANT : NATURAL\n";
    _moddefS += "    );\n";
    _moddefS += "    port (\n";

    Vector <ADGInPort> binding_in_ports;
    
    Iterator i;
    Iterator j;
    
    ADGVariable in_arg;
    ADGInPort adg_in_port;
    String in_arg_name;
    
    if(_adgInPorts.size() == 0){
      
    }
    else{
      i = _inArgList.iterator();
      while(i.hasNext()){
        in_arg = (ADGVariable) i.next();
        
        // get the vector of the in ports of the node relating to the specific in_argument of the function
        binding_in_ports = new Vector<ADGInPort>();
        in_arg_name = in_arg.getName();
              
        j = _adgInPorts.iterator();
        while (j.hasNext()) {
          adg_in_port = (ADGInPort) j.next();
          if (adg_in_port.getBindVariables().get(0).getName().equals(in_arg_name)== true){
            binding_in_ports.addElement(adg_in_port);
          }
        }
        
        Iterator k = binding_in_ports.iterator();
        while (k.hasNext()) {
          ADGInPort in = (ADGInPort) k.next();
          // Module definition
          _moddefS += "      " + in.getName() + "_Rd    : out std_logic;\n";
          _moddefS += "      " + in.getName() + "_Din   : in  std_logic_vector(QUANT-1 downto 0);\n";
          _moddefS += "      " + in.getName() + "_Exist : in  std_logic;\n";
          _moddefS += "      " + in.getName() + "_CLK   : out std_logic;\n";
          _moddefS += "      " + in.getName() + "_CTRL  : in  std_logic;\n";
          _moddefS += "\n";

          // Port map instantiation
          _portmapS += "      " + in.getName() + "_Rd    => s_" + in.getName() + "_Rd,\n";
          _portmapS += "      " + in.getName() + "_Din   => s_" + in.getName() + "_Din,\n";
          _portmapS += "      " + in.getName() + "_Exist => s_" + in.getName() + "_Exist,\n";
          _portmapS += "      " + in.getName() + "_CLK   => s_" + in.getName() + "_CLK,\n";
          _portmapS += "      " + in.getName() + "_CTRL  => s_" + in.getName() + "_CTRL,\n";
          _portmapS += "\n";

        }
      }
    }

    //the out ports of the node are corresponding to out ports of the ADGNode
    Vector <ADGOutPort> binding_out_ports;
    
    ADGVariable out_arg;  
    ADGOutPort adg_out_port;
    String out_arg_name;
    
    if(_adgOutPorts.size() == 0){
      
    }
    else{
      i = _outArgList.iterator();
      while(i.hasNext()){
        out_arg = (ADGVariable) i.next();
        
        ////get the vector of the out ports of the node relating to the specific out_argument of the function
        binding_out_ports = new Vector<ADGOutPort>();
        out_arg_name = out_arg.getName();
              
        j = _adgOutPorts.iterator();
        while (j.hasNext()) {       
          adg_out_port = (ADGOutPort) j.next();
          if (adg_out_port.getBindVariables().get(0).getName().equals(out_arg_name)== true){
            binding_out_ports.addElement(adg_out_port);
          }
        }
        
        Iterator k = binding_out_ports.iterator();
        while (k.hasNext()) {
          ADGOutPort out = (ADGOutPort) k.next();
          // Module definition
          _moddefS += "      " + out.getName() + "_Wr   : out std_logic;\n";
          _moddefS += "      " + out.getName() + "_Dout : out std_logic_vector(QUANT-1 downto 0);\n";
          _moddefS += "      " + out.getName() + "_Full : in  std_logic;\n";
          _moddefS += "      " + out.getName() + "_CLK  : out std_logic;\n";
          _moddefS += "      " + out.getName() + "_CTRL : out std_logic;\n";
          _moddefS += "\n";

          // Port map instantiation
          _portmapS += "      " + out.getName() + "_Wr    => s_" + out.getName() + "_Wr,\n";
          _portmapS += "      " + out.getName() + "_Dout  => s_" + out.getName() + "_Dout,\n";
          _portmapS += "      " + out.getName() + "_Full  => s_" + out.getName() + "_Full,\n";
          _portmapS += "      " + out.getName() + "_CLK   => s_" + out.getName() + "_CLK,\n";
          _portmapS += "      " + out.getName() + "_CTRL  => s_" + out.getName() + "_CTRL,\n";
          _portmapS += "\n";

          // Signals
          /*_siglistS += "  signal s_" + out.getName() + "_Wr    : std_logic;\n";
          _siglistS += "  signal s_" + out.getName() + "_Dout  : std_logic_vector(QUANT-1 downto 0);\n";
          _siglistS += "  signal s_" + out.getName() + "_Full  : std_logic;\n";
          _siglistS += "  signal s_" + out.getName() + "_CLK   : std_logic;\n";
          _siglistS += "  signal s_" + out.getName() + "_CTRL  : std_logic;\n";*/
        }
      }
    }
    _moddefS += "      PARAM_DT : in  std_logic_vector(PAR_WIDTH-1 downto 0);\n";
    _moddefS += "      PARAM_LD : in  std_logic;\n";
    _moddefS += "\n";
    _moddefS += "      RST : in std_logic;\n";
    _moddefS += "      CLK : in std_logic;\n";
    _moddefS += "      STOP : out std_logic\n";
    _moddefS += "    );\n";
    _moddefS += "  end component;\n";
    _moddefS += "\n";
  }
  
  
  /**
   * Writes the component instantiation for the current node.
   */
  private void _writeComponentInst() {
    _modinstS += "  -- Component instantiation of node " + _adgNode.getName() + " (" + _adgNode.getFunction().getName() + ")\n";
    _modinstS += "  " + _coreName + "_0 : " + _coreName + "\n";
    _modinstS += "    generic map (\n";
    _modinstS += "      RESET_HIGH => " + _resetHigh + ",\n";
    _modinstS += "      PAR_WIDTH => 16,\n";
    _modinstS += "      QUANT => 32\n";
    _modinstS += "    )\n";
    _modinstS += "    port map (\n";
    _modinstS += "      RST => sys_rst_s,\n";
    _modinstS += "      CLK => sys_clk_s,\n";
    _modinstS += _portmapS;
    _modinstS += "      PARAM_DT => net_gnd16,\n";
    _modinstS += "      PARAM_LD => net_gnd0,\n";
    _modinstS += "      STOP => open\n";
    _modinstS += "    );\n";
    _modinstS += "\n";
  }
  

  

  /**
   * Open a file to write
   * 
   * @param fileName
   *            the fullpath file name
   */
  private PrintStream _openFile(String fileName) throws FileNotFoundException {
    PrintStream ps = null;
    String fn = "";

    System.out.println(" -- OPEN FILE: " + fileName);

    fn = _codeDir + "/" + fileName;
    if (fileName.equals(""))
      ps = new PrintStream(System.out);
    else
      ps = new PrintStream(new FileOutputStream(fn));

    return ps;
  }


  private boolean _isSource(ADGNode node) {
    return (node.getInPorts().size() == 0);
  }
  
  private boolean _isSink(ADGNode node) {
    return (node.getOutPorts().size() == 0);
  }
  
  
  
  // /////////////////////////////////////////////////////////////////
  // // private variables ///
  private String _coreName;

  // dir name
  private String _moduleName;

  private String _moduleDir;

  private static String _commonlauraDir = "common_laura";     // Contains common components of the LAURA processor (e.g. controller, muxes etc.)
  private static String _hdlDir = "hdl/vhdl";

  private UserInterface _ui = null;

  private String _codeDir;

  private String _projectName;
  
  private Mapping _mapping;

  private PrintStream _systemPS;

  private PrintStream _iseScriptPS;

  private String _moddefS;
  private String _reorderdefS;
  private String _modinstS;
  private String _siglistS;
  private String _portmapS;

  private String _fifoInst;
  private String _externalFifoDecls;
  private Vector<String> _externalFifoPorts;

  private CompaanHWNode _HWNode;
  
  private ADGraph _adg;
  
  private ADGNode _adgNode; //corresponding ADG node
  
  private Vector _inArgList ;   //in arguments of the ADG function
  
  private Vector _adgInPorts ;      //in ports of the ADG node
  
  private Vector _outArgList ;      //out arguments of the ADG function
  
  private Vector _adgOutPorts ;     //out ports of the ADG node


  ////////////////////////////////////
  // Experimental & hardcoded options:
  ////////////////////////////////////

  private boolean _omitIONodes = true; // omit input and output nodes (only keep the transformer nodes of a network which have >= 1 input and >= 1 output port)
  private boolean _synth = false;   // Make output suitable for synthesis
  private int _resetHigh = 0;       // Active reset level
}
