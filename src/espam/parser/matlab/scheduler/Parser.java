/*******************************************************************\

The ESPAM Software Tool 
Copyright (c) 2004-2008 Leiden University (LERC group at LIACS).
All rights reserved.

The use and distribution terms for this software are covered by the 
Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.txt)
which can be found in the file LICENSE at the root of this distribution.
By using this software in any fashion, you are agreeing to be bound by 
the terms of this license.

You must not remove this notice, or any other, from this software.

\*******************************************************************/

/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package espam.parser.matlab.scheduler;

/**
@author Todor Stefanov
@version $Id: Parser.java,v 1.1 2008/05/23 15:04:21 stefanov Exp $
*/

import espam.datamodel.parsetree.*;
import espam.datamodel.parsetree.statement.*;
import espam.utils.symbolic.expression.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.InputStream;
import java.util.Iterator;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();
    ///////////////////////////////////////////////////////////////////
    ////                         public methods                    ////

    public static Statement getParseTree( InputStream fileStream )
            throws ParseException
        {
            Statement x = null;
            Parser t = new Parser( fileStream );
            SimpleNode n = t.NLP();
            x = n.getStatementNode();
            return x;
        }

    ///////////////////////////////////////////////////////////////////
    ////                         private methods                   ////

    /** Reoder nodes in the parse tree. Depending on the type of the
        nodes given, either create a line of nodes, or add the nodes
        to the same parent.
        @param currentParseNode The node to which a node needs to be
        added.
        @param snode The node that needs to be added.
        @return the node to which subsequently nodes needs to be added.
    */

    private Statement _reorderNodes( Statement currentStatement,
                                   SimpleNode snode)
    {
        // Keep a reference to the currentStatement in case
        // the snode is a ASTindexStatements node.
        Statement keep = currentStatement;

        Statement st = snode.getStatementNode();
        Statement pn = snode.getStatementNode();
        //System.out.println("Current: " + currentStatement);
        //System.out.println("Statement: " + st);
        if ( st instanceof AssignStatement ||
             st instanceof IfStatement ||
             st instanceof ForStatement ||
             st instanceof RootStatement ||
             st instanceof ElseStatement ) {
            st.setParent( currentStatement );
            currentStatement.addChild( st );
        } else if ( st instanceof NilStatement ) {
            // Add all children of the Nil Statement to the
            // currentStatement. Is is need to curcumvent a problem in
            // listOfIndexStatements

            // System.out.println(" FOUND NIL STATEMENT ");
            // System.out.println(" Current Statement: " + currentStatement);;

            Iterator i = pn.getChildren();
            while (i.hasNext() ) {
                ParserNode ppn = (ParserNode)i.next();
                ppn.setParent( currentStatement );
                currentStatement.addChild( ppn );
            }
        } else {
            st.setParent( currentStatement );
            currentStatement.addChild( st );
            currentStatement = st;
        }
        return currentStatement;
    }

    ///////////////////////////////////////////////////////////////////
    ////                         private variables                 ////

    /** Static Variable Implementing a Singleton */
    private static int _textualPosition = 0;

  final public SimpleNode NLP() throws ParseException {
 /*@bgen(jjtree) NLP */
    ASTNLP jjtn000 = new ASTNLP(this, JJTNLP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);// System.out.println(" -- NLP -- ");
    SimpleNode snode;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFFUNCTION:
      case DEFINITIONTYPE:
      case DEFPARAMETER:
        declarations();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      listOfAllStatements();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            int numberOfChildern = jjtn000.jjtGetNumChildren();
            //System.out.println(" -- ROOT STATEMENT: childeren: " + numberOfChildern );

            Statement rootNode = new RootStatement();
            rootNode.setParent( null );
            Statement currentStatement = rootNode;
            for (int i=0;i<numberOfChildern;i++) {
                snode = (SimpleNode) jjtn000.jjtGetChild(i);
                currentStatement = _reorderNodes( currentStatement, snode);
            }

            jjtn000.setStatementNode( rootNode );
            {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void declarations() throws ParseException {
    declaration();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFFUNCTION:
      case DEFINITIONTYPE:
      case DEFPARAMETER:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      declaration();
    }
  }

  final public void declaration() throws ParseException {
    int numberOfChildern;
    SimpleNode node;
    String nodeName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFPARAMETER:
      parameterStatement();
      break;
    case DEFINITIONTYPE:
      typeDefinitionStatement();
      break;
    case DEFFUNCTION:
      functionDefinitionStatement();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void matlabStatement() throws ParseException {
                          /*@bgen(jjtree) matlabStatement */
    ASTmatlabStatement jjtn000 = new ASTmatlabStatement(this, JJTMATLABSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token body = null;
    try {
      jj_consume_token(MATLABBEGIN);
      body = jj_consume_token(MATLAB_COMMENT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void typeDefinitionStatement() throws ParseException {
                                  /*@bgen(jjtree) typeDefinitionStatement */
  ASTtypeDefinitionStatement jjtn000 = new ASTtypeDefinitionStatement(this, JJTTYPEDEFINITIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DEFINITIONTYPE);
      Identifier();
      Identifier();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void parameterStatement() throws ParseException {
 /*@bgen(jjtree) parameterStatement */
  ASTparameterStatement jjtn000 = new ASTparameterStatement(this, JJTPARAMETERSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DEFPARAMETER);
      Identifier();
      fraction();
      fraction();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void functionDefinitionStatement() throws ParseException {
                                      /*@bgen(jjtree) functionDefinitionStatement */
  ASTfunctionDefinitionStatement jjtn000 = new ASTfunctionDefinitionStatement(this, JJTFUNCTIONDEFINITIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(DEFFUNCTION);
      Identifier();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void listOfStatements() throws ParseException {
    statement();
    label_2:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_2;
      }
      statement();
    }
  }

  final public void listOfAllStatements() throws ParseException {
    allStatement();
    label_3:
    while (true) {
      if (jj_2_2(3)) {
        ;
      } else {
        break label_3;
      }
      allStatement();
    }
  }

  final public void statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR:
    case IF:
      controlStatement();
      break;
    case LEFTBRACKET:
      functionStatement();
      break;
    case MATLABBEGIN:
      matlabStatement();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void allStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      listOfIndexStatements();
      break;
    case FOR:
    case IF:
    case LEFTBRACKET:
    case MATLABBEGIN:
      statement();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void controlStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      ifElseStatement();
      break;
    case FOR:
      forStatement();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void functionStatement() throws ParseException {
    assignStatement();
  }

  final public void forStatement() throws ParseException {
                        /*@bgen(jjtree) forStatement */
    ASTforStatement jjtn000 = new ASTforStatement(this, JJTFORSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);// System.out.println(" -- Running a For Statement --");
    int numberOfChildern;
    SimpleNode snode;
    String nodeName;
    ForStatement forStat = null;
    try {
      jj_consume_token(FOR);
      Identifier();
      jj_consume_token(EQ);
      complexExpression();
      jj_consume_token(COLON);
      Integer();
      jj_consume_token(COLON);
      complexExpression();
      jj_consume_token(50);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR:
      case IF:
      case LEFTBRACKET:
      case MATLABBEGIN:
      case IDENTIFIER:
        listOfAllStatements();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(END);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            String id = ((ASTIdentifier) jjtn000.jjtGetChild(0)).getName();
            Expression lb = ((ASTcomplexExpression) jjtn000.jjtGetChild(1)).getLinearExp();
            int stepSize = ((ASTInteger) jjtn000.jjtGetChild(2)).getValue();
            Expression ub = ((ASTcomplexExpression) jjtn000.jjtGetChild(3)).getLinearExp();

            // We need to change the way the Nodes are organized.
            // We do not want equal statements to be childeren of
            // this For statement. We want that equal statements
            // form a connected link of statements.

            Statement forNode = new ForStatement( id, lb, ub, stepSize);
            Statement currentStatement = forNode;
            for (int i=4; i<numberOfChildern; i++) {
                snode = (SimpleNode) jjtn000.jjtGetChild(i);
                currentStatement = _reorderNodes( currentStatement, snode);
            }
            jjtn000.setStatementNode( forNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void ifElseStatement() throws ParseException {
    ifStatement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      elseStatement();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    jj_consume_token(END);
  }

  final public void ifStatement() throws ParseException {
                       /*@bgen(jjtree) ifStatement */
    ASTifStatement jjtn000 = new ASTifStatement(this, JJTIFSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int numberOfChildern;
    String nodeName;
    SimpleNode snode;
    try {
      jj_consume_token(IF);
      condition();
      jj_consume_token(50);
      listOfAllStatements();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            ASTcondition node = ((ASTcondition) jjtn000.jjtGetChild(0));

            Expression rhs = node.getRhsLinearExp();
            Expression lhs = node.getLhsLinearExp();
            int relation  = node.getRelation();

            rhs.negate();
            Expression condition = lhs;
            condition.addAll(rhs);

            switch (relation) {
               case 1:
                  // EQ ==
                  {if (true) throw new Error(" It is not allowed to use If-statement" +
                        "with an equal or not-equal to formulation." +
                        "Replace the fault If-Statement with two " +
                        "If-statements using the a-b >= 0 formulation ");}
               case 2:
                  // NEQ
                  {if (true) throw new Error(" It is not allowed to use If-statement" +
                        "with an equal or not-equal to formulation." +
                        "Replace the fault If-Statement with two " +
                        "If-statements using the a-b >= 0 formulation ");}
               case 3:
                  // LT <
                  condition.negate();
                  condition.addMinusOne();
                break;
               case 4:
                  // LE <=
                  condition.negate();
                  break;
               case 5:
                  // GT >
                  condition.addMinusOne();
                  break;
               case 6:
                  // GE >= canonical form, do nothing
                  break;
            }

            condition.simplify();
            condition.setEqualityType(1);

            Statement ifNode = new IfStatement(condition, 1);
            Statement currentStatement = ifNode;
            for (int i=1;i<numberOfChildern;i++) {
                snode = (SimpleNode) jjtn000.jjtGetChild(i);
                //System.out.println(" IF STATEMENT: " + ((Statement)snode.getStatementNode()).toString());
                currentStatement = _reorderNodes( currentStatement, snode);
            }
            jjtn000.setStatementNode( ifNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void elseStatement() throws ParseException {
                        /*@bgen(jjtree) elseStatement */
  ASTelseStatement jjtn000 = new ASTelseStatement(this, JJTELSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSE);
      listOfAllStatements();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            int numberOfChildern = jjtn000.jjtGetNumChildren();

            Statement elseNode = new ElseStatement();
            Statement currentStatement = elseNode;
            for (int i=0;i<numberOfChildern;i++) {
                SimpleNode snode = (SimpleNode) jjtn000.jjtGetChild(i);
                currentStatement = _reorderNodes( currentStatement, snode);
            }
            jjtn000.setStatementNode( elseNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void listOfIndexStatements() throws ParseException {
 /*@bgen(jjtree) listOfIndexStatements */
  ASTlistOfIndexStatements jjtn000 = new ASTlistOfIndexStatements(this, JJTLISTOFINDEXSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      indexStatements();
      label_4:
      while (true) {
        if (jj_2_3(3)) {
          ;
        } else {
          break label_4;
        }
        indexStatements();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            NilStatement nilStat = new NilStatement();

            int numberOfChildren = jjtn000.jjtGetNumChildren();
            ParserNode currentNode = nilStat;
            ParserNode scopeNode = nilStat;

            HashMap hm = new HashMap();

            // Determine count
            for (int i = 0; i < numberOfChildren; i++) {
                SimpleNode snode = (SimpleNode) jjtn000.jjtGetChild(i);
                Statement ppn = snode.getStatementNode();
                //System.out.println("(listOfIndexStatement [" + i + " ]: "
                //        + ppn.toString());
                ControlStatement indexStatement = (ControlStatement) ppn;
                String name = indexStatement.getName();
                if ( hm.containsKey( name )) {
                    Integer count = (Integer)hm.get( name );
                    int v = count.intValue();
                    hm.put( name, new Integer( ++v ));
                } else {
                    hm.put( name, new Integer( 1 ));
                }
            }

            // Show hm;
            //System.out.println(" HM: " + hm.toString());

            for (int i = 0; i < numberOfChildren; i++) {
                SimpleNode snode = (SimpleNode) jjtn000.jjtGetChild(i);
                Statement ppn = snode.getStatementNode();
                //System.out.println("(listOfIndexStatement [" + i + " ]: "
                //        + snode.toString());

                if ( ppn.getNumChildren() > 0 ) {
                    // Contains children
                    ControlStatement indexStatement = (ControlStatement) ppn;
                    String name = indexStatement.getName();
                    Integer count = (Integer)hm.get( name );
                    int v = count.intValue();
                    if ( v == 1 ) {
                        scopeNode.addChild( ppn );
                        ppn.setParent( scopeNode );
                        scopeNode = ppn;
                        currentNode = scopeNode;
                    } else {
                        currentNode.addChild( ppn );
                        ppn.setParent( currentNode );
                    }
                } else {
                    // No children
                    ControlStatement indexStatement = (ControlStatement) ppn;
                    String name = indexStatement.getName();
                    Integer count = (Integer)hm.get( name );
                    int v = count.intValue();
                    if ( v == 1 ) {
                        // Unique index-statement
                        if ( currentNode == scopeNode ) {
                            // Unique index-statement is added to a
                            // unique index statement
                            scopeNode.addChild( ppn );
                            ppn.setParent( scopeNode );
                            scopeNode = ppn;
                            currentNode = scopeNode;
                        } else {
                            // Unique index-statement has to migrate
                            // to an unique index statement
                            ParserNode searchNode = currentNode;
                            while ( searchNode.getParent() != scopeNode ) {
                                searchNode = searchNode.getParent();
                            }
                            // Remove the search node
                            scopeNode.removeChild( searchNode );

                            // Add scope node
                            scopeNode.addChild( ppn );
                            ppn.setParent( scopeNode );
                            scopeNode = ppn;

                            scopeNode.addChild( searchNode );
                            searchNode.setParent( scopeNode );

                            //currentNode = scopeNode;
                        }
                    } else {
                        // Appears mode than once...
                        currentNode.addChild( ppn );
                        ppn.setParent( currentNode );
                        currentNode = ppn;
                    }
                }
            }

            //System.out.println(" DUMP:\n " + nilStat.dumpChildren());

            jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void indexStatements() throws ParseException {
 /*@bgen(jjtree) indexStatements */
  ASTindexStatements jjtn000 = new ASTindexStatements(this, JJTINDEXSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      indexStatement();
      label_5:
      while (true) {
        if (jj_2_4(3)) {
          ;
        } else {
          break label_5;
        }
        listOfStatements();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            int numberOfChildren = jjtn000.jjtGetNumChildren();
            SimpleNode node = (SimpleNode)jjtn000.jjtGetChild(0);
            Statement indexNode = node.getStatementNode();
            Statement currentParseNode = indexNode;
            //System.out.println("(indexStatement 0: "
            //        + currentParseNode.toString());
            for (int i = 1; i < numberOfChildren; i++) {
                SimpleNode snode = (SimpleNode) jjtn000.jjtGetChild(i);
                //System.out.println("(indexStatement [" + i + " ]: "
                //        + snode.toString());
                currentParseNode = _reorderNodes( currentParseNode, snode);
            }
            jjtn000.setStatementNode( indexNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void indexStatement() throws ParseException {
                         /*@bgen(jjtree) indexStatement */
  ASTindexStatement jjtn000 = new ASTindexStatement(this, JJTINDEXSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      jj_consume_token(EQ);
      complexExpression();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            String id = ((ASTIdentifier) jjtn000.jjtGetChild(0)).getName();
            Expression exp = ((ASTcomplexExpression)
                    jjtn000.jjtGetChild(1)).getLinearExp();
            ControlStatement  indexNode = new ControlStatement( id, exp, 1);
            //System.out.println(" FOUND INDEX: " + indexNode);
            jjtn000.setStatementNode( indexNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void assignStatement() throws ParseException {
 /*@bgen(jjtree) assignStatement */
    ASTassignStatement jjtn000 = new ASTassignStatement(this, JJTASSIGNSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);String name;
    try {
      leftVariableList();
      jj_consume_token(EQ);
      Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 51:
        rightVariableList();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            name = ((ASTIdentifier) jjtn000.jjtGetChild(1)).getName();
            AssignStatement assignNode = new AssignStatement();
            assignNode.setFunctionName(name);

            LhsStatement ls = new LhsStatement();
            ls.setParent( assignNode );
            assignNode.addChild( ls );

            RhsStatement rs = new RhsStatement();
            rs.setParent( assignNode );
            assignNode.addChild( rs );

            jjtn000.setStatementNode( assignNode );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void ipdStatement() throws ParseException {
 /*@bgen(jjtree) ipdStatement */
  ASTipdStatement jjtn000 = new ASTipdStatement(this, JJTIPDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACKET);
      Identifier();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(EQ);
      jj_consume_token(IPD);
      jj_consume_token(51);
      variable();
      jj_consume_token(52);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte000;}
       }
       if (jjte000 instanceof ParseException) {
         {if (true) throw (ParseException)jjte000;}
       }
       {if (true) throw (Error)jjte000;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
  }

  final public void opdStatement() throws ParseException {
 /*@bgen(jjtree) opdStatement */
  ASTopdStatement jjtn000 = new ASTopdStatement(this, JJTOPDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACKET);
      variable();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(EQ);
      jj_consume_token(OPD);
      jj_consume_token(51);
      Identifier();
      jj_consume_token(52);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void leftVariableList() throws ParseException {
                           /*@bgen(jjtree) leftVariableList */
  ASTleftVariableList jjtn000 = new ASTleftVariableList(this, JJTLEFTVARIABLELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFTBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        variable();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[9] = jj_gen;
            break label_6;
          }
          jj_consume_token(50);
          variable();
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      jj_consume_token(RIGHTBRACKET);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void rightVariableList() throws ParseException {
                            /*@bgen(jjtree) rightVariableList */
  ASTrightVariableList jjtn000 = new ASTrightVariableList(this, JJTRIGHTVARIABLELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(51);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        variable();
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[11] = jj_gen;
            break label_7;
          }
          jj_consume_token(50);
          variable();
        }
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void variable() throws ParseException {
 /*@bgen(jjtree) variable */
  ASTvariable jjtn000 = new ASTvariable(this, JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 51:
        jj_consume_token(51);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ADD:
        case SUB:
        case INTEGER_LITERAL:
        case IDENTIFIER:
          simpleExpression();
          label_8:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 50:
              ;
              break;
            default:
              jj_la1[13] = jj_gen;
              break label_8;
            }
            jj_consume_token(50);
            simpleExpression();
          }
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(52);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
           // Hack to avoid adding nodes to the parse tree.
           NilStatement nilStat = new NilStatement();
           jjtn000.setStatementNode( nilStat );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void condition() throws ParseException {
                    /*@bgen(jjtree) condition */
    ASTcondition jjtn000 = new ASTcondition(this, JJTCONDITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int relation;
    int numberOfChildern;
    SimpleNode node;
    String nodeName;
    try {
      complexExpression();
      relation = relational_operator();
      complexExpression();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            if ( numberOfChildern == 2 ) {
                Expression lhs =
                    ((ASTcomplexExpression)
                            jjtn000.jjtGetChild(0)).getLinearExp();
                Expression rhs =
                    ((ASTcomplexExpression)
                            jjtn000.jjtGetChild(1)).getLinearExp();;
                jjtn000.setLhsLinearExp( lhs );
                jjtn000.setRhsLinearExp( rhs );
                jjtn000.setRelation( relation );
            } else {
                {if (true) throw new ParseException(" --- CONDITION > 2 Elements ");}
}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public int relational_operator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
      jj_consume_token(EQ);
                            {if (true) return 1;}
      break;
    case NEQ:
      jj_consume_token(NEQ);
                            {if (true) return 2;}
      break;
    case LO:
      jj_consume_token(LO);
                            {if (true) return 3;}
      break;
    case LE:
      jj_consume_token(LE);
                            {if (true) return 4;}
      break;
    case GT:
      jj_consume_token(GT);
                            {if (true) return 5;}
      break;
    case GE:
      jj_consume_token(GE);
                            {if (true) return 6;}
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void simpleExpression() throws ParseException {
                          /*@bgen(jjtree) simpleExpression */
    ASTsimpleExpression jjtn000 = new ASTsimpleExpression(this, JJTSIMPLEEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int signValue;
    int numberOfChildern;
    SimpleNode node;
    String nodeName;
    LinTerm trm;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        sign();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      term();
      label_9:
      while (true) {
        if (jj_2_5(2)) {
          ;
        } else {
          break label_9;
        }
        linearOperator();
        term();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            signValue = 1;
            ArrayList termList = new ArrayList();
            for (int i=0;i<numberOfChildern;i++) {
                node = (SimpleNode) jjtn000.jjtGetChild(i);
                nodeName = node.toString();
                if (nodeName == "sign" ) {
                    signValue = ((ASTsign) node).getValue();
                }
                if (nodeName == "linearOperator" ) {
                    signValue = ((ASTlinearOperator) node).getValue();
                }
                if (nodeName == "term" ) {
                    trm = ((ASTterm) node).getTerm();
                    trm.setSign( signValue );
                    termList.add( trm );
                }
            }
            jjtn000.setLinearExp( termList );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void complexExpression() throws ParseException {
                            /*@bgen(jjtree) complexExpression */
    ASTcomplexExpression jjtn000 = new ASTcomplexExpression(this, JJTCOMPLEXEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int signValue;
    int numberOfChildern;
    SimpleNode node;
    String nodeName;
    LinTerm trm;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        sign();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      termOrOperator();
      label_10:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_10;
        }
        linearOperator();
        termOrOperator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            signValue = 1;
            ArrayList termList = new ArrayList();
            for (int i=0;i<numberOfChildern;i++) {
                node = (SimpleNode) jjtn000.jjtGetChild(i);
                nodeName = node.toString();
                // System.out.println(" -- Node: " + nodeName);
                if (nodeName == "sign" ) {
                    signValue = ((ASTsign) node).getValue();
                }
                if (nodeName == "linearOperator" ) {
                    signValue = ((ASTlinearOperator) node).getValue();
                }
                if (nodeName == "termOrOperator" ) {
                    trm = ((ASTtermOrOperator) node).getTerm();
                    trm.setSign( signValue );
                    termList.add( trm );
                }
            }
            jjtn000.setLinearExp( termList );
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void sign() throws ParseException {
               /*@bgen(jjtree) sign */
  ASTsign jjtn000 = new ASTsign(this, JJTSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
        jj_consume_token(ADD);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.setValue(  1 );
        break;
      case SUB:
        jj_consume_token(SUB);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.setValue( -1 );
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

  final public void linearOperator() throws ParseException {
                         /*@bgen(jjtree) linearOperator */
  ASTlinearOperator jjtn000 = new ASTlinearOperator(this, JJTLINEAROPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
        jj_consume_token(ADD);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.setValue(  1 );
        break;
      case SUB:
        jj_consume_token(SUB);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.setValue( -1 );
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

  final public void termOrOperator() throws ParseException {
                         /*@bgen(jjtree) termOrOperator */
  ASTtermOrOperator jjtn000 = new ASTtermOrOperator(this, JJTTERMOROPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_7(3)) {
        specialTerm();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            jjtn000.setTerm( ((ASTspecialTerm) jjtn000.jjtGetChild(0)).getTerm() );
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
          term();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            jjtn000.setTerm( ((ASTterm) jjtn000.jjtGetChild(0)).getTerm() );
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         {if (true) throw (RuntimeException)jjte000;}
       }
       if (jjte000 instanceof ParseException) {
         {if (true) throw (ParseException)jjte000;}
       }
       {if (true) throw (Error)jjte000;}
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
  }

  final public void specialTerm() throws ParseException {
                      /*@bgen(jjtree) specialTerm */
    ASTspecialTerm jjtn000 = new ASTspecialTerm(this, JJTSPECIALTERM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int num, den;
    LinTerm term;
    int numberOfChildren;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        fraction();
        jj_consume_token(MUL);
        specialOperator();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildren = jjtn000.jjtGetNumChildren();
            num = ((ASTfraction) jjtn000.jjtGetChild(0)).getNumerator();
            den = ((ASTfraction) jjtn000.jjtGetChild(0)).getDenominator();
            term = ((ASTspecialOperator) jjtn000.jjtGetChild(1)).getTerm();
            term.setNumerator( num );
            term.setDenominator( den );

            jjtn000.setTerm( term );
        break;
      case DIV:
      case MOD:
      case FLOOR:
      case CEIL:
      case MIN:
      case MAX:
        specialOperator();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            term = ((ASTspecialOperator) jjtn000.jjtGetChild(0)).getTerm();
            jjtn000.setTerm( term );
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void specialOperator() throws ParseException {
                          /*@bgen(jjtree) specialOperator */
    ASTspecialOperator jjtn000 = new ASTspecialOperator(this, JJTSPECIALOPERATOR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);LinTerm term = null;
    Expression exp = null;
    Expression exp1 = null;
    Expression exp2 = null;
    int div;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIV:
        jj_consume_token(DIV);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(50);
        Integer();
        jj_consume_token(52);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
              exp = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(0)).getLinearExp();
              div = ((ASTInteger) jjtn000.jjtGetChild(1)).getValue();
              term = new DivTerm(exp,div);
              jjtn000.setTerm( term );
        break;
      case MOD:
        jj_consume_token(MOD);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(50);
        Integer();
        jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            exp = ((ASTsimpleExpression)
                    jjtn000.jjtGetChild(0)).getLinearExp();
            div = ((ASTInteger) jjtn000.jjtGetChild(1)).getValue();
            term = new ModTerm(exp,div);
            jjtn000.setTerm( term );
        break;
      case FLOOR:
        jj_consume_token(FLOOR);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
              exp = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(0)).getLinearExp();
              term = new FloorTerm(exp);
              jjtn000.setTerm( term );
        break;
      case CEIL:
        jj_consume_token(CEIL);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
              exp = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(0)).getLinearExp();
              term = new CeilTerm(exp);
              jjtn000.setTerm( term );
        break;
      case MAX:
        jj_consume_token(MAX);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(50);
        simpleExpression();
        jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
              exp1 = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(0)).getLinearExp();
              exp2 = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(1)).getLinearExp();
              term = new MaximumTerm(exp1, exp2);
              jjtn000.setTerm( term );
        break;
      case MIN:
        jj_consume_token(MIN);
        jj_consume_token(51);
        simpleExpression();
        jj_consume_token(50);
        simpleExpression();
        jj_consume_token(52);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
              exp1 = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(0)).getLinearExp();
              exp2 = ((ASTsimpleExpression)
                      jjtn000.jjtGetChild(1)).getLinearExp();
              term = new MinimumTerm(exp1, exp2);
              jjtn000.setTerm( term );
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

  final public void term() throws ParseException {
               /*@bgen(jjtree) term */
    ASTterm jjtn000 = new ASTterm(this, JJTTERM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int num, den;
    String name;
    int numberOfChildern;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        fraction();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MUL:
          jj_consume_token(MUL);
          Identifier();
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            num = ((ASTfraction) jjtn000.jjtGetChild(0)).getNumerator();
            den = ((ASTfraction) jjtn000.jjtGetChild(0)).getDenominator();
            name = "";
            if ( numberOfChildern == 2 ) {
                name = ((ASTIdentifier) jjtn000.jjtGetChild(1)).getName();
            }
            jjtn000.setTerm( new LinTerm(num,den,name) );
        break;
      case IDENTIFIER:
        Identifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MUL:
          jj_consume_token(MUL);
          fraction();
          break;
        default:
          jj_la1[25] = jj_gen;
          ;
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            numberOfChildern = jjtn000.jjtGetNumChildren();
            name = ((ASTIdentifier) jjtn000.jjtGetChild(0)).getName();
            num = 1;
            den = 1;
            if ( numberOfChildern == 2 ) {
                num = ((ASTfraction) jjtn000.jjtGetChild(1)).getNumerator();
                den = ((ASTfraction) jjtn000.jjtGetChild(1)).getDenominator();
            }
            jjtn000.setTerm( new LinTerm(num,den,name));
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void fraction() throws ParseException {
                   /*@bgen(jjtree) fraction */
    ASTfraction jjtn000 = new ASTfraction(this, JJTFRACTION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);int num;
    int den;
    try {
      Integer();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FRACTION:
        jj_consume_token(FRACTION);
        Integer();
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
            int numberOfChildern = jjtn000.jjtGetNumChildren();
            if ( numberOfChildern == 1 ) {
                num = ((ASTInteger) jjtn000.jjtGetChild(0)).getValue();
                den = 1;
            } else {
                num = ((ASTInteger) jjtn000.jjtGetChild(0)).getValue();
                den = ((ASTInteger) jjtn000.jjtGetChild(1)).getValue();
            }
            jjtn000.setFraction(num,den);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Identifier() throws ParseException {
                     /*@bgen(jjtree) Identifier */
    ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                        jjtn000.setName( t.toString() );
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Integer() throws ParseException {
                  /*@bgen(jjtree) Integer */
    ASTInteger jjtn000 = new ASTInteger(this, JJTINTEGER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INTEGER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.setValue( t.toString() );
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(LO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(NEQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_18()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(SUB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(ADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(SUB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(ADD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(MIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(MATLABBEGIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MATLAB_COMMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(MAX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(FOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(CEIL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_53()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_42()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(FLOOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_15()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_52()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_11()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_35()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(FRACTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(DIV)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_13()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_3R_11()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_1()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(MUL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_63()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_64()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_15()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_24()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(LEFTBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RIGHTBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_62()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_16()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(MUL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MUL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_13()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(GE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(GT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(LE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public ParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  final private int[] jj_la1_0 = {0x1c000,0x1c000,0x1c000,0x20000018,0x20000018,0x18,0x20000018,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x300000,0x0,0x1f800000,0x300000,0x300000,0x300000,0x300000,0x0,0xde0,0xde0,0x40000,0x40000,0x0,0x80000,};
  final private int[] jj_la1_1 = {0x0,0x0,0x0,0x2,0x8002,0x0,0x8002,0x0,0x80000,0x40000,0x8000,0x40000,0x8000,0x40000,0x8800,0x80000,0x0,0x0,0x0,0x0,0x0,0x8800,0x800,0x0,0x0,0x0,0x8800,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[7];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[53];
    for (int i = 0; i < 53; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 7; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
