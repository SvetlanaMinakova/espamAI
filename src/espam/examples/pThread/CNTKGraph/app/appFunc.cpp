// File automatically generated by ESPAM

#include <stdlib.h>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "appFunc.h"
#include "dnnFunc.h"
#include <cstddef>
using namespace std;

appFunc::appFunc() {}
appFunc::~appFunc() {}

// get fifo buffer by src
fifo_buf* appFunc::get_buf_by_src (std::string name, std::vector<fifo_buf>& fifos){
  for (auto & fifos_elem: fifos)  {
    if (name.compare(fifos_elem.src) == 0)
      return &fifos_elem;
    }
    return nullptr;
}

// get fifo buffer by dst
fifo_buf* appFunc::get_buf_by_dst (std::string name, std::vector<fifo_buf>& fifos){
  for (auto & fifos_elem: fifos)  {
    if (name.compare(fifos_elem.dst) == 0)
      return &fifos_elem;
    }
    return nullptr;
}

// Execution function primitive
   void appFunc::execute (std::string function)
    {
      // cout<<function<<endl;
    }
   void appFunc::execute (std::string function,int* input, int* weights, int* output, std::map<std::string,int>* int_params_ptr )
    {
	   if (function.find("CONV") != std::string::npos){
		   execute_conv(input, weights, output,int_params_ptr);
	   }

	   if (function.find("DENSEBLOCK") != std::string::npos){
		   execute_dense_block(function,input, weights, output,int_params_ptr);

	   }
      // cout<<function<<endl;
    }



   void appFunc::execute_dense_block (std::string function,int* input, int* weights, int* output, std::map<std::string,int>* int_params_ptr ){
	   int input_len = 1;
	   for(int i=0; i<int_params_ptr->at("input_dims");i++)
		  input_len *= int_params_ptr->at(("input_dim_"+std::to_string(i)));
	   // cout<<"SM input_len= "<<input_len;


	   /** TODO extend by any NonLinear function, not only softmax*/
	   if (function.find("SOFTMAX") != std::string::npos)
		   dnnFunc::softmax(input, input_len);

	   //::weight_and_sum(int *input, int *weights, int *result, int input_len){
	   dnnFunc::weight_and_sum(input, weights, output, input_len);

   }



   void appFunc::execute_conv (int* input, int* weights, int* output, std::map<std::string,int>* int_params_ptr )
       {



   		   int stride;
   		   int k_h;
   		   int k_w;
   		   int channels;
   		   int neurons;
   		   int input_h;
   		   int input_w;
   		   int output_d;
   		   int output_h;
   		   int output_w;

   		   k_h = int_params_ptr->at("k_h");
   		   k_w = int_params_ptr->at("k_w");
   		   stride =  int_params_ptr->at("stride");
   		   neurons =  int_params_ptr->at("neurons");

   		 //  cout<<"neurons: "<<*neurons;

   		   if(int_params_ptr->at("output_dims")==2){
   			   output_h = int_params_ptr->at("output_dim_0");
   			   output_w = int_params_ptr->at("output_dim_1");
   		   }
   		   else
   		   {
   			   output_h = int_params_ptr->at("output_dim_1");
   			   output_w = int_params_ptr->at("output_dim_2");
   		   }


   		 //  cout<<"output_h = "<<output_h<<endl;

   		   /** conv over 2d input*/
   		   if(int_params_ptr->at("input_dims")==2){
   			   input_h = int_params_ptr->at("input_dim_0");
   			   input_w = int_params_ptr->at("input_dim_1");

   			 // accumulate values in in output matrix
   			 dnnFunc::convolution_2d_inp(input, weights, output, input_h, input_w, output_h, output_w, k_h, k_w, stride);
   			 return;
   		   }

   		   /** conv over 3d input:
   		    * 1. Conv over every spatial dimension
   		    * 2. element-wise summ of spatial dimensions
   		    * */
   		   if(int_params_ptr->at("input_dims")==3){

   			    input_h = int_params_ptr->at("input_dim_1");
   			    input_w = int_params_ptr->at("input_dim_2");
   			    channels = int_params_ptr->at("input_dim_0");
   			 //   cout<<"Conv3D!"<<endl;
   			 //   cout<<"channels = "<<*(channels)<<" neurons = "<<*(output_d);

   			    /**
   			     * (int *input, int *kernel, int *output, int channels, int neurons, int input_h, int input_w,
		int output_h,int output_w, int k_h, int k_w, int stride)
   			     *
   			     *
   			     */
   			dnnFunc::convolution_3d_inp(input,weights,output,
   			      		channels,input_h, input_w, output_h, output_w, k_h, k_w, stride);
   				}

         // cout<<function<<endl;
       }







// Data shift function (for shifting overlapping data in I/O arrays)
  /**
    * copies 2D-data line from src to dst.
    * data_h - src data height
    * data_w - src data width
    * src - pointer to first data source array element
    * dst - pointer to first copy destination array element
  */
   void appFunc::cpy_2D_data_line(const int &data_w, int *src,int *dst, const int &line_id)
    {
      int line_start = line_id * data_w;
      for (int i = 0; i < data_w ; i++)
        dst[i] = src[line_start];
    }
  /**
    * copies 2D-data line from src to dst.
    * data_h - src data height
    * data_w - src data width
    * src - pointer to first data source array element
    * dst - pointer to first copy destination array element
  */
   void appFunc::cpy_2D_data_line(const int &data_w, float *src,float *dst, const int &line_id)
    {
      int line_start = line_id * data_w;
      for (int i = 0; i < data_w ; i++)
        dst[i] = src[line_start];
    }
  /**
    * Moves 2D data on n lines to top.
    * Required for overlapping data.
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_2D (const int &h, const int &w, int *x, const int &stride)
    {
      for(int line_ind = stride; line_ind < w ; line_ind ++){
        for(int i=0; i<w; i++)
          x[i + (line_ind - stride)* w] = x[i + line_ind * w];
        }
    }
  /**
    * Moves 3D data on n lines to top.
    * Required for overlapping data.
    * d - array depth
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_3D (const int &d, const int &h, const int &w, int *x, const int &stride)
    {
    /*  int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        for(int line_ind = stride; line_ind < w ; line_ind ++){
          for(int i=0; i<w; i++)
            x[i + (line_ind - stride)* w + start_elem_id] = x[i + line_ind * w + start_elem_id];
          }
        start_elem_id +=w*h;
      } */
    }
  /**
    * Moves 2D data on n lines to top.
    * Required for overlapping data.
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_2D (const int &h, const int &w, float *x, const int &stride)
    {
      for(int line_ind = stride; line_ind < w ; line_ind ++){
        for(int i=0; i<w; i++)
          x[i + (line_ind - stride)* w] = x[i + line_ind * w];
        }
    }
  /**
    * Moves 3D data on n lines to top.
    * Required for overlapping data.
    * d - array depth
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_3D (const int &d, const int &h, const int &w, float *x, const int &stride)
    {
   /*   int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        for(int line_ind = stride; line_ind < w ; line_ind ++){
          for(int i=0; i<w; i++)
            x[i + (line_ind - stride)* w + start_elem_id] = x[i + line_ind * w + start_elem_id];
          }
        start_elem_id +=w*h;
      }*/
    }
  //2D array print function, type: int
   void appFunc::print_2D(const int &h, const int &w, int *x)
    {
      for (int i = 0; i < h; i++){
        for (int j = 0; j < w ; j++)
          std::cout << x[i * w + j] << ' ';
        std::cout<<endl;
      }
    }
  //3D array print function, type: int
   void appFunc::print_3D(const int &d, const int &h, const int &w, int *x)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        std::cout<<"depth"<<depth<<endl;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
    }
  //2D array print function, type: float
   void appFunc::print_2D(const int &h, const int &w, float *x)
    {
      for (int i = 0; i < h; i++){
        for (int j = 0; j < w ; j++)
          std::cout << x[i * w + j] << ' ';
        std::cout<<endl;
      }
    }
  //3D array print function, type: float
   void appFunc::print_3D(const int &d, const int &h, const int &w, float *x)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        std::cout<<"depth"<<depth<<endl;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
    }
