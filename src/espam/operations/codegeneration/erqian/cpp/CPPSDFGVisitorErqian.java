package espam.operations.codegeneration.erqian.cpp;

import espam.datamodel.graph.csdf.CSDFGraph;
import espam.datamodel.graph.csdf.CSDFNode;
import espam.datamodel.graph.csdf.CSDFPort;
import espam.datamodel.graph.csdf.datasctructures.MemoryUnit;
import espam.operations.codegeneration.sesame.cpp.CPPSDFGVisitor;
import espam.utils.fileworker.FileWorker;

import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;

public class CPPSDFGVisitorErqian extends CPPSDFGVisitor {
    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///


    /**
     * generate main class template contains R/W primitives description
     * and other common stuff.
     */
    public void generateMainClassTemplate(String dir, CSDFGraph sdfg){
        try {
            _printStream = FileWorker.openFile(dir, _mainClassName, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("");
            _addAllClassesHeaders(sdfg);
            _writeMainClassCPPBeginning();
            _writeNoBaseCppConstructorAndDestructor(_mainClassName);
            _writeMainClassFunctions(sdfg);
            _printStream.close();
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

     /**
     * generate main class template contains R/W primnitives description
     * and other common stuff.
     */
    public void generateBaseClassTemplate(String dir){
        try {
            String className = "csdfNode";
            _printStream = FileWorker.openFile(dir, className, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("#include \"" + _baseClassName + ".h\"");
            _writeNoBaseCppConstructorAndDestructor(_baseClassName);
            _printStream.println("//virtual main function");
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

    /**
     * Write common beginning for all generated nodes, contains:
     *  - definition of header
     *  - definition of standard libraries
     *  - definition of namespace
     * @param className name of the .cpp class
     */
    @Override
    protected void _writeCommonCppBeginning(String className){
        _printStream.println("// File automatically generated by ESPAM");
        _printStream.println("");
         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include \""+ className + ".h\"");
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include \"" + _baseClassName + ".h\"");
        _printStream.println("#include \""+_mainClassName+".h\"");
        //include null
        _printStream.println("#include <cstddef>");
        _printStream.println("using namespace std;");
        _printStream.println("");
    }

    /**
     * Write application main class .cpp beginning
     */
    protected void _writeMainClassCPPBeginning(){

         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include <map>");
        _printStream.println("#include <vector>");
        _printStream.println("#include \"" + _baseClassName + ".h\"");
        _printStream.println("#include \""+_mainClassName+".h\"");

        /** include existing primitives definition*/
       // _printStream.println("#include \"fifo.h\"");
        _printStream.println("using namespace std;");
        _printStream.println("");
    }

    /**
     * TODO refactoring on idea
     * mention all available nodes
     */
    protected void  _addAllClassesHeaders(CSDFGraph csdfG){
         Iterator i = csdfG.getNodeList().iterator();
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            _printStream.println("#include \""+ node.getName() + ".h\"");
        }
    }



    /**
     * Write application main class .cpp beginning
     */
    protected void _writeMainClassFunctions(CSDFGraph csdfG){
        _printStream.println("// Main function");
        _writeMainClassMain(csdfG);
    //    _printStream.println("// Call of the specific node ");
    //    _prefixInc();
    //    _printStream.println(_prefix + "void " + _mainClassName + "::run_node(string node_name) { }");
    //    _prefixDec();
        _printStream.println();
        _printStream.println(_prefix + "// Read/Write primitives");
        prefixInc();
        _writeRWPrimitives();
        prefixDec();
        _printStream.println("");
        _printStream.println(_prefix + "// Execution function primitive");
        prefixInc();
        _writeExecPrimitive();
        prefixDec();
        _printStream.println("");
        _printStream.println(_prefix + "// Data shift function (for shifting overlapping data in I/O arrays)");
        prefixInc();
        _writeShiftFunction();
        prefixDec();
    }

    /**
     * Write main function of the main class
     */
    protected void _writeMainClassMain(CSDFGraph csdfg){
        _prefixInc();
        _printStream.println(_prefix + "int main()");
        prefixInc();
        //open main function
         _printStream.println(_prefix + "{");
         prefixInc();
         _printStream.println(_prefix + "// list of all available nodes");
         _printStream.println(_prefix + "std::map< std::string, "+ _baseClassName +
                 "* > nodes = std::map< std::string," + _baseClassName + "* >();");
         _createAllClassesInstancesAndRefs(csdfg);
         _printStream.println("");
         _writeSchedule();
         _printStream.println("");
         _printStream.println(_prefix + "// Call dnn nodes according to the schedule ");
         _callNodesInScheduleOrder();
         _printStream.println("");
         _printStream.println(_prefix + "return 0;");
         prefixDec();
         //close main function
         _printStream.println(_prefix + "}");
         prefixDec();
        _prefixDec();
        //
    }

      /**
     * TODO refactoring on idea
     * Create instances of all node and references on them
     * @param csdfG csdf graph
     */
    protected void _createAllClassesInstancesAndRefs(CSDFGraph csdfG){
        Iterator i = csdfG.getNodeList().iterator();
        String nodename;
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            nodename = node.getName();
            _printStream.println(_prefix + nodename + " " + nodename + "_instance = " + nodename + "();");
            _printStream.println(_prefix + "nodes[\"" + nodename + "\"] = &" + nodename + "_instance;");
        }

    }

    /**
     //define schedule - LB: layers in traverse order
	   //NB : neurons of one layer can run in parallel?

     */
    protected void _writeSchedule(){
        _printStream.println(_prefix + "/**");
        prefixInc();
        _printStream.println(_prefix + "Define schedule ");
        _printStream.println(_prefix + "Dummy schedule for LB-mode: layers in traverse order");
        _printStream.println(_prefix + "Dummy schedule for NB-mode: neurons of one layer can run in parallel");
        prefixDec();
        _printStream.println(_prefix + "*/");
        _printStream.println(_prefix + "vector<std::string> schedule = vector<std::string>();");
        _printStream.println("");
        //
        if(_isScheduleNullOrEmpty())
            _processNullSchedule();

        else {
            for (String nodeCall : _schedule)
                _printStream.println(_prefix + "schedule.push_back(\"" + nodeCall + "\");");
        }

    }

    /**
     * Checks if schedule is null or empty
     * @return true, if schedule is null or empty and false otherwise
     */
    private boolean _isScheduleNullOrEmpty(){
        if(_schedule==null)
            return true;
        if(_schedule.size()==0)
            return true;
        return false;
    }

    /**
     * Process null schedule in generated .cpp - code
     */
    private void _processNullSchedule(){
        _printStream.println(_prefix + "//WARNING: Please, write CSDF graph schedule here using schedule.push_back(\"node_name\");");
        _printStream.println(_prefix + "cout<<\"WARNING: CSDF graph schedule is undefined.\"<<endl<<\"Please, write schedule manually in appMain.main()\";");
    }

    /**
     * Call dnn nodes according to schedule
     */
    protected void _callNodesInScheduleOrder(){
        _printStream.println(_prefix + "for(int i=0; i<schedule.size();i++){");
        prefixInc();
        _printStream.println(_prefix + "nodes[schedule.at(i)]->main();");
        prefixDec();
        _printStream.println(_prefix + "}");
    }


    /**
     * Write shift function (for shifting overlapping data in I/O arrays)"
     * TODO implement shift function
     */
    protected void _writeShiftFunction(){
        _printStream.println(_prefix + " void " + _mainClassName + "::data_shift(void *array, int dim) {   }");
    }

    /**
     * Write r/w primitive functions templates
     */
    protected void _writeRWPrimitives(){
        for (int dim=1;dim <=_maxPrimitiveDimensionality; dim++){
         _writeMocRWPrimitive("read"+ _externalRWPostfix ,dim);
         _writeMocRWPrimitive("write"+ _externalRWPostfix ,dim);
         _writeMocRWPrimitive("read" + _internalRWPostfix ,dim);
         _writeMocRWPrimitive("write" + _internalRWPostfix,dim);
        }
    }

    /**
     *
     * @param primitiveName
     */
    private void _writeMocRWPrimitive(String primitiveName, int dim){
        _printStream.println(_prefix + " void " + _mainClassName +
                    "::" + primitiveName +"_"+ dim + "D " +
                    "(void* fifo, void* memobj_cpu, int len, int fifo_size)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "cout<<\"" + primitiveName + "(\"<<len<<\" tokens)\"<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
        _printStream.println(" ");
    }

    /**
     * Write execution function primitive
     */

    //;
    protected void _writeExecPrimitive(){
        _printStream.println(_prefix + " void " + _mainClassName +
                    "::execute (std::string function)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "cout<<function<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }

    /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    @Override
    protected void  _writeCppConstructorAndDestructor(String className, String baseClassName){
        _printStream.println(className + "::" + className + "() : " + _baseClassName + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }
     /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    protected void  _writeNoBaseCppConstructorAndDestructor(String className){
        _printStream.println(className + "::" + className + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }

    /**
     * process exec function with default name
     * @param node CSDF node
     */
    @Override
    protected void _processExecution(CSDFNode node){
        _processExecution(node,_mainClassName + "::execute");
    }

     /**
     * print reading template
     * @param port SDF input port
     */
     @Override
      public void printReadTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
        if(port.getStartTokens()==null) {
         //   if(port.isOverlapHandler())
           //     printOperationTemplate(port, "read" + _internalRWPostfix,arrayName);
          //  else
            _printStream.println(_prefix + "//TODO replace NULL by shared memory object");
            printOperationTemplate(port, "read" + _externalRWPostfix,arrayName);
            return;
        }
        String shiftDesc = port.getName() + "_shift";
        printOperationShiftedTemplate(port,"read" + _internalRWPostfix,arrayName,shiftDesc);
    }

    /**
     * Print write template
     * @param port CSDF port performs writing
     */
    public void printWriteTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
        if(port.isOverlapHandler()) {
            printOperationTemplate(port, "write" + _internalRWPostfix, arrayName);
        }
        else {
            _printStream.println(_prefix + "//TODO replace NULL by shared memory object");
            printOperationTemplate(port, "write" + _externalRWPostfix, arrayName);
        }
    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     * R/W primitive parameters:
     * 1. fifo: reference on destination array (name of CSDF node input port array) or FIFO
     * 2. memobj_cpu : reference on source array (default value, stored in header)
     * 3. len - number of tokens to be transferred
     * 4. fifo_size - total fifo size (const value, stored in header)
      * */
     @Override
    public void printOperationTemplate(CSDFPort port,String operation, String arrayName){
       if(port==null || arrayName==null)
           return;
        int dataDimensionality = port.getMemoryDim();
        String portName = port.getName();
        String memobj_cpu = "NULL";
        if(operation.contains(_internalRWPostfix))
            memobj_cpu = arrayName;

        _printStream.println(" ");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
        _printStream.println(_prefix + _mainClassName + "::"+ operation + "_" + dataDimensionality + "D (" + arrayName + ", " +
                memobj_cpu +", " + portName + "_tokens, " + portName + "_fifo_size);");

    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     */
     @Override
    public void printOperationShiftedTemplate(CSDFPort port,String operation, String arrayName, String shiftDesc){
       if(port==null || arrayName==null)
           return;
        int dataDimensionality = port.getMemoryDim();
        String portName = port.getName();
        String memobj_cpu = arrayName;

        _printStream.println(" ");
        _printStream.println(_prefix + "//TODO replace internal r/w by overlapping data shift operation");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
        _printStream.println(_prefix + _mainClassName + "::" + operation + "_" + dataDimensionality + "D (" + arrayName + "" +
                "[" + shiftDesc + "], " + memobj_cpu + ", " + portName + "_tokens, " + portName + "_fifo_size);");
    }

    /**
     * Set csdfg schedule
     * CSDFG nodes schedule : get from the repetition vector of CSDFG??
     * @param schedule CSDFG nodes schedule : get from the repetition vector of CSDFG??
     */
    public void setSchedule(Vector<String> schedule){
        _schedule = schedule;
    }

    ///////////////////////////////////////////////////////////////////
    ///                private variables                           ///

    /** primitive postfix*/
    private static String _externalRWPostfix = "SWF_CPU";

    /** primitive postfix*/
    private static String _internalRWPostfix = "_Internal";

    /** application main class name*/
    private static String _mainClassName = "appMain";

    /** CSDF graph node base class*/
    private static String _baseClassName = "csdfNode";

    /** max r/w primitives dimensionality */
    private static int _maxPrimitiveDimensionality = 3;

    /** CSDFG nodes schedule : get from the repetition vector of CSDFG??*/
    Vector<String> _schedule;

    /** TODO shift primitive???*/

}
