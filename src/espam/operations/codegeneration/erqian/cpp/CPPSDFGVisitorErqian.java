package espam.operations.codegeneration.erqian.cpp;

import espam.datamodel.graph.csdf.CSDFGraph;
import espam.datamodel.graph.csdf.CSDFNode;
import espam.datamodel.graph.csdf.CSDFPort;
import espam.datamodel.graph.csdf.datasctructures.MemoryUnit;
import espam.operations.codegeneration.sesame.cpp.CPPSDFGVisitor;
import espam.utils.fileworker.FileWorker;

import java.io.PrintStream;
import java.util.Iterator;
import java.util.Vector;

public class CPPSDFGVisitorErqian extends CPPSDFGVisitor {
    ///////////////////////////////////////////////////////////////////
    ////                         public methods                     ///

    /**
     * generate main class template contains R/W primnitives description
     * and other common stuff.
     */
    public void generateMainClassTemplate(String dir, CSDFGraph sdfg){
        try {
            _printStream = FileWorker.openFile(dir, _mainClassName, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("");
            _addAllClassesHeaders(sdfg);
            _writeMainClassCPPBeginning();
            _writeNoBaseCppConstructorAndDestructor(_mainClassName);
            _writeMainClassFunctions();
            _printStream.close();
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

     /**
     * generate main class template contains R/W primnitives description
     * and other common stuff.
     */
    public void generateBaseClassTemplate(String dir){
        try {
            String className = "csdfNode";
            _printStream = FileWorker.openFile(dir, className, "cpp");
            _printStream.println("// File automatically generated by ESPAM");
            _printStream.println("#include \"" + _baseClassName + ".h\"");
            _writeNoBaseCppConstructorAndDestructor(_baseClassName);
            _printStream.println("//virtual main function");
        }
        catch (Exception e){
            System.err.println(".cpp file creation error for " + _mainClassName + " " + e.getMessage());
        }
    }

    /**
     * Write common beginning for all generated nodes, contains:
     *  - definition of header
     *  - definition of standard libraries
     *  - definition of namespace
     * @param className name of the .cpp class
     */
    @Override
    protected void _writeCommonCppBeginning(String className){
        _printStream.println("// File automatically generated by ESPAM");
        _printStream.println("");
         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include \""+ className + ".h\"");
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        _printStream.println("#include \"" + _baseClassName + ".h\"");
        _printStream.println("#include \""+_mainClassName+".h\"");
        //include null
        _printStream.println("#include <cstddef>");
        _printStream.println("using namespace std;");
        _printStream.println("");
    }

    /**
     * Write application main class .cpp beginning
     */
    protected void _writeMainClassCPPBeginning(){

         /** TODO: should I define any libraries in here?? Or they will
          * TODO be copied from the graphName.so file?*/
        _printStream.println("#include \""+ _mainClassName + ".h\"");
        _printStream.println("#include <stdlib.h>");
        _printStream.println("#include <iostream>");
        /** include existing primitives definition*/
       // _printStream.println("#include \"fifo.h\"");
        _printStream.println("using namespace std;");
        _printStream.println("");
    }

    /**
     * TODO refactoring on idea
     * mention all available nodes
     */
    protected void  _addAllClassesHeaders(CSDFGraph csdfG){
         Iterator i = csdfG.getNodeList().iterator();
        while (i.hasNext()) {
            CSDFNode node = (CSDFNode) i.next();
            _printStream.println("#include \""+ node.getName() + ".h\"");
        }
    }

    /**
     * TODO refactoring on idea
     *
     * @param csdfG
     */
    protected void _createAllClassesInstances(CSDFGraph csdfG){

    }


    /**
     * Write application main class .cpp beginning
     */
    protected void _writeMainClassFunctions(){
        _printStream.println("// Main function");
        _prefixInc();
        _printStream.println(_prefix + "void " + _mainClassName + "::main() {   }");
        _prefixDec();
        _printStream.println("// Call of the specific node ");
        _prefixInc();
        _printStream.println(_prefix + "void " + _mainClassName + "::run_node(string node_name) { }");
        _prefixDec();
        _printStream.println();
        _printStream.println(_prefix + "// Read/Write primitives");
        prefixInc();
        _writeRWPrimitives();
        prefixDec();
        _printStream.println("");
        _printStream.println(_prefix + "// Execution function primitive");
        prefixInc();
        _writeExecPrimitive();
        prefixDec();
        _printStream.println("");
        _printStream.println(_prefix + "// Data shift function (for shifting overlapping data in I/O arrays)");
        prefixInc();
        _writeShiftFunction();
        prefixDec();
    }

    /**
     * Write shift function (for shifting overlapping data in I/O arrays)"
     * TODO implement shift function
     */
    protected void _writeShiftFunction(){
        _printStream.println(_prefix + " void " + _mainClassName + "::data_shift(void *array, int dim) {   }");
    }

    /**
     * Write r/w primitive functions templates
     */
    protected void _writeRWPrimitives(){
        for (int dim=1;dim <=_maxPrimitiveDimensionality; dim++){
         _writeMocRWPrimitive("read"+ _externalRWPostfix ,dim);
         _writeMocRWPrimitive("write"+ _externalRWPostfix ,dim);
         _writeMocRWPrimitive("read" + _internalRWPostfix ,dim);
         _writeMocRWPrimitive("write" + _internalRWPostfix,dim);
        }
    }

    /**
     *
     * @param primitiveName
     */
    private void _writeMocRWPrimitive(String primitiveName, int dim){
        _printStream.println(_prefix + " void " + _mainClassName +
                    "::" + primitiveName +"_"+ dim + "D " +
                    "(void* fifo, void* memobj_cpu, int len, int fifo_size)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "cout<<\"" + primitiveName + "(\"<<len<<\" tokens)\"<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
        _printStream.println(" ");
    }

    /**
     * Write execution function primitive
     */

    //;
    protected void _writeExecPrimitive(){
        _printStream.println(_prefix + " void " + _mainClassName +
                    "::execute (std::string function)");
        prefixInc();
        _printStream.println(_prefix + "{");
        prefixInc();
        _printStream.println(_prefix + "cout<<function<<endl;");
        prefixDec();
        _printStream.println(_prefix + "}");
        prefixDec();
    }

    /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    @Override
    protected void  _writeCppConstructorAndDestructor(String className, String baseClassName){
        _printStream.println(className + "::" + className + "() : " + _baseClassName + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }
     /**
     * Write constructor and destructor .cpp definitions
     * @param className name of the .cpp class
     */
    protected void  _writeNoBaseCppConstructorAndDestructor(String className){
        _printStream.println(className + "::" + className + "() {}");
        _printStream.println(className + "::~" + className + "() {}");
        _printStream.println("");
    }

    /**
     * process exec function with default name
     * @param node CSDF node
     */
    @Override
    protected void _processExecution(CSDFNode node){
        _processExecution(node,_mainClassName + "::execute");
    }

     /**
     * print reading template
     * @param port SDF input port
     */
     @Override
      public void printReadTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
        if(port.getStartTokens()==null) {
         //   if(port.isOverlapHandler())
           //     printOperationTemplate(port, "read" + _internalRWPostfix,arrayName);
          //  else
            _printStream.println(_prefix + "//TODO replace NULL by shared memory object");
            printOperationTemplate(port, "read" + _externalRWPostfix,arrayName);
            return;
        }
        String shiftDesc = port.getName() + "_shift";
        printOperationShiftedTemplate(port,"read" + _internalRWPostfix,arrayName,shiftDesc);
    }

    /**
     * Print write template
     * @param port CSDF port performs writing
     */
    public void printWriteTemplate(CSDFPort port) {
        String arrayName = port.getAssignedMemoryName();
        if(port.isOverlapHandler()) {
            printOperationTemplate(port, "write" + _internalRWPostfix, arrayName);
        }
        else {
            _printStream.println(_prefix + "//TODO replace NULL by shared memory object");
            printOperationTemplate(port, "write" + _externalRWPostfix, arrayName);
        }
    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     * R/W primitive parameters:
     * 1. fifo: reference on destination array (name of CSDF node input port array) or FIFO
     * 2. memobj_cpu : reference on source array (default value, stored in header)
     * 3. len - number of tokens to be transferred
     * 4. fifo_size - total fifo size (const value, stored in header)
      * */
     @Override
    public void printOperationTemplate(CSDFPort port,String operation, String arrayName){
       if(port==null || arrayName==null)
           return;
        int dataDimensionality = port.getMemoryDim();
        String portName = port.getName();
        String memobj_cpu = "NULL";
        if(operation.contains(_internalRWPostfix))
            memobj_cpu = arrayName;

        _printStream.println(" ");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
        _printStream.println(_prefix + _mainClassName + "::"+ operation + "_" + dataDimensionality + "D (" + arrayName + ", " +
                memobj_cpu +", " + portName + "_tokens, " + portName + "_fifo_size);");

    }

     /**
     * print reading/writing template for port,
     * taking into account only end border limitations
     */
     @Override
    public void printOperationShiftedTemplate(CSDFPort port,String operation, String arrayName, String shiftDesc){
       if(port==null || arrayName==null)
           return;
        int dataDimensionality = port.getMemoryDim();
        String portName = port.getName();
        String memobj_cpu = arrayName;

        _printStream.println(" ");
        _printStream.println(_prefix + "//TODO replace internal r/w by overlapping data shift operation");
        _printStream.println(_prefix + "// " + operation + " to " + arrayName);
        _printStream.println(_prefix + _mainClassName + "::" + operation + "_" + dataDimensionality + "D (" + arrayName + "" +
                "[" + shiftDesc + "], " + memobj_cpu + ", " + portName + "_tokens, " + portName + "_fifo_size);");
    }


    ///////////////////////////////////////////////////////////////////
    ///                private variables                           ///

    /** primitive postfix*/
    private static String _externalRWPostfix = "SWF_CPU";

    /** primitive postfix*/
    private static String _internalRWPostfix = "_Internal";

    /** application main class name*/
    private static String _mainClassName = "appMain";

    /** CSDF graph node base class*/
    private static String _baseClassName = "csdfNode";

    /** max r/w primitives dimensionality */
    private static int _maxPrimitiveDimensionality = 3;


    /** TODO shift primitive???*/

}
