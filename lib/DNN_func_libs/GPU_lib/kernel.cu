// File automatically generated by ESPAM

#include <stdio.h>
#include <cuda.h>
#include <iostream>


#include <cuda_runtime.h>
#include <helper_functions.h>
#include <helper_cuda.h>

using namespace std;



int iDivUp (int a, int b) { 
    return (a % b != 0) ? (a / b + 1) : (a / b);
} 




__global__ void kernel_3d(float *input, float *weights, float *output, float *bias, int channels, int input_h, int input_w, int output_d, int output_h, int output_w, int k_h, int k_w, int stride) {


  float fold_cell = 0;
  int input_elem_ind = 0;
  int k_elem_ind = 0;
  int k_elem_ind_reverse = 0;
  int k_size = k_h*k_w;
  int outp_elem_ind =0;
  int sub_kern_start = 0;

  float *sub_input;
  float *sub_output;
  float *sub_kernel;

  int i= blockIdx.x * blockDim.x + threadIdx.x;
  int j= blockIdx.y * blockDim.y + threadIdx.y;
  int ofm= blockIdx.z * blockDim.z + threadIdx.z;

//for (int ofm=0; ofm<output_d;ofm++){
  
  sub_output = output + output_w * output_h * ofm;
  for (int ifm=0; ifm<channels;ifm++){

    sub_input = input + input_w * input_h * ifm;
    sub_kern_start =  k_h * k_w * ifm + k_h * k_w * channels * ofm;
    //if(channels!=1){
    //std::cout<<"sub_k_start: "<<sub_kern_start<<std::endl;
//}
    sub_kernel = weights + sub_kern_start;



//     for (int j = 0; j < output_h; j++){
//     for (int i = 0; i < output_w; i++){

    	//std::cout<<std::endl<<std::endl<<"out["<<i<<"]["<<j<<"]"<<std::endl;

        fold_cell = 0;
         //summ k,l
        for (int l = 0; l < k_h; l++){
          for (int k = 0; k < k_w; k++){
            k_elem_ind = l + k * k_h;
            k_elem_ind_reverse = k_size - k_elem_ind - 1;
            input_elem_ind = (j*stride+l) + (i*stride+k)* input_w;
             fold_cell += *(sub_input + input_elem_ind) * *(sub_kernel + k_elem_ind);
          }
        }
        outp_elem_ind = i * output_w + j;
        sub_output[outp_elem_ind] += fold_cell;
        fold_cell = 0;
}
//}
//}
//}
}


 void print_2D(const int &h, const int &w, float *x)
    {
      int start_elem_id = 0;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
 




 void print_3D(const int &d, const int &h, const int &w, float *x)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        std::cout<<"depth"<<depth<<endl;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
    }




void kernelhost_3d(float *input, float *weights, float *output, float *bias, int channels, int input_h, int input_w, int output_d, int output_h, int output_w, int k_h, int k_w, int stride, int blocksize){

// printf("kernelhost_3d is executing..............\n");

 	 //init output
	  if(bias==NULL){
	    for (int i = 0; i < output_d * output_h * output_w; i++)
	      output[i] = 0;
	    }
	  else {
	    float bias_val;
	    for (int d = 0; d < output_d; d++) {
	      bias_val = bias[d];
	      //std::cout<<" d: "<<d <<" ,bias_val "<<bias_val<<" ";
	      for (int i = 0; i < output_w * output_h; i++)
	        output[i + d * output_w * output_h] = bias_val;
	      }
	    }




        //allocate memory
		int N_input = input_h * input_w * channels;
		int N_weights = k_h * k_w * output_d * channels;
		int N_output = output_d * output_h * output_w;

        float *d_input, *d_weights, *d_output;
		cudaMalloc(&d_input, N_input*sizeof(float));
		cudaMalloc(&d_weights, N_weights*sizeof(float));
		cudaMalloc(&d_output, N_output*sizeof(float));

		checkCudaErrors(cudaMemcpy(d_input, input, N_input*sizeof(float), cudaMemcpyHostToDevice));
		checkCudaErrors(cudaMemcpy(d_weights, weights, N_weights*sizeof(float), cudaMemcpyHostToDevice));
		checkCudaErrors(cudaMemcpy(d_output, output, N_output*sizeof(float), cudaMemcpyHostToDevice));

       int blockW=blocksize, blockH=blocksize, blockD;
      int count_d=0, n_d=0, maxn=30;
       int approximate_d[maxn];




       while(count_d<=output_d){
         if(output_d%count_d == 0){
         approximate_d[n_d++]=count_d;
            }
          count_d++; 
          }
         if(n_d%2==0){
         blockD=approximate_d[n_d/2-1];
       }else{
         blockD=approximate_d[(n_d-1)/2];
       }  
       
//       printf("blockW=%d\n", blockW);
//       printf("blockH=%d\n", blockH);





		dim3 dimBlock(blockW, blockH, blockD);
    		dim3 dimGrid(iDivUp(output_w, dimBlock.x), iDivUp(output_h, dimBlock.y), iDivUp(output_d, dimBlock.z));
                //cout<<"iDivUp(output_w, dimBlock.x)="<<iDivUp(output_w, dimBlock.x)<<endl;
		//cout<<"iDivUp(output_h, dimBlock.y)="<<iDivUp(output_h, dimBlock.y)<<endl;
		kernel_3d<<<dimGrid, dimBlock>>>(d_input, d_weights, d_output, bias, channels, input_h, input_w, output_d, output_h, output_w, k_h, k_w, stride);

		cudaDeviceSynchronize();

		checkCudaErrors(cudaMemcpy(output, d_output, N_output*sizeof(float), cudaMemcpyDeviceToHost));
     //	  cout<<"after computation:"<<endl;
     //	  print_3D(output_d, output_h, output_w, output);

		cudaFree(d_input);
		cudaFree(d_weights);
		cudaFree(d_output);


}
