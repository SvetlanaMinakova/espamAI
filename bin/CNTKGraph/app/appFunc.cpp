// File automatically generated by ESPAM

#include <stdlib.h>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "appFunc.h"
#include "dnnFunc.h"
#include "types.h"
#include <cstddef>
using namespace std;

appFunc::appFunc() {}
appFunc::~appFunc() {}

// Execution function primitive

  /**Write execution function primitive simplest MoC 
  (only function name is a parameter)*/ 
   void appFunc::execute (std::string function)
    {
      // cout<<function<<endl;
    }

  /**Write execution function primitive MoC 
  (with a number of parameters, that can be used by DNN operators)
  TODO extend or replace by DNN library */
   void appFunc::execute (std::string function,int* input, int* weights, int* output, std::map<std::string,int>* int_params_ptr )
    {
      if (function.find("CONV") != std::string::npos)
        dnnFunc::execute_conv(input, weights, output,int_params_ptr);
      if (function.find("DENSEBLOCK") != std::string::npos)
        dnnFunc::execute_dense_block(function,input, weights, output,int_params_ptr);
    }

// Data shift function (for shifting overlapping data in I/O arrays)
  /**
    * copies 2D-data line from src to dst.
    * data_h - src data height
    * data_w - src data width
    * src - pointer to first data source array element
    * dst - pointer to first copy destination array element
  */
   void appFunc::cpy_2D_data_line(const int &data_w, int *src,int *dst, const int &line_id)
    {
      int line_start = line_id * data_w;
      for (int i = 0; i < data_w ; i++)
        dst[i] = src[line_start];
    }
  /**
    * copies 2D-data line from src to dst.
    * data_h - src data height
    * data_w - src data width
    * src - pointer to first data source array element
    * dst - pointer to first copy destination array element
  */
   void appFunc::cpy_2D_data_line(const int &data_w, float *src,float *dst, const int &line_id)
    {
      int line_start = line_id * data_w;
      for (int i = 0; i < data_w ; i++)
        dst[i] = src[line_start];
    }
  /**
    * Moves 2D data on n lines to top.
    * Required for overlapping data.
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_2D (const int &h, const int &w, int *x, const int &stride)
    {
      for(int line_ind = stride; line_ind < w ; line_ind ++){
        for(int i=0; i<w; i++)
          x[i + (line_ind - stride)* w] = x[i + line_ind * w];
        }
    }
  /**
    * Moves 3D data on n lines to top.
    * Required for overlapping data.
    * d - array depth
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_3D (const int &d, const int &h, const int &w, int *x, const int &stride)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        for(int line_ind = stride; line_ind < w ; line_ind ++){
          for(int i=0; i<w; i++)
            x[i + (line_ind - stride)* w + start_elem_id] = x[i + line_ind * w + start_elem_id];
          }
        start_elem_id +=w*h;
      }
    }
  /**
    * Moves 2D data on n lines to top.
    * Required for overlapping data.
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_2D (const int &h, const int &w, float *x, const int &stride)
    {
      for(int line_ind = stride; line_ind < w ; line_ind ++){
        for(int i=0; i<w; i++)
          x[i + (line_ind - stride)* w] = x[i + line_ind * w];
        }
    }
  /**
    * Moves 3D data on n lines to top.
    * Required for overlapping data.
    * d - array depth
    * h - array height
    * w - array width
    * x - pointer to first array element
  */
   void appFunc::shift_3D (const int &d, const int &h, const int &w, float *x, const int &stride)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        for(int line_ind = stride; line_ind < w ; line_ind ++){
          for(int i=0; i<w; i++)
            x[i + (line_ind - stride)* w + start_elem_id] = x[i + line_ind * w + start_elem_id];
          }
        start_elem_id +=w*h;
      }
    }
  //2D array print function, type: int
   void appFunc::print_2D(const int &h, const int &w, int *x)
    {
      for (int i = 0; i < h; i++){
        for (int j = 0; j < w ; j++)
          std::cout << x[i * w + j] << ' ';
        std::cout<<endl;
      }
    }
  //3D array print function, type: int
   void appFunc::print_3D(const int &d, const int &h, const int &w, int *x)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        std::cout<<"depth"<<depth<<endl;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
    }
  //2D array print function, type: float
   void appFunc::print_2D(const int &h, const int &w, float *x)
    {
      for (int i = 0; i < h; i++){
        for (int j = 0; j < w ; j++)
          std::cout << x[i * w + j] << ' ';
        std::cout<<endl;
      }
    }
  //3D array print function, type: float
   void appFunc::print_3D(const int &d, const int &h, const int &w, float *x)
    {
      int start_elem_id = 0;
      for(int depth=0; depth < d; depth++ ){
        std::cout<<"depth"<<depth<<endl;
        for (int i = 0; i < h; i++){
          for (int j = 0; j < w ; j++)
            std::cout << x[i * w + j + start_elem_id] << ' ';
          std::cout<<endl;
        }
        start_elem_id +=w*h;
      }
    }

  // get fifo buffer by src
  fifo_buf* appFunc::get_buf_by_src (std::string name, std::vector<fifo_buf>& fifos){
    for (auto & fifos_elem: fifos)  {
      if (name.compare(fifos_elem.src) == 0)
        return &fifos_elem;
      }
      return nullptr;
  }

  // get fifo buffer by dst
  fifo_buf* appFunc::get_buf_by_dst (std::string name, std::vector<fifo_buf>& fifos){
    for (auto & fifos_elem: fifos)  {
      if (name.compare(fifos_elem.dst) == 0)
        return &fifos_elem;
      }
      return nullptr;
  }
